<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="MIT6-828-note-lab4, yxz的博客">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>MIT6-828-note-lab4 | yxz的博客</title>
    <link rel="icon" type="image/jpeg" href="/logo.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">yxz的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">yxz的博客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">MIT6-828-note-lab4</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                操作系统
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    28 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Lab4-note"><a href="#Lab4-note" class="headerlink" title="Lab4 note"></a>Lab4 note</h1><h2 id="1-introduction"><a href="#1-introduction" class="headerlink" title="1 introduction"></a>1 introduction</h2><p>In this lab, we should implement the preemptive multitasking mechanism among multiple simultaneously active user-mode environment. The lab is divided into 3 parts, which in each part we have disparate tasks to complete. In part A, we will add multiprocessor support to our system, while we will implement a Unix-like <code>fork</code> in part B. Ultimately, we will add support for inter-process communication (<code>IPC</code>), allowing different user-mode environments to communicate and synchronize with each other explicitly.</p>
<h2 id="2-preparation"><a href="#2-preparation" class="headerlink" title="2 preparation"></a>2 preparation</h2><p>Before starting, we are supposed to acquire some propaedeutics about multitask and multiprocessor. There are some word abbreviations about this aspect: BSP, AP, MP. Below is the explanation of them.</p>
<h3 id="2-1-operating-system-boot-up"><a href="#2-1-operating-system-boot-up" class="headerlink" title="2-1  operating system boot-up"></a>2-1  operating system boot-up</h3><p>While all processors in an MP-compliant system are functionally identical, one of the processors will be designated as the boot processor (BSP) at system initialization by system hardware or by application processors (APs). <strong>The BSP is responsible for booting the operating system.</strong> Once the MP operating system is up and running, the BSP functions as an AP. Usually a processor is designed as the BSP because it is capable of controlling all system hardware, including AP start up and shut down. The operating system must determine and remember the APIC ID of the designated BSP, so it can keep the BSP operating as the last running processor during system shut down. The BSP is not necessarily the first processor, especially in fault-tolerant MP systems in which any available processor can be designated as the BSP. There are some AP states at the time that the first instruction of the operating system is executed, while our process are in halted condition with interrupts disabled. This means that the AP’s local APICs (<code>lapic</code>) are passively monitor the APIC bus and will react only to INIT or STARTUP inter-processor interrupts (IPIs).</p>
<h3 id="2-2-AP-start-up"><a href="#2-2-AP-start-up" class="headerlink" title="2-2 AP start up"></a>2-2 AP start up</h3><p><img src="/picture/stup.png" alt=""></p>
<h2 id="3-Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#3-Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="3 Part A: Multiprocessor Support and Cooperative Multitasking"></a>3 Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>There are some new include files and source files at this stage. Let’s have a look at the crucial ones.</p>
<h3 id="3-1-mmio-map-region"><a href="#3-1-mmio-map-region" class="headerlink" title="3-1 mmio_map_region"></a>3-1 <code>mmio_map_region</code></h3><p>In <code>kern/init.c</code>, we see a function called <code>lapic_init</code> and trace into it. It brings me to a source file named <code>lapic.c</code>. A variable called <code>lapicaddr</code> is initialized in <code>mpconfig.c</code>. There are three structures: <code>mp</code>, <code>mpconf</code>, <code>mpproc</code>. There are some functions related to multiprocessor:</p>
<ul>
<li><code>sum(addr, len)</code>: It’s used to check whether all the bytes memory located at the address the <code>mp</code> variable that we want to examine contains can be add up to 0.</li>
<li><code>mpsearch1(a, len)</code>: It looks for an <code>MP</code> structure in the <code>len</code> bytes at physical address <code>addr</code>.</li>
<li><code>mpsearch(void)</code>: It searches for the <code>MP</code> Floating Pointer Structure, which according to <code>[MP 4]</code> is in one of the following three locations:<ol>
<li>in the first <code>KB</code> of <code>EBDA</code></li>
<li>if there is no <code>EBDA</code>, in the first <code>KB</code> of system base memory</li>
<li>in the BIOS ROM between <code>0xE0000</code> and <code>0xFFFFF</code></li>
</ol>
</li>
<li><code>mpconfig(struct mp **pmp)</code>: It searches for an <code>MP</code> configuration table and return a pointer pointing at a <code>mpconf</code>.</li>
</ul>
<p>Above is some basic auxiliary functions. And the most significant procedure is <code>mp_init</code>. It looks for the <code>mpconfig</code> and assign the address of local APIC to <code>lapicaddr</code>. And then it initializes <code>cpus[]</code> with the aid of the configuration we read.</p>
<p>so,we get the physical address of <code>LAPIC</code>. We can map the physical address in the virtual memory so that we can access it.</p>
<pre class=" language-lang-c"><code class="language-lang-c">//
// Reserve size bytes in the MMIO region and map [pa,pa+size) at this
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
    // Your code here:
    size = ROUNDUP(size, PGSIZE);
    if(base + size >= MMIOLIM)
        panic("mmio_map_region: out of memory\n");
    boot_map_region(kern_pgdir, base, size, pa, PTE_PCD|PTE_PWT|PTE_W);
    base += size;
}
</code></pre>
<h3 id="3-2-modify-page-init"><a href="#3-2-modify-page-init" class="headerlink" title="3-2 modify page_init"></a>3-2 modify <code>page_init</code></h3><p><img src="/picture/3-2.png" alt=""></p>
<h3 id="3-3-mem-init-mp"><a href="#3-3-mem-init-mp" class="headerlink" title="3-3 mem_init_mp"></a>3-3 <code>mem_init_mp</code></h3><p>When writing a multiprocessor OS, it is important to distinguish between per-CPU state that is private to each processor, and global state that the whole system shares. <code>kern/cpu.h</code> defines most of the per-CPU state, including <code>struct CpuInfo</code>, which stores per-CPU variables. <code>cpunum()</code> always returns the ID of the CPU that calls it, which can be used as an index into arrays like <code>cpus</code>. Alternatively, the macro <code>thiscpu</code> is shorthand for the current CPU’s <code>struct CpuInfo</code>.</p>
<p>Here is the per-CPU state you should be aware of:</p>
<ul>
<li><p><strong>Per-CPU kernel stack</strong>.<br>Because multiple CPUs can trap into the kernel simultaneously, we need a separate kernel stack for each processor to prevent them from interfering with each other’s execution. The array <code>percpu_kstacks[NCPU][KSTKSIZE]</code> reserves space for NCPU’s worth of kernel stacks.</p>
<p>In Lab 2, you mapped the physical memory that <code>bootstack</code> refers to as the BSP’s kernel stack just below <code>KSTACKTOP</code>. Similarly, in this lab, you will map each CPU’s kernel stack into this region with guard pages acting as a buffer between them. CPU 0’s stack will still grow down from <code>KSTACKTOP</code>; CPU 1’s stack will start <code>KSTKGAP</code> bytes below the bottom of CPU 0’s stack, and so on. <code>inc/memlayout.h</code> shows the mapping layout.</p>
</li>
<li><p><strong>Per-CPU TSS and TSS descriptor</strong>.<br>A per-CPU task state segment (TSS) is also needed in order to specify where each CPU’s kernel stack lives. The TSS for CPU <em>i</em> is stored in <code>cpus[i].cpu_ts</code>, and the corresponding TSS descriptor is defined in the GDT entry <code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>. The global <code>ts</code> variable defined in <code>kern/trap.c</code> will no longer be useful.</p>
</li>
<li><p><strong>Per-CPU current environment pointer</strong>.<br>Since each CPU can run different user process simultaneously, we redefined the symbol <code>curenv</code> to refer to <code>cpus[cpunum()].cpu_env</code> (or <code>thiscpu-&gt;cpu_env</code>), which points to the environment <em>currently</em> executing on the <em>current</em> CPU (the CPU on which the code is running).</p>
</li>
<li><p><strong>Per-CPU system registers</strong>.<br>All registers, including system registers, are private to a CPU. Therefore, instructions that initialize these registers, such as <code>lcr3()</code>, <code>ltr()</code>, <code>lgdt()</code>, <code>lidt()</code>, etc., must be executed once on each CPU. Functions <code>env_init_percpu()</code> and <code>trap_init_percpu()</code> are defined for this purpose.</p>
</li>
<li><p>In addition to this, if you have added any extra per-CPU state or performed any additional CPU-specific initialization (by say, setting new bits in the CPU registers) in your solutions to challenge problems in earlier labs, be sure to replicate them on each CPU here!</p>
</li>
</ul>
<p>We should accomplish the function <code>mem_init_mp</code>. The graph in <code>memlayout</code> illustrates the memory layout of different CPUs’ kernel stack in the virtual memory. The code is below:</p>
<pre class=" language-lang-c"><code class="language-lang-c">// Modify mappings in kern_pgdir to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
    // LAB 4: Your code here:
    uint32_t kstracktop_i;
    for(int i = 0; i < NCPU; i++){
        kstracktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
        boot_map_region(kern_pgdir, kstracktop_i - KSTKSIZE, 
            KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
    }
}
</code></pre>
<h3 id="3-4-trap-init-per-cpu"><a href="#3-4-trap-init-per-cpu" class="headerlink" title="3-4 trap_init_per_cpu"></a>3-4 <code>trap_init_per_cpu</code></h3><p>Task segment will store for each CPU, so we shouldn’t use <code>ts</code> anymore, and replace <code>ts</code> with <code>thiscpu</code> instead.</p>
<pre class=" language-lang-c"><code class="language-lang-c">// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
    // LAB 4: Your code here:
    // Setup a TSS so that we get the right stack
    // when we trap to the kernel.
    thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKSIZE + KSTKGAP);
    thiscpu->cpu_ts.ts_ss0 = GD_KD;
    thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);

    // Initialize the TSS slot of the gdt.
    gdt[(GD_TSS0 >> 3) + cpunum()] = SEG16(STS_T32A, (uint32_t) (&(thiscpu->cpu_ts)),
                    sizeof(struct Taskstate) - 1, 0);
    gdt[(GD_TSS0 >> 3) + cpunum()].sd_s = 0;        

    // Load the TSS selector (like other segment selectors, the
    // bottom three bits are special; we leave them 0)
    ltr(GD_TSS0 + (cpunum() << 3));

    // Load the IDT
    lidt(&idt_pd);
}
</code></pre>
<h3 id="3-5-scheduler"><a href="#3-5-scheduler" class="headerlink" title="3-5 scheduler"></a>3-5 <code>scheduler</code></h3><p>In the scheduler, we must choose a user environment to run and run it. The scheduler we will implement is a round-robin one. We scan the <code>envs</code> array from <code>curenv</code>. If <code>curenv</code> isn’t existing (That means there has not been a user environment yet.) ,The scanning will start from <code>envs[0]</code>. If some environment is runnable, run it!</p>
<pre class=" language-lang-c"><code class="language-lang-c">// Choose a user environment to run and run it.
void
sched_yield(void)
{
    struct Env *idle;
    // LAB 4: Your code here.
    int curid = curenv ? ENVX(curenv->env_id) : -1;

    for(int i = (curid + 1) % NENV; i != curid; i = (i + 1) % NENV){
        if(envs[i].env_status == ENV_RUNNABLE){
            env_run(&envs[i]);
        }
    }
    if(curenv->env_status == ENV_RUNNING){
        env_run(curenv);
    }

    // sched_halt never returns
    sched_halt();
}
</code></pre>
<h3 id="3-6-system-call"><a href="#3-6-system-call" class="headerlink" title="3-6 system call"></a>3-6 <code>system call</code></h3><p>We will provide a different, more primitive set of system calls for creating new user-mode environments. With these system calls we can implement a Unix-like <code>fork()</code> entirely in user space, in addition to other styles of environment creation. The new system calls  we need for JOS are as follows:</p>
<ul>
<li><p><code>sys_exofork</code>:</p>
<p>This system call creates a new environment with an almost blank slate: nothing is mapped in the user portion of its address space, and it is not runnable. The new environment will have the same register state as the parent environment at the time of the <code>sys_exofork</code> call. In the parent, <code>sys_exofork</code> will return the <code>envid_t</code> of the newly created environment (or a negative error code if the environment allocation failed). In the child, however, it will return 0.</p>
</li>
<li><p><code>sys_env_set_status</code>:</p>
<p>Sets the status of a specified environment to <code>ENV_RUNNABLE</code> or <code>ENV_NOT_RUNNABLE</code>. This system call is typically used to mark a new environment ready to run, once its address space and register state has been fully initialized.</p>
</li>
<li><p><code>sys_page_alloc</code>:</p>
<p>Allocates a page of physical memory and maps it at a given virtual address in a given environment’s address space.</p>
</li>
<li><p><code>sys_page_map</code>:</p>
<p>Copy a page mapping (<em>not</em> the contents of a page!) from one environment’s address space to another, leaving a memory sharing arrangement in place so that the new and the old mappings both refer to the same page of physical memory.</p>
</li>
<li><p><code>sys_page_unmap</code>: Unmap a page mapped at a given virtual address in a given environment.</p>
</li>
</ul>
<p>The description on the comments is very detailed. So I omit the details how to implement these syscalls. Here is the code:</p>
<ul>
<li><p><code>sys_exofork</code>:</p>
<pre class=" language-lang-c"><code class="language-lang-c">static envid_t
sys_exofork(void)
{
    // LAB 4: Your code here.
    struct Env *e;
    int res;
    if((res = env_alloc(&e, curenv->env_id)) < 0)
        return res;
    e->env_status = ENV_NOT_RUNNABLE;
    e->env_tf = curenv->env_tf;

    e->env_tf.tf_regs.reg_eax = 0;
    if(curenv->env_id != e->env_id)return e->env_id;
    else return 0;
    //panic("sys_exofork not implemented");
}
</code></pre>
</li>
<li><p><code>sys_env_set_status</code>:</p>
<pre class=" language-lang-c"><code class="language-lang-c">//    -E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
    // LAB 4: Your code here.
    struct Env *e;
    int res;
    if((res = envid2env(envid, &e, 1)) < 0)
        return res;
    if(    status != ENV_FREE &&
        status != ENV_DYING &&
        status != ENV_RUNNABLE &&
        status != ENV_RUNNING &&
        status != ENV_NOT_RUNNABLE
    )
    return -E_INVAL;

    e->env_status = status;
    return 0;
    //panic("sys_env_set_status not implemented");
}
</code></pre>
</li>
<li><p><code>sys_page_alloc</code>:</p>
<pre class=" language-lang-c"><code class="language-lang-c">static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
    // LAB 4: Your code here.
    struct Env *e;
    int res;
    res = envid2env(envid, &e, 1);
    if(res < 0) 
        return -E_BAD_ENV;
    if((uint32_t)va > UTOP || (uint32_t)va != ROUNDUP((uint32_t)va, PGSIZE))
        return -E_INVAL;
    struct PageInfo *pp = page_alloc(1);
    if(pp == NULL) 
        return -E_NO_MEM;
    int corperm = PTE_P | PTE_U | PTE_W | PTE_AVAIL;
    if((~corperm & perm) != 0)
        return -E_INVAL;

    res = page_insert(e->env_pgdir, pp, va, perm);
    if(res < 0){
        page_free(pp);
        return res;
    }
    pp->pp_ref++;
    return 0;
    //panic("sys_page_alloc not implemented");
}
</code></pre>
</li>
</ul>
<ul>
<li><p><code>sys_page_map</code>:</p>
<pre class=" language-lang-c"><code class="language-lang-c">static int
sys_page_map(envid_t srcenvid, void *srcva,
         envid_t dstenvid, void *dstva, int perm)
{
    // LAB 4: Your code here.
    struct Env *srcenv, *dstenv;
    int res;
    if( envid2env(srcenvid, &srcenv, 1) < 0 ||
        envid2env(dstenvid, &dstenv, 1) < 0 )
        return -E_BAD_ENV;
    if((uint32_t)srcva > UTOP || (uint32_t)srcva != ROUNDUP((uint32_t)srcva, PGSIZE))
        return -E_INVAL;
    int corperm = PTE_P | PTE_U | PTE_W | PTE_AVAIL;
    if((~corperm & perm) != 0)
        return -E_INVAL;

    pte_t *srcpte, *dstpte;
    struct PageInfo *pp;
    pp = page_lookup(srcenv->env_pgdir, srcva, &srcpte);
    if((perm&PTE_W) && (*srcpte&PTE_W) == 0) 
        return -E_INVAL;
    if(!pp)
        return -E_INVAL;
    res = page_insert(dstenv->env_pgdir, pp, dstva, perm);
    if(res < 0)return -E_NO_MEM;
    return 0;
    //panic("sys_page_map not implemented");
}
</code></pre>
</li>
</ul>
<ul>
<li><p><code>sys_page_unmap</code>: </p>
<pre class=" language-lang-c"><code class="language-lang-c">static int
sys_page_unmap(envid_t envid, void *va)
{
    // LAB 4: Your code here.
    struct Env *e;
    int res;
    res = envid2env(envid, &e, 1);
    if(res < 0) 
        return -E_BAD_ENV;
    if((uint32_t)va > UTOP || (uint32_t)va != ROUNDUP((uint32_t)va, PGSIZE))
        return -E_INVAL;

    pte_t *pte;
    struct PageInfo *pp;
    pp = page_lookup(e->env_pgdir, va, &pte);
    if(pp == NULL)
        return 0;
    page_remove(e->env_pgdir, va);
    return 0;

    //panic("sys_page_unmap not implemented");
}
</code></pre>
</li>
</ul>
<h2 id="4-Part-B-Copy-on-Write-Fork"><a href="#4-Part-B-Copy-on-Write-Fork" class="headerlink" title="4 Part B: Copy-on-Write Fork"></a>4 Part B: Copy-on-Write Fork</h2><p>At this part, we will implement a mechanism called Copy-on-Write, which allows the parent and child to <em>share</em> the memory mapped into their respective address spaces until one of the processes actually modifies it. When a write operation occurs, a page fault is triggered because the shared page is mapped with permission <code>read-only</code>. And then we can deal with the page fault with our methods. The concrete description is as followings:</p>
<p><strong>Copy-on-write (sometimes referred to as “<code>COW</code>“)</strong> is an optimization strategy used in computer programming. The fundamental idea is that if multiple callers ask for resources which are initially indistinguishable, you can give them pointers to the same resource. This function can be maintained until a caller tries to modify its “copy” of the resource, at which point a true private copy is created to prevent the changes becoming visible to everyone else. All of this happens transparently to the callers. The primary advantage is that if a caller never makes any modifications, no private copy need ever be created. It avoids a lot of unnecessary overhead.</p>
<p>In OS world, creating a process is a significant field of the application of <code>COW</code>. We can use <code>fork()</code> or <code>vfork()</code> to create a new process. <code>vfork</code> follows the concept of copy-on-write. For example, the child process created by <code>vfork</code> will share the data and code segment with the parent process. This speeds up the forking time. It is expected to use <code>vfork</code> if you are performing <code>exec</code> followed by <code>vfork</code>. So <code>vfork</code> will create the child process which will share data and code segment with its parent but when we call exec, it will load up the image of a new executable in the address space of the child process. In our lab, <code>fork</code> in <code>lib/fork.c</code> is so similar to <code>vfork</code>.</p>
<h3 id="4-1-sys-env-set-pgfault-upcall"><a href="#4-1-sys-env-set-pgfault-upcall" class="headerlink" title="4-1 sys_env_set_pgfault_upcall"></a>4-1 <code>sys_env_set_pgfault_upcall</code></h3><p>When a process wants to write on a page marked <code>COW</code>(with the permission <code>read-only</code>), a page fault occur. If we want to deal with the fault in user space, we should install a user page fault handler for the kernel. <code>sys_env_set_pgfault_upcall</code> is the function that install a user page fault handler. The code is below:</p>
<pre class=" language-lang-c"><code class="language-lang-c">static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
    // LAB 4: Your code here.
    struct Env *e;
    int ret = 0;
    ret = envid2env(envid, &e, 1);
    if(ret < 0)return -E_BAD_ENV;
    e->env_pgfault_upcall = func;
    return 0;
}
</code></pre>
<h3 id="4-2-page-fault-handler"><a href="#4-2-page-fault-handler" class="headerlink" title="4-2 page_fault_handler"></a>4-2 <code>page_fault_handler</code></h3><p>After installing the user page fault handler, we are supposed to modify page fault handler in kernel, make the OS run the page fault handler in user space. </p>
<ul>
<li>Set up a page fault stack frame on the user exception stack (below <code>UXSTACKTOP</code>)</li>
<li>branch to <code>curenv-&gt;env_pgfault_upcall</code></li>
<li>pay attention to dealing with the recursive case!</li>
</ul>
<p>emmm… You may have a question why we need a exception stack. In my opinion, it ensures the consistency of operations that deal with all the pages in virtual memory except user exception stack. (Maybe)</p>
<pre class=" language-lang-c"><code class="language-lang-c">void
page_fault_handler(struct Trapframe *tf)
{
    uint32_t fault_va;
    // Read processor's CR2 register to find the faulting address
    fault_va = rcr2();
    // Handle kernel-mode page faults.
    // LAB 3: Your code here.
    if( (tf->tf_cs & 3) == 0){
        cprintf("[%08x] user fault va %08x ip %08x\n",
        curenv->env_id, fault_va, tf->tf_eip);
        print_trapframe(tf);
        panic("kernel page fault\n");
    }

    // LAB 4: Your code here.
    // Destroy the environment that caused the fault.
    if(curenv->env_pgfault_upcall == NULL){
        //cprintf("111\n");
        cprintf("[%08x] user fault va %08x ip %08x\n",
        curenv->env_id, fault_va, tf->tf_eip);
        print_trapframe(tf);
        env_destroy(curenv);
    }

    uint32_t size = 0, stktop = 0;
    if(tf->tf_esp < UXSTACKTOP && tf->tf_esp >= UXSTACKTOP - PGSIZE){
        size = sizeof(struct UTrapframe) + sizeof(uint32_t);
        stktop = tf->tf_esp;
        //cprintf("%x\n",stktop - size);
    }
    else{
        size = sizeof(struct UTrapframe);
        stktop = UXSTACKTOP;
        //cprintf("aa %x\n",stktop - size);
    }
    user_mem_assert(curenv, (void *)(stktop - size), size, PTE_U|PTE_P|PTE_W);

    struct UTrapframe *utf = (struct UTrapframe *)(stktop - size);
    utf->utf_esp = tf->tf_esp;
    utf->utf_eflags = tf->tf_eflags;
    utf->utf_eip = tf->tf_eip;
    utf->utf_regs = tf->tf_regs;
    utf->utf_err = tf->tf_err;
    utf->utf_fault_va = fault_va;

    curenv->env_tf.tf_esp = (uintptr_t)utf;
    curenv->env_tf.tf_eip = (uint32_t)curenv->env_pgfault_upcall;
    env_run(curenv);

}
</code></pre>
<h3 id="4-3-pgfault-upcall"><a href="#4-3-pgfault-upcall" class="headerlink" title="4-3  _pgfault_upcall"></a>4-3  <code>_pgfault_upcall</code></h3><p>Now we come to the entry of user page fault handler, <code>_pgfault_upcall</code> can be seen as a scheduler of <code>_pgfault_handler</code> (the entity of user page handler). After returning from <code>_pgfault_handler</code>, there are a trap frame lying on user exception stack. We add 8 to <code>esp</code> to skip over <code>fault_va</code> and <code>error_code</code>. <code>esp</code> now points at the regular register. Because later we will <code>ret</code> to the location where the page fault occurs, we should move the <code>eip</code> to the user stack.  Then restore the trap-time registers and switch to user stack.</p>
<p><img src="/picture/utf.png" alt=""></p>
<p>Here is the code:</p>
<pre class=" language-lang-assembly"><code class="language-lang-assembly">.text
.globl _pgfault_upcall
_pgfault_upcall:
    // Call the C page fault handler.
    pushl %esp            // function argument: pointer to UTF
    movl _pgfault_handler, %eax
    call *%eax
    addl $4, %esp            // pop function argument

    //significant, move eip to the user stack in order to ret
    // LAB 4: Your code here.
    addl $8, %esp
    movl 0x20(%esp), %eax 
    movl 0x28(%esp), %ecx
    subl $4, %ecx
    movl %ecx, 0x28(%esp)
    movl %eax, (%ecx)

    // Restore the trap-time registers.  After you do this, you
    // can no longer modify any general-purpose registers.
    // LAB 4: Your code here.
    popal

    // Restore eflags from the stack.  After you do this, you can
    // no longer use arithmetic operations or anything else that
    // modifies eflags.
    // LAB 4: Your code here.
    addl $4, %esp
    popfl

    // Switch back to the adjusted trap-time stack.
    // LAB 4: Your code here.
    popl %esp

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.
    ret
</code></pre>
<h3 id="4-4-COW-fork"><a href="#4-4-COW-fork" class="headerlink" title="4-4 COW fork"></a>4-4 <code>COW fork</code></h3><p>Here is the code:</p>
<pre class=" language-lang-c"><code class="language-lang-c">static void
pgfault(struct UTrapframe *utf)
{
    void *addr = (void *) utf->utf_fault_va;
    uint32_t err = utf->utf_err;
    int r;
    // LAB 4: Your code here.
    pte_t pte = uvpt[PGNUM(addr)];

    //cprintf("%e\n",err);
    if( (err&FEC_WR) == 0 && (pte & PTE_COW)){
        cprintf("%x\n",addr);
        panic("pgfault: it's not a write err\n");
    }
    // LAB 4: Your code here.
    addr = ROUNDDOWN(addr, PGSIZE);

    //allocate a new page, and map it at PFTEMP
    if(sys_page_alloc(0, (void *)PFTEMP, PTE_P|PTE_W|PTE_U) < 0){
        panic("sys_page_alloc: alloc failed\n");
    }

    //move the content at virtual address addr to PFTEMP
    memmove((void *)PFTEMP, addr, PGSIZE);

    //remap the page at PFTEMP at new virtual address addr
    //Here was a small bug troubling me for a long time, which I ignored PTE_W !!!
    if(sys_page_map(0, (void *)PFTEMP, 0, (void *)addr, PTE_W|PTE_U|PTE_P) < 0){
        panic("map failed\n");
    }

    //unmap the virtual address PFTEMP
    if(sys_page_unmap(0, (void *)PFTEMP) < 0){
        panic("failed\n");
    }
}

static int
duppage(envid_t envid, unsigned pn)
{
    int r;
    struct Env *dstenv = (struct Env *)envs + ENVX(envid);
    void *addr = (void *)(pn * PGSIZE);
    //the pte is certainly existing, because fork will check it.
    pte_t pte = uvpt[pn];
    // LAB 4: Your code here.


    if((pte&PTE_COW) || (pte&PTE_W)){

        if((r = sys_page_map(0, addr, dstenv->env_id, addr, PTE_P|PTE_U|PTE_COW)) < 0){
            cprintf("sys_page_map: %e\n", r);
        }
        if((r = sys_page_map(0, addr, 0, addr, PTE_P|PTE_U|PTE_COW)) < 0){
            cprintf("sys_page_map: %e\n", r);
        }
    }
    else{
        sys_page_map(0,addr, dstenv->env_id, addr, PTE_U|PTE_P);
    }

    return 0;
}

envid_t
fork(void)
{
    // LAB 4: Your code here.
    envid_t envid;
    uint8_t *addr;
    int r;
    uint32_t pn;

    set_pgfault_handler(pgfault);

    envid = sys_exofork();

    //sys_exfork returns from child 
    if (envid == 0) {
        thisenv = &envs[ENVX(sys_getenvid())];
        return 0;
    }

    // operate through all the page below UTOP
    for (addr = 0; (uint32_t)addr < USTACKTOP; addr += PGSIZE){
        pn = PGNUM(addr);
        if( (PTE_P & uvpd[PDX(addr)]) && (PTE_P&uvpt[pn])){        
            duppage(envid, pn);
        }
    }

    // allocate a new page for UXSTACKTOP
    sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_W|PTE_U|PTE_P);

    if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0){
        panic("sys_env_set_status: %e", r);
    }

    return envid;
</code></pre>
<h2 id="5-Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#5-Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="5 Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>5 Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><h3 id="5-1-Preemptive-Multitasking"><a href="#5-1-Preemptive-Multitasking" class="headerlink" title="5-1 Preemptive Multitasking"></a>5-1 <code>Preemptive Multitasking</code></h3><p>In this part, we will implement preemptive multitasking, forcefully retaking control of the CPU from it. In order to achieve it, we must extend our kernel to support external hardware interrupts from the clock hardware. We should add some entries to both <code>trapentry.S</code> and <code>IDT</code>:</p>
<ul>
<li><p><code>trapentry.S</code>:</p>
<pre class=" language-lang-c"><code class="language-lang-c">TRAPHANDLER_NOEC(irq_timer, IRQ_OFFSET + IRQ_TIMER)
TRAPHANDLER_NOEC(irq_kbd, IRQ_OFFSET + IRQ_KBD)
TRAPHANDLER_NOEC(irq_serial, IRQ_OFFSET + IRQ_SERIAL)
TRAPHANDLER_NOEC(irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS)
TRAPHANDLER_NOEC(irq_ide, IRQ_OFFSET + IRQ_IDE)
TRAPHANDLER_NOEC(irq_error, IRQ_OFFSET + IRQ_ERROR)
</code></pre>
</li>
<li><p>extend IDT in <code>trap.c</code></p>
<pre class=" language-lang-c"><code class="language-lang-c">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, irq_timer, 0);
    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], 0, GD_KT, irq_kbd, 0);
    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], 0, GD_KT, irq_serial, 0);
    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], 0, GD_KT, irq_spurious, 0);
    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], 0, GD_KT, irq_ide, 0);
    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, irq_error, 0);
</code></pre>
</li>
</ul>
<p>By now, the basic settings are done.</p>
<p>Then we make interrupt enabled in user environment. The first thing is enable interrupts while initializing an environment:</p>
<p>In <code>env_alloc</code>, we add <code>e-&gt;env_tf.tf_eflags |= FL_IF;</code> to enable interrupts, so that a user environment starts running with IF set to 1. Don’t forget to uncomment <code>'sti'</code>. Then modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p>
<pre class=" language-lang-c"><code class="language-lang-c">    // Handle clock interrupts. Don't forget to acknowledge the
    // interrupt using lapic_eoi() before calling the scheduler!
    // LAB 4: Your code here.
    if(tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER){
        lapic_eoi();
        sched_yield();
        return;
    }
</code></pre>
<h3 id="5-2-IPC"><a href="#5-2-IPC" class="headerlink" title="5-2 IPC"></a>5-2 <code>IPC</code></h3><p>It’s enough to read the guide of this part and comments in codes to accomplish <code>IPC</code>.</p>
<p>The followings is <code>syscall</code>:</p>
<pre class=" language-lang-c"><code class="language-lang-c">// Try to send 'value' to the target env 'envid'.
// If srcva < UTOP, then also send page currently mapped at 'srcva',
// so that receiver gets a duplicate mapping of the same page.
//
// The send fails with a return value of -E_IPC_NOT_RECV if the
// target is not blocked, waiting for an IPC.
//
// The send also can fail for the other reasons listed below.
//
// Otherwise, the send succeeds, and the target's ipc fields are
// updated as follows:
//    env_ipc_recving is set to 0 to block future sends;
//    env_ipc_from is set to the sending envid;
//    env_ipc_value is set to the 'value' parameter;
//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.
// The target environment is marked runnable again, returning 0
// from the paused sys_ipc_recv system call.  (Hint: does the
// sys_ipc_recv function ever actually return?)
//
// If the sender wants to send a page but the receiver isn't asking for one,
// then no page mapping is transferred, but no error occurs.
// The ipc only happens when no errors occur.
//
// Returns 0 on success, < 0 on error.
// Errors are:
//    -E_BAD_ENV if environment envid doesn't currently exist.
//        (No need to check permissions.)
//    -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,
//        or another environment managed to send first.
//    -E_INVAL if srcva < UTOP but srcva is not page-aligned.
//    -E_INVAL if srcva < UTOP and perm is inappropriate
//        (see sys_page_alloc).
//    -E_INVAL if srcva < UTOP but srcva is not mapped in the caller's
//        address space.
//    -E_INVAL if (perm & PTE_W), but srcva is read-only in the
//        current environment's address space.
//    -E_NO_MEM if there's not enough memory to map srcva in envid's
//        address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
    // LAB 4: Your code here.
    //cprintf("send\n");
    struct Env *dstenv;
    int r = 0;
    if(envid2env(envid, &dstenv, 0) < 0){
        return -E_BAD_ENV;
    }
    if(dstenv->env_ipc_recving == false){
        return -E_IPC_NOT_RECV;
    }
    if((uint32_t)srcva < UTOP && srcva != ROUNDDOWN(srcva, PGSIZE)){
        return -E_INVAL;
    }
    int corperm = PTE_P | PTE_U | PTE_W | PTE_AVAIL;
    if((uint32_t)srcva < UTOP && (~corperm & perm) != 0){
        return -E_INVAL;
    }
    struct PageInfo *pp, *pp2;
    pte_t *ptep, *dstptep;


    pp = page_lookup(curenv->env_pgdir, srcva, &ptep);
    if((uint32_t)srcva < UTOP && pp == NULL){
        return -E_INVAL;
    }
    if(((*ptep) & PTE_W) == 0 && (perm & PTE_W)){
        return -E_INVAL;
    }
    if((uint32_t)srcva !=UTOP && (uint32_t)(dstenv->env_ipc_dstva) == UTOP){
        return 0;
    }

    if((uint32_t)srcva != UTOP){
        if( envid2env(envid, &dstenv, 0) < 0 ){
            return -E_BAD_ENV;
        }
        pp2 = page_lookup(dstenv->env_pgdir, srcva, &dstptep);
        if(pp2 != NULL){
            return -E_NO_MEM;
        }
        if(page_insert(dstenv->env_pgdir, pp, dstenv->env_ipc_dstva, perm) < 0){
            return -E_NO_MEM;
        }
    }

    dstenv->env_ipc_recving = false;
    dstenv->env_ipc_from = curenv->env_id;
    dstenv->env_ipc_value = value;
    dstenv->env_ipc_perm = srcva ? perm : 0;
    dstenv->env_status = ENV_RUNNABLE;
    return 0;
    //panic("sys_ipc_try_send not implemented");
}

// Block until a value is ready.  Record that you want to receive
// using the env_ipc_recving and env_ipc_dstva fields of struct Env,
// mark yourself not runnable, and then give up the CPU.
//
// If 'dstva' is < UTOP, then you are willing to receive a page of data.
// 'dstva' is the virtual address at which the sent page should be mapped.
//
// This function only returns on error, but the system call will eventually
// return 0 on success.
// Return < 0 on error.  Errors are:
//    -E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
    // LAB 4: Your code here.
    //cprintf("recv\n");

    if((uint32_t)dstva < UTOP && (uint32_t)dstva != ROUNDDOWN((uint32_t)dstva, PGSIZE)){
        return -E_INVAL;
    }

    curenv->env_ipc_recving= true;
    curenv->env_ipc_dstva = dstva;
    curenv->env_status = ENV_NOT_RUNNABLE;
    return 0;
    //cprintf("finish schedule\n");
    //panic("sys_ipc_recv not implemented");
    //return 0;
}
</code></pre>
<ul>
<li><code>ipc.c</code></li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">// Receive a value via IPC and return it.
// If 'pg' is nonnull, then any page sent by the sender will be mapped at
//    that address.
// If 'from_env_store' is nonnull, then store the IPC sender's envid in
//    *from_env_store.
// If 'perm_store' is nonnull, then store the IPC sender's page permission
//    in *perm_store (this is nonzero iff a page was successfully
//    transferred to 'pg').
// If the system call fails, then store 0 in *fromenv and *perm (if
//    they're nonnull) and return the error.
// Otherwise, return the value sent by the sender
//
// Hint:
//   Use 'thisenv' to discover the value and who sent it.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
    // LAB 4: Your code here.
    int r;
    if(pg == NULL){
        pg = (void *)UTOP;
    }
    //cprintf("%x\n", (uint32_t)pg);

    while(1){
        r = sys_ipc_recv(pg);
        if(r < 0){

            if(from_env_store != NULL) *from_env_store = 0;
            if(perm_store != NULL) *perm_store = 0;
            //cprintf("error: %e\n", r);
            return r;
        }
        if(thisenv->env_ipc_recving == false)break;
    }

    if(from_env_store != NULL){
        *from_env_store = thisenv->env_ipc_from;
    }

    if(perm_store != NULL){
        *perm_store = thisenv->env_ipc_perm;
    }

    return thisenv->env_ipc_value;
    //panic("ipc_recv not implemented");
    return 0;
}

// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
// This function keeps trying until it succeeds.
// It should panic() on any error other than -E_IPC_NOT_RECV.
//
// Hint:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
    // LAB 4: Your code here.
    int r = 0;
    if(pg == NULL){
        pg = (void *)UTOP;
    }
    while(1){
        r = sys_ipc_try_send(to_env, val, pg, perm);
        if(r == 0){ 
            break;
        }
        else if(r != -E_IPC_NOT_RECV){
            panic("ipc_send: %e\n", r);
        }
        sys_yield();
    }
    //panic("ipc_send not implemented");
}
</code></pre>
<h2 id="6-Question"><a href="#6-Question" class="headerlink" title="6 Question"></a>6 Question</h2><ol>
<li><p>question: Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?</p>
<p>answer:  Below is the macro <code>MPBOOTPHYS</code>. As we know, the symbol <code>mpentry_start</code> is linked at the link address that is above <code>KERNBASE</code>, but when a <code>CPU</code> initially starts, it begins in real mode. The load address begins at <code>0x7000</code> (<code>MPENTRY_PADDR</code>), so the macro is designated for translate a link address to the corresponding load address, which allows the <code>CPU</code> can work well before turning on paging.</p>
<pre class=" language-lang-c"><code class="language-lang-c">#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)
</code></pre>
</li>
</ol>
<h2 id="7-reference"><a href="#7-reference" class="headerlink" title="7 reference"></a>7 reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf">MultiProcessor Specification (mit.edu)</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/628938/what-is-copy-on-write#:~:text=&quot;Copy on write&quot; means more or less what,is used to resolve concurrency sorts of problems.">optimization - What is copy-on-write? - Stack Overflow</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labs/lab4/">Lab 4: Preemptive Multitasking (mit.edu)</a></li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">yxz</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://changanyyy.github.io/2021/08/15/MIT6-828-note-lab4/">http://changanyyy.github.io/2021/08/15/MIT6-828-note-lab4/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">yxz</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">您的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/08/23/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA-%E7%BB%AA%E8%AE%BA/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="形式语言与自动机 绪论">
                        
                        <span class="card-title">形式语言与自动机 绪论</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            形式语言，自动机理论
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/" class="post-category">
                                    形式语言，自动机理论
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/">
                        <span class="chip bg-color">形式语言，自动机理论</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/08/07/Software-Reliable-Method-ch3/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Software Reliable Method ch3">
                        
                        <span class="card-title">Software Reliable Method ch3</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            软件形式化
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BD%A2%E5%BC%8F%E5%8C%96/" class="post-category">
                                    软件形式化
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%BD%A2%E5%BC%8F%E5%8C%96/">
                        <span class="chip bg-color">软件形式化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: yxz的博客<br />'
            + '文章作者: yxz<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">yxz</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/changanyyy" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:191220146@smail.nju.edu.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1263522794" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1263522794" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
