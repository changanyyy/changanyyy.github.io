<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络笔记网络层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/06/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图中的最长路径"><a href="#有向无环图中的最长路径" class="headerlink" title="有向无环图中的最长路径"></a>有向无环图中的最长路径</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为一个数字<code>n</code>，表示总点数。之后点的标号为从<code>0</code>到<code>n-1</code>。</p><p>之后的每一行，格式为<code>3</code>个数字，以空格隔开，分别为相连的两个点的编号，它们的边的权值。</p><p>注：输入为有向图。如果出现了<code>“0 1 50”</code>表示点<code>0</code>到点<code>1</code>之间有一条边，权值为<code>50</code>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>点0到其他所有点的最长路径，以空格隔开。注：点0到其他所有点都是可达的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度要求在<strong>O(m+n)</strong></p><p>样例输入输出</p><pre class="line-numbers language-none"><code class="language-none">输入：60 1 10 3 21 2 62 4 12 5 23 4 33 1 44 5 1输出：6 12 2 13 14 </code></pre><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先，看到复杂度是线性时间复杂度，我们想到不太可能用类似<code>Dijkstra</code>，<code>Prime</code>之类的算法，大概是用一个<code>DFS</code>或者<code>BFS</code>框架来完成。</p><p>对于有向无环图，我们会敏锐地发觉它的一些特性：从0经过某些顶点之前，路径上必然会经过另一些顶点！！！如果我们在处理顶点A之前，对它之前的所有顶点的路径进行处理的话，我们就可以依托之前的路径来对顶点A进行处理。这句话怎么听起来这么耳熟？没错，这似乎就是动态规划的具体做法！</p><p>众所周知，动态规划的思路就是<strong>利用前面已经求出的子问题来解决其他的子问题</strong>。我们通过前面经过的顶点来求后面的顶点，与这个思想相符。那么我们怎么判断谁在前谁在后呢？联系算法需要的线性复杂度，我们联想到<code>Topo</code>排序，对顶点进行拓扑序小的在前面，拓扑序大的在后面。那么基本的思路逐渐清晰了。</p><p>先利用拓扑排序对顶点进行排序，这样我在遍历某一个顶点A的时候，从0到A的路径上的所有顶点必然已经被遍历过！那么我们如何找到他前面的顶点呢？做法有两种，第一种是建立一个逆邻接表，这样就可以找到哪一个路径通向点A；第二种做法是在遍历A前面节点X的时候，直接对X的邻居进行处理，这样在遍历到A的时候，A已经被处理完了，A的任务就只变成了对A的邻居进行处理。这两种做法本质上是一样的，但是鉴于省下更多的时间和空间，我采用了第二种方法！</p><p>复杂度分析：<code>topo</code>排序是线性复杂度，后面的<code>DP</code>也是线性复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面我们就可以进行Coding了！代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std; //邻接表节点，存储邻居节点和路径长度struct node {    int v, weight;    node(int _v, int _w) { v = _v; weight = _w; }};//邻接表，二维矩阵vector&lt;vector&lt;node&gt;&gt; table;//topo的本质是DFS，需要visit数组vector&lt;bool&gt; visit;//存储topo序，顶端的topo序更小stack&lt;int&gt; topo;//存储答案vector&lt;int&gt; res; void dfs(int v) {    visit[v] = true;    for (int i = 0; i &lt; table[v].size(); i++) {        if(!visit[table[v][i].v])dfs(table[v][i].v);    }    topo.push(v);//在处理过v后面所有的节点之后，v的节点topo序要小于它后面的所有节点} int main() {    int n;    scanf("%d", &amp;n);//初始化         res = vector&lt;int&gt;(n, 0);    visit = vector&lt;bool&gt;(n, false);    table = vector&lt;vector&lt;node&gt;&gt;(n);    int v1, v2, w;    while (scanf("%d %d %d",&amp;v1,&amp;v2,&amp;w)!=-1) {        table[v1].push_back(node(v2, w));    }     dfs(0);//topo排序     while (!topo.empty()) {        int cur = topo.top();        topo.pop();        for (int i = 0; i &lt; table[cur].size(); i++) {//处理cur的邻居            res[table[cur][i].v] = max(res[table[cur][i].v], res[cur] + table[cur][i].weight);        }    }    for (int i = 1; i &lt; n; i++) {        printf("%d ", res[i]);    }     return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记链路层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="不同类型的局域网"><a href="#不同类型的局域网" class="headerlink" title="不同类型的局域网"></a>不同类型的局域网</h1><h2 id="1-令牌环"><a href="#1-令牌环" class="headerlink" title="1.令牌环"></a>1.令牌环</h2><h2 id="2-以太网"><a href="#2-以太网" class="headerlink" title="2.以太网"></a>2.以太网</h2><p>以太网是一种主导有线局域网的技术，有如下的好处：</p><ul><li>NIC比较便宜</li><li>首先被广泛运用于局域网技术</li><li>比令牌局域网和ATM简单廉价</li><li>速度比较不错</li></ul><h3 id="以太网的物理拓扑"><a href="#以太网的物理拓扑" class="headerlink" title="以太网的物理拓扑"></a>以太网的物理拓扑</h3><h4 id="总线：在90年代中期很流行"><a href="#总线：在90年代中期很流行" class="headerlink" title="总线：在90年代中期很流行"></a>总线：在90年代中期很流行</h4><p>所有节点在同一个碰撞域中，可以互相碰撞</p><h4 id="星型拓扑：现在比较盛行"><a href="#星型拓扑：现在比较盛行" class="headerlink" title="星型拓扑：现在比较盛行"></a>星型拓扑：现在比较盛行</h4><p>每一个节点运行一个分离的以太网协议，不会相互碰撞</p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20210607141806849.png" alt="image-20210607141806849" style="zoom:50%;"><p>下面说说他们的比较；广播vs交换以太网</p><p>总线拓扑是一种广播技术</p><ul><li>主机之间共享信道</li><li>每个包被所有相连的主机收到</li><li>通过CSMA/CD来进行媒体访问控制</li></ul><p>现代的以太网是交换以太网</p><ul><li>链路是交换机之间或者交换机和主机之间的</li><li>不需要共享信道-&gt;不用CSMA/CD</li><li>依靠自学习和生成树算法来路由！！</li></ul><h3 id="以太网的发展演变"><a href="#以太网的发展演变" class="headerlink" title="以太网的发展演变"></a>以太网的发展演变</h3><p>从共享媒介的线缆变成专用链路！</p><p>速度从3Mbps变成100Gbps！</p><p>从电子信号变成光信号！</p><p>我们从中学到什么？正确的方法（比如以太网）可以经受得住很多改变，并且在保持方法的时候要更新技术！（后向兼容）</p><h3 id="以太网：不可靠，无连接"><a href="#以太网：不可靠，无连接" class="headerlink" title="以太网：不可靠，无连接"></a>以太网：不可靠，无连接</h3><p>无连接是说在收发的NIC之间没有握手的过程</p><p>不可靠是说接收者的NIC不给发送者的NIC发送确认消息，这样只有更上层的协议有可靠传输协议才可以让丢掉的包得到恢复，否则抛弃的包就丢了！</p><h3 id="以太网帧的格式"><a href="#以太网帧的格式" class="headerlink" title="以太网帧的格式"></a>以太网帧的格式</h3><p>前导码Preamble：有七个字节，为了时钟同步，有一个字节指出帧的开始！</p><p>MAC地址Addresses：6字节，一共48bit</p><p>类型Type：2字节，填入上层协议，比如IP</p><p>数据负载Data payload：最大1500字节，最小46字节</p><p>CRC循环冗余码：4字节，一共32bit，进行错误检测</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>MAC地址是一个和网络适配器有关的数值地址</p><p>有48bit的名空间，比如16进制的00-15-C5-49-04-A9</p><p>当适配器生产时候就有一个独一无二的硬编码MAC地址</p><h5 id="MAC地址的分配"><a href="#MAC地址的分配" class="headerlink" title="MAC地址的分配"></a>MAC地址的分配</h5><p>分为不同的块，在MAC地址的前3个字节，被分配给不同的厂家，下面的3个字节由厂家来分配给每一个适配器</p><h3 id="成帧Framing-frames"><a href="#成帧Framing-frames" class="headerlink" title="成帧Framing frames"></a>成帧Framing frames</h3><p>物理层把bit放入链路，但是两个联通在相同物理媒介的主机需要交换帧，这个服务由链路层提供，由网络适配器来实现！</p><p>那么有一个问题：链路层如何判断每个帧的起止位置呢？</p><ol><li>简单的方法：比特计数，在帧的开始填入后面所跟的数据的大小，然后接受者根据这个值来解析！有一个缺点就是，如果这个计数的数值错了，将导致后面的帧全部错误！</li><li>哨兵位：用哨兵来标记帧的起止位置，<code>01111110</code>表示开始，<code>01111111</code>表示结束。但是有一个问题，如果在数据里面有哨兵怎么办？问题的解决办法是比特填充，如果在内容里面遇到5个1就在后面插入一个0，然后接收方每遇到5个1就拿掉后面的1个0！</li></ol><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20210607145115984.png" alt="image-20210607145115984" style="zoom:50%;"><p>举个例子，如果接收者看见了5个1：后面如果是0，那么就移走它继续解析；如果后面是1的话再看下一位，下一位是0，说明是帧的开始，否则是帧的结束！</p><h3 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h3><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20210607145201877.png" alt="image-20210607145201877" style="zoom:50%;"><h4 id="802-3的物理层"><a href="#802-3的物理层" class="headerlink" title="802.3的物理层"></a>802.3的物理层</h4><p>有许多不同的标准：</p><ul><li>类似的MAC协议和帧格式</li><li>不同的速率：2Mbps，10Mbps，100Mbps，1Gbps，10Gbps</li><li>不同的物理媒介：线缆，光纤</li></ul><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20210607145639218.png" alt="image-20210607145639218" style="zoom:70%;">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
