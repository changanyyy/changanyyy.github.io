<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT6.828操作系统笔记Lab1</title>
      <link href="/2021/07/12/MIT6-828-note-lab1/"/>
      <url>/2021/07/12/MIT6-828-note-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h2><p>本学期上完了操作系统课程，感觉OS真的是一门很高级的学问，涉及了计算机最底层的东西，私以为要盖好上层建筑，就必须把基本功打好，这是内功。在学长的推荐下，我决定做一下6.828的实验！在经过一学期的英文文档阅读之后，看见英文的东西已经不打怵了，说不上进步多大，但肯定是有进步的！</p><p>下面附上课程网站：<code>[6.828 / Fall 2018 (mit.edu)](https://pdos.csail.mit.edu/6.828/2018/schedule.html)</code></p><h2 id="二-Lab1"><a href="#二-Lab1" class="headerlink" title="二.Lab1"></a>二.Lab1</h2><pre class="line-numbers language-none"><code class="language-none">+------------------+  &lt;- 0xFFFFFFFF (4GB)|      32-bit      ||  memory mapped   ||     devices      ||                  |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\|                  ||      Unused      ||                  |+------------------+  &lt;- depends on amount of RAM|                  ||                  || Extended Memory  ||                  ||                  |+------------------+  &lt;- 0x00100000 (1MB)|     BIOS ROM     |+------------------+  &lt;- 0x000F0000 (960KB)|  16-bit devices, ||  expansion ROMs  |+------------------+  &lt;- 0x000C0000 (768KB)|   VGA Display    |+------------------+  &lt;- 0x000A0000 (640KB)|                  ||    Low Memory    ||                  |+------------------+  &lt;- 0x00000000</code></pre><h3 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1.BIOS"></a>1.BIOS</h3><h4 id="1-1-BIOS的基本功能"><a href="#1-1-BIOS的基本功能" class="headerlink" title="1-1 BIOS的基本功能"></a>1-1 BIOS的基本功能</h4><p>在我们给计算机加电之后，CPU第一个执行的指令就是BIOS的指令，从GDB里面我们可以看出，就是下面这一行，这时<code>CS=0xf000</code>并且<code>IP=0xfff0</code>，所以现在这个指令在地址<code>0xffff0</code>处。我们可以看出来，在实地址模式下，几乎已经达到了寻址空间的尽头，后面为数不多的空间不够存放几条指令了。实际上，真正的<code>BIOS</code>的真正代码在更低地址处。所以我们需要通过下面的指令跳转到相应位置。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b</code></pre><p><code>ljmp</code>的意思是长跳转，，也就是说跳转到<code>0xfe05b</code>地址处，可以看出，确实是在第一条指令的前面！</p><p>后面<code>BIOS</code>完成自己后续任务，包括设置中断描述符表和初始化各种设备，比如<code>VGA</code>。在做完这些工作之后，<code>BIOS</code>寻找可引导的设备，当它发现可引导的磁盘时，<code>BIOS</code>从磁盘读出<code>bootloader</code>然后把控制权交给它！</p><p>我总结了一下：<code>BIOS</code>起到一个最原始的引导的作用，主要功能是检查硬件，加载bootloader，然后把控制权交给<code>bootloader</code>。而对于设置中断描述符表之类的事情，其实并不是<code>BIOS</code>必须要做的事情，算是拓展功能。而且因为跟硬件的初始化相关，所以BIOS是硬件厂商来制定比较好，也就是说，如果足够精简的BIOS甚至可以把所有的任务都交给bootloader。BIOS相对于用户来说是透明的，而bootloader才是真正操作系统的一部分。而BIOS的具体内容是什么，其实并不在操作系统的范围内。（其实<code>bootloader</code>也不算）。</p><h4 id="1-2-知识补充"><a href="#1-2-知识补充" class="headerlink" title="1-2 知识补充"></a>1-2 知识补充</h4><h5 id="1-2-1-地址卷绕"><a href="#1-2-1-地址卷绕" class="headerlink" title="1-2-1 地址卷绕"></a>1-2-1 地址卷绕</h5><p>用两个 16 位的寄存器左移相加来得到 20 位的内存地址这里还是有问题。那就是两个 16 位数相加所得的最大结果是超过 20 位的。例如段基址 0xffff 左移变成 0xffff0 和偏移量 0xffff 相加得到 0x10ffef 这个内存地址是“溢出”的，怎么办？这里 CPU 被设计出来一个“卷绕”机制，当内存地址超过 20 位则绕回来。举个例子你拿 0x100001 来寻址，我就拿你当作 0x00001 。你超出终点我就把你绕回起点。</p><h5 id="1-2-2-A20总线"><a href="#1-2-2-A20总线" class="headerlink" title="1-2-2 A20总线"></a>1-2-2 A20总线</h5><p>现代的 x86 计算机，无论你是 32 位的还是 64 位的，在开机的那一刻 CPU 都是以模拟 16 位模式运行的，地址卷绕机制也是有效的，所以无论你的电脑内存有多大，开机的时候 CPU 的寻址能力只有 1MB，就好像回到 8086 时代一样。那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。</p><h3 id="2-BootLoader"><a href="#2-BootLoader" class="headerlink" title="2.BootLoader"></a>2.BootLoader</h3><p><code>BootLoader</code>完成以下的几种任务：</p><ol><li><code>BootLoader</code>先把CPU从实地址模式转换成32位的保护模式，因为只有运行在保护模式的软件才可以访问超过<code>1MB</code>的地址空间！</li><li>下一步，它把操作系统内核读入内存中，最后把控制权交给内核！</li></ol><p>通过查看反汇编的<code>obj/boot/boot.asm</code>，我们可以看出，<code>bootloader</code>的第一行代码被<code>BIOS</code>存放在地址为<code>0x7c00</code>的位置，通过<code>jmp</code>指令设置<code>CS:IP</code>为<code>0000:7c00</code>，把控制权交给它</p><h4 id="2-1-boot-S分析"><a href="#2-1-boot-S分析" class="headerlink" title="2-1 boot.S分析"></a>2-1 <code>boot.S</code>分析</h4><p>下面进入bootloader的实体了，它做了如下工作：</p><ol><li><p>关闭中断，CPU不再响应中断，它的作用是保证引导程序能够顺利地执行。然后清除eflags里面的DF，作用是在字串操作中让变址寄存器SI和DI的地址指针自动增加，字符串处理从前向后</p></li><li><p>下一步初始化重要的段寄存器，比如ds，es，ss，异或操作让他们全部为0</p></li><li><p>然后开启A20地址线。为了后向兼容早期的PC机，20号物理地址线绑定在低地址，所以高于1MB的地址默认是0，这个作用就是撤销这个，开启所有地址线</p><ul><li>其中seta20.1的作用是在64号端口写入0xd1，说明我要向键盘控制器的P2端口写数据了。</li><li>写数据的方法是把数据通过键盘控制器的60号端口写进去，写入的数据是0xdf，这样打开了A20 gate</li></ul></li><li><p>下面要做的是从实地址模式到保护模式的转换</p><ul><li>首先准备gdt（全局描述符表），上面是带有宏的代码，翻译出来就是底下的代码</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#翻译之前gdt:  SEG_NULL# null seg  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg  SEG(STA_W, 0x0, 0xffffffff) # data seg#翻译出来之后  gdt:  .word 0, 0;  .byte 0, 0, 0, 0                             # 空  .word 0xffff, 0x0000;  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段  .word 0xffff, 0x0000;  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段</code></pre><p>我们可以看出来DB=1表示的是地址和操作数是32位，G等于1表示20位的段limit的粒度是4KB，最大长度是4GB，所以根据上面的代码来看，limit都是0xfffff，说明32位寻址，段长度是0xfffff=2^20，根据粒度等于4KB，所以段界限为4GB，也就是全部地址空间！</p><p>E为1是代码段，为0是数据段，这样即使RW位都相同，但是因为E不同，代码段是只可读，而数据段是可读写</p><ul><li>下面正式进入保护模式，下面这段代码正好对应了<code>gdtr</code>的48位，高32位是gdt的首地址，而低16位是gdt的长度！（长度可以看出来有多少个全局描述符表项）</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">gdtdesc:  .word   (gdtdesc - gdt - 1)             # 16 位的 gdt 大小sizeof(gdt) - 1  .long   gdt                             # 32 位的 gdt 所在物理地址</code></pre><p>其中<code>lgdt</code>指令把<code>gdtdesc</code>的值加载到<code>gdtr</code>里面！</p><ul><li><p>下面一步是打开保护模式的“开关”，x86的控制寄存器有<code>CR0</code>,<code>CR1</code>,<code>CR2</code>,<code>CR3</code>这四个，保护模式的开关再<code>CR0</code>上面</p><p>下面这个代码的意思是把CR0的PE位设置为1，开启保护模式！</p></li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movl    %cr0, %eaxorl     $CR0_PE_ON, %eaxmovl    %eax, %cr0</code></pre></li><li><p>开启保护模式之后，使用长跳转语句，跳转到内核的数据段，这时候寻址方式变成“段基址+段内偏移量”，此时基址寄存器里面的内容是gdt的索引，经过CPU的MMU翻译之后，跳转到相应位置。其中有一些需要解释的地方：为什么<code>PROT_MODE_DSEG</code>的值是0x10呢，因为段基址的高13位代表GDT的下标，所以这样表示下标为2，刚好是内核数据段的下标！查找GDT表之后，我们知道基地址为0，所以后面的段内偏移量就是<code>$protcseg</code>，直接跳转到32位的<code>protcseg</code>函数部分</p></li><li><p>最后设置各个段寄存器，设置栈指针为0x7c00，然后调用<code>bootmain</code>！</p></li></ol><h4 id="2-2-bootmain-c分析"><a href="#2-2-bootmain-c分析" class="headerlink" title="2-2 bootmain.c分析"></a>2-2 <code>bootmain.c</code>分析</h4><p>我们进入<code>bootmain.c</code>的时候，通过反汇编的代码我们可以看出<code>ph</code>被存入了<code>ebx</code>寄存器中，而<code>eph</code>存入了<code>esi</code>寄存器里。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);   7d3a:a1 1c 00 01 00       mov    0x1001c,%eaxeph = ph + ELFHDR-&gt;e_phnum;   7d3f:0f b7 35 2c 00 01 00 movzwl 0x1002c,%esiph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);   7d46:8d 98 00 00 01 00    lea    0x10000(%eax),%ebxeph = ph + ELFHDR-&gt;e_phnum;   7d4c:c1 e6 05             shl    $0x5,%esi   7d4f:01 de                add    %ebx,%esi</code></pre><p>首先分析等待磁盘操作<code>waitdisk</code>，下面的操作就是去读<code>0x1fc</code>端口的<code>bit6</code>和<code>bit7</code>，当<code>bit6=1</code>并且<code>bit7=0</code>的时候，就代表磁盘空闲。其中<code>bit6</code>等于1表示驱动器就绪，<code>bit7</code>空闲表示控制器空闲！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">voidwaitdisk(void){// wait for disk reaadywhile ((inb(0x1F7) &amp; 0xC0) != 0x40)/* do nothing */;}</code></pre><p>然后说一下<code>readseg</code>函数，先等待磁盘空闲，就可以读磁盘了。为什么要把offset写入这些端口呢？</p><p>IDE定义了8个寄存器操作硬盘。PC 体系结构将第一个硬盘控制器映射到端口 1F0-1F7 处，而第二个硬盘控制器则被映射到端口 170-177 处。out函数主要是是把扇区计数、扇区LBA地址等信息输出到端口1F2-1F6，然后将0x20命令写到1F7，表示要进行读扇区的操作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">voidreadsect(void *dst, uint32_t offset){// wait for disk to be readywaitdisk();outb(0x1F2, 1);// count = 1outb(0x1F3, offset);outb(0x1F4, offset &gt;&gt; 8);outb(0x1F5, offset &gt;&gt; 16);outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);outb(0x1F7, 0x20);// cmd 0x20 - read sectors// wait for disk to be readywaitdisk();// read a sectorinsl(0x1F0, dst, SECTSIZE/4);}</code></pre><p>但是有一个问题，上面的代码里有一个<code>insl</code>函数，这个是什么呢？</p><p>看它的实现是一个内联汇编</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">static inline void    insl(uint32_t port, void *addr, int cnt) {        asm volatile (            "cld;"            "repne; insl;"            : "=D" (addr), "=c" (cnt)            : "d" (port), "0" (addr), "1" (cnt)            : "memory", "cc");    }</code></pre><p>我去<code>StackOverflow</code>搜到了相应的解释：</p><blockquote><p>That function will read <code>cnt</code> <code>dwords</code> from the input port specified by <code>port</code> into the supplied output array <code>addr</code>.</p></blockquote><p>大概意思就是说，从<code>port</code>端口里面读出<code>cnt</code>个<code>dword</code>（4字节），读入到特定的内存地址上去。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// read a sectorinsl(0x1F0, dst, SECTSIZE/4);</code></pre><p>可以看出来，因为一个<code>dword</code>是4字节，所以后面的<code>cnt</code>就是<code>SECTSIZE/4</code></p><p>跟踪<code>for</code>循环语句，我们从<code>asm</code>代码可以看出，下面这段代码是跟循环有关，首先用<code>cmp</code>指令比较<code>ph</code>和<code>eph</code>的大小，如果<code>ph</code>大于等于<code>eph</code>的话，就跳出循环，跳到入口函数。否则继续执行，给<code>readseg</code>的参数入栈，中间会进行一些<code>ph</code>自增的操作，最后跳回比较操作！</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">for (; ph &lt; eph; ph++)   7d51:39 f3                cmp    %esi,%ebx   7d53:73 16                jae    7d6b &lt;bootmain+0x56&gt;readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);   7d55:ff 73 04             pushl  0x4(%ebx)   7d58:ff 73 14             pushl  0x14(%ebx)for (; ph &lt; eph; ph++)   7d5b:83 c3 20             add    $0x20,%ebxreadseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);   7d5e:ff 73 ec             pushl  -0x14(%ebx)   7d61:e8 76 ff ff ff       call   7cdc &lt;readseg&gt;for (; ph &lt; eph; ph++)   7d66:83 c4 0c             add    $0xc,%esp   7d69:eb e6                jmp    7d51 &lt;bootmain+0x3c&gt;((void (*)(void)) (ELFHDR-&gt;e_entry))();   7d6b:ff 15 18 00 01 00    call   *0x10018</code></pre><p>具体的源代码就不放出来了，有兴趣请去网上找资源</p><h4 id="2-3-回答问题"><a href="#2-3-回答问题" class="headerlink" title="2-3 回答问题"></a>2-3 回答问题</h4><p>回答下列问题：</p><ol><li><p>问：处理器在哪一个点开始执行32位的代码？实际上是什么造成了16位到32位的转换？</p><p>回答：处理器从<code>boot.S</code>的<code>.code32</code>伪指令开始执行32位代码，在这之前处理器还处于16位的实模式，而打开了cr0的PE位之后，开启了保护模式，从16位变成32位</p></li><li><p>问：bootloader执行的最后一个指令是什么？kernel第一个被加载的指令是什么？</p><p>下面是<code>bootloader</code>的最后一条指令，对应的c语言代码就是跳转到<code>Kernel</code>的入口处！</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">((void (*)(void)) (ELFHDR-&gt;e_entry))();7d6b:ff 15 18 00 01 00    call   *0x10018</code></pre><p>而下面这段是<code>kernel</code>的第一条指令</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0x10000c:movw   $0x1234,0x472   </code></pre></li><li><p>问：内核的第一条指令地址在哪里？</p><p>回答：根据GDB调试，地址在<code>0x10000c</code>处</p></li><li><p><code>bootloader</code>如何知道它要从磁盘里读多少扇区？从哪里找到这些信息的？</p><p>回答：可以从<code>bootmain.c</code>的源代码看出，它的所有信息都是从ELF头里面读出来的！首先找到程序头表的位置，然后找到程序头表里有多少条目。根据程序头表条目给出的信息，把kernel的相应内容从磁盘读入内存！</p></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);eph = ph + ELFHDR-&gt;e_phnum;for (; ph &lt; eph; ph++)// p_pa is the load address of this segment (as well// as the physical address)readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</code></pre><h4 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h4><p>问：修改链接地址并且观察<code>bootloader</code>的运行情况</p><p>答：我先把链接地址从<code>0x7c00</code>改成了<code>0x8c00</code>，然后用<code>gdb</code>来看看发生了什么问题。我在上述这两个地址处都设置了断点，然后按c继续运行，这时我可以看见，仍然在<code>0x7c00</code>处执行第一条指令<code>cli</code>，这让我很疑惑。但是在查阅相关资料之后，发现这是<code>BIOS</code>在捣鬼，实际上不管链接地址是加载到哪里的，<code>BIOS</code>是固定会把<code>bootloader</code>加载到<code>0x7c00</code>的位置，这样也就不难解释为什么还是从<code>0x7c00</code>开始执行代码了。但是我再一次按c继续执行，发现了报错！</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Program received signal SIGTRAP, Trace/breakpoint trap.[   0:7c2d] =&gt; 0x7c2d:ljmp   $0x8,$0x8c32</code></pre><p>也就是说，在<code>ljmp $PROT_MODE_CSEG, $protcseg</code>这句汇编语句出现了错误，这是因为，链接器在链接的时候是根据<code>protcseg</code>相对于第一条指令的相对地址来确定链接地址的，所以确定地址为<code>0x8c32</code>，而实际上加载到的真实地址还是<code>0x7c32</code>！（其实包括前面的<code>lgdt</code>也出错了！）</p><h4 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h4><p>问：查看<code>bootloader</code>把内核加载前后<code>kernel</code>入口处的内存地址，看看为什么有这样的不同</p><p>回答：从下面这段<code>gdb</code>调试的代码可以看出，在<code>bootloader</code>加载<code>kernel</code>之前，这段内存都是0，在加载之后，内存中有了相应的内容，我对比<code>kernel.asm</code>看一看，它们刚好对应</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">The target architecture is assumed to be i8086[f000:fff0]    0xffff0:ljmp   $0xf000,$0xe05b0x0000fff0 in ?? ()+ symbol-file obj/kern/kernel(gdb) b *0x7d6bBreakpoint 1 at 0x7d6b(gdb) x/10x 0x10000c0x10000c:0x000000000x000000000x000000000x000000000x10001c:0x000000000x000000000x000000000x000000000x10002c:0x000000000x00000000(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0x7d6b:call   *0x10018Breakpoint 1, 0x00007d6b in ?? ()(gdb) x/10x 0x10000c0x10000c:0x7205c7660x340000040x2000b8120x220f00110x10001c:0xc0200fd80x0100010d0xc0220f800x10002fb80x10002c:0xbde0fff00x00000000(gdb) </code></pre><h3 id="3-Kernel"><a href="#3-Kernel" class="headerlink" title="3.Kernel"></a>3.Kernel</h3><p>下面开始分析<code>Kernel</code>了。</p><h4 id="3-1有关分页"><a href="#3-1有关分页" class="headerlink" title="3-1有关分页"></a>3-1有关分页</h4><h5 id="练习七"><a href="#练习七" class="headerlink" title="练习七"></a>练习七</h5><p>要求首先看看关于地址映射的问题，我先在<code>mov %eax, %cr0</code>所在位置设置了断点，运行到这里。然后检查了两段地址的内存，刚开始是不一样，然后执行完这句指令，发现两块内存是一样的了！这很神奇！这是因为在开启PE位之后，开启了虚拟内存模式，把虚拟内存空间高地址的内存映射到对应的物理内存上，所以他们的内容是一样的</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">(gdb) b *0x100025Breakpoint 2 at 0x100025(gdb) cContinuing.=&gt; 0x100025:mov    %eax,%cr0Breakpoint 2, 0x00100025 in ?? ()(gdb) x/8x 0x1000000x100000:0x1badb0020x000000000xe4524ffe0x7205c7660x100010:0x340000040x2000b8120x220f00110xc0200fd8(gdb) x/8x 0xf01000000xf0100000 &lt;_start+4026531828&gt;:0x000000000x000000000x000000000x000000000xf0100010 &lt;entry+4&gt;:0x000000000x000000000x000000000x00000000(gdb) si=&gt; 0x100028:mov    $0xf010002f,%eax0x00100028 in ?? ()(gdb) x/8x 0x1000000x100000:0x1badb0020x000000000xe4524ffe0x7205c7660x100010:0x340000040x2000b8120x220f00110xc0200fd8(gdb) x/8x 0xf01000000xf0100000 &lt;_start+4026531828&gt;:0x1badb0020x000000000xe4524ffe0x7205c7660xf0100010 &lt;entry+4&gt;:0x340000040x2000b8120x220f00110xc0200fd8(gdb) </code></pre><p>如果开启PE失败的话，那么下面两句就会出现问题：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov$relocated, %eaxf0100028:b8 2f 00 10 f0       mov    $0xf010002f,%eaxjmp*%eaxf010002d:ff e0                jmp    *%eax</code></pre><p>其实我们在阅读源代码的时候会注意到注释上给了一点问题</p><blockquote><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># Now paging is enabled, but we're still running at a low EIP# (why is this okay?).  Jump up above KERNBASE before entering# C code.</code></pre></blockquote><p>问的是为什么开启分页之后，用原来的<code>EIP</code>还能继续运行，我们需要注意，<strong>我们是将两个范围的虚拟地址映射到物理地址上，而不仅仅是高地址！</strong>这也是这么做的目的！</p><p>既然提到了有关分页的操作，我们不得不分析一下代码了</p><ol><li>在开启分页之前，我们要把页目录的地址存入<code>cr3</code>，注意：我们要加载的是页目录表的<strong>物理地址</strong>，这是因为到时候直接从<code>cr3</code>中取出地址来寻找页目录表，不经过地址转换，所以不能是虚拟地址！（虚拟地址转换需要借助<code>cr3</code>，不能够因果倒置！）</li><li>然后把<code>cr0</code>的<code>PG</code>位打开</li><li>然后跳转到高地址！（变成<code>high EIP</code>）</li></ol><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movl$(RELOC(entry_pgdir)), %eaxmovl%eax, %cr3# Turn on paging.movl%cr0, %eaxorl$(CR0_PE|CR0_PG|CR0_WP), %eaxmovl%eax, %cr0# Now paging is enabled, but we're still running at a low EIP# (why is this okay?).  Jump up above KERNBASE before entering# C code.mov$relocated, %eaxjmp*%eax</code></pre><p>那么，我们就知道了如果没有映射成功的话，打开<code>cr0</code>的<code>PG</code>位之后的下两条指令就会出错，因为<code>relocated</code>是高地址，如果没有映射的话，跳转到那里就会报错！</p><p>我们来测试一下，注释掉设置<code>cr0</code>的操作，可见那个地址的内存全是0，系统崩溃掉了！</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">(gdb) b *0x100025Breakpoint 1 at 0x100025(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0x100025:mov    $0xf010002c,%eaxBreakpoint 1, 0x00100025 in ?? ()(gdb) si=&gt; 0x10002a:jmp    *%eax0x0010002a in ?? ()(gdb) si=&gt; 0xf010002c &lt;relocated&gt;:add    %al,(%eax)relocated () at kern/entry.S:7474movl$0x0,%ebp# nuke frame pointer(gdb) Remote connection closed(gdb) </code></pre><p>还有关于<code>entry_pgdir</code>这个东西的一些讨论，我们可以从<code>entrypgdir.c</code>里面看出来，<code>Jos</code>利用的是二级页表操作，也就是说，把逻辑地址分为页目录10位，页表号10位，页内偏移量12位这三个部分，而我们只需要映射两个部分的虚拟内存！所以页目录设置为下面这样！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__attribute__((__aligned__(PGSIZE)))pde_t entry_pgdir[NPDENTRIES] = {// Map VA's [0, 4MB) to PA's [0, 4MB)[0]= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P,// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)[KERNBASE&gt;&gt;PDXSHIFT]= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W};</code></pre><p>页表在下面这样的格式。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__attribute__((__aligned__(PGSIZE)))pte_t entry_pgtable[NPTENTRIES] = {0x000000 | PTE_P | PTE_W,0x001000 | PTE_P | PTE_W,0x002000 | PTE_P | PTE_W, ......   }</code></pre><h4 id="3-2有关格式化输出"><a href="#3-2有关格式化输出" class="headerlink" title="3-2有关格式化输出"></a>3-2有关格式化输出</h4><p>我们在进行下几步之前，先阅读一下源代码。</p><p>在阅读过程中有几个宏让我感到很疑惑，就是下面这几个，经过查阅引用[5]我得知这几个宏跟格式化输出函数的可变参数有关！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define va_start(ap, last) __builtin_va_start(ap, last)#define va_arg(ap, type) __builtin_va_arg(ap, type)#define va_end(ap) __builtin_va_end(ap)</code></pre><p>我们需要修改的一个地方就是打印8进制数字，理解了代码之后不难写出这个</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// (unsigned) octalcase 'o':num = getuint(&amp;ap,lflag);base = 8;goto number;break;</code></pre><p>下面回答几个问题：</p><ol><li><p>问：Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</p><p>答：<code>printf.c</code>里面的<code>putch</code>调用了<code>console.c</code>里面的<code>cputchar</code>函数，同时<code>vcprintf</code>调用了<code>putch</code>函数，<code>cprintf</code>调用了<code>vcprintf</code>函数</p><p>总结下来调用关系就是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cprintf-&gt;vcprintf-----&gt;putch-&gt;cputchar(consule.c)      |      +--&gt;vprintfmt(ptintfmt.c)</code></pre></li><li><p>问：explain the following from <code>console.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// What is the purpose of this?if (crt_pos &gt;= CRT_SIZE) {int i;memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)crt_buf[i] = 0x0700 | ' ';crt_pos -= CRT_COLS;}</code></pre><p>答：这段代码的目的是：当屏幕已经装满了字符，再次输入的时候，让屏幕向上回滚一行，也就是说把内存里面的内容向前移动80个字符的大小，然后最后一行用黑色填满</p></li><li><p>```c<br>int x = 1, y = 3, z = 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p><pre class="line-numbers language-none"><code class="language-none">   问1：上面这段代码里，`fmt`指代什么？`ap`指代什么？   答：`fmt`是字符串`"x %d, y %x, z %d\n"`的首地址，根据上面的解释`ap`是后面参数的首地址   问2：列出调用过程   答：   - `cprintf`首先调用`vcprintf`，参数`fmt`的值为格式化字符串的地址，参数`ap`指向变量`x`的地址。   - `vcprintf`调用`vprintfmt`，`vprintfmt`函数中多次调用`va_arg`和`putch`，`putch`调用`cputchar`，而`cputchar`调用`cons_putc`，`putch`的字符参数传给`cons_putc`   - 调用`cons_putc`，参数为字符`'x'`   - 调用`cons_putc`，参数为字符空格   - 调用`va_arg`，`lflag=0`，调用前`ap`指向`x`，调用后`ap`指向`y`   - 调用`cons_putc`，参数是字符`'1'`   - 调用`cons_putc`，参数为字符`','`   - 调用`cons_putc`，参数为字符空格   - 调用`cons_putc`，参数为字符`'y'`   - 调用`cons_putc`，参数为字符空格   - 调用`va_arg`，`lflag=0`，调用前`ap`指向`y`，调用后`ap`指向`z`   - 调用`cons_putc`，参数为字符`'3'`   - 调用`cons_putc`，参数为字符`','`   - 调用`cons_putc`，参数为字符空格   - 调用`cons_putc`，参数为字符`'z'`   - 调用`cons_putc`，参数为字符空格   - 调用`va_arg`，`lflag=0`，调用前`ap`指向`z`，调用后`ap`指向`z`后面一块内存   - 调用`cons_putc`，参数为字符`'4'`   - 调用`cons_putc`，参数为字符`'\n'`4. 运行下面程序，看看运行结果   ```c       unsigned int i = 0x00646c72;       cprintf("H%x Wo%s", 57616, &amp;i);   //结果：   //He110 World</code></pre><p>原因如下：10进制57616的16进制表示是E110，而<code>i</code>所在内存将被解读成一个字符串，根据小端法，依次输出0x72，0x6c，0x64表示<code>ASCII</code>码所表示的字符，分别是r，l，d这三个字符！</p><p>综上，我们得到输出结果<code>He110 World</code></p></li><li><p>执行下面代码会把y输出成什么呢？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cprintf("x=%d y=%d", 3);</code></pre><p>实际上输出参数3后面的内存地址所指向的4字节值（按照小端法读取）</p><p>经过测试，实际上输出的是整数1600，具体的过程如何呢？</p><p>在下面这段代码里面，我们发现在把3入栈之前，先把<code>esp</code>加8，那么我们可以知道，y所输出的值就是<code>esp</code>加8之后的所指向的内存，继续往回看，在调用<code>test_backtrace(5)</code>的时候，并没有把5压栈，而是直接把<code>esp</code>所指向的内存的值改成了5，所以我们需要继续向上找。可以看出<code>cprintf</code>有两个参数，所以<code>esp</code>加8应该跳到这两个参数之上的那个参数，我们发现在<code>0xf01000d4</code>这里还有一个给<code>esp</code>加8的操作，所以再回溯两个<code>push</code>操作，我们注意到这一行<code>f01000c6:    50                       push   %eax</code>，没错，这个<code>eax</code>就是显示出来的y的值！根据上面的<code>sub</code>指令，我们算出来<code>eax</code>的值就是十进制的1600！！！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">f01000b8:c7 c2 60 30 11 f0    mov    $0xf0113060,%edxf01000be:c7 c0 a0 36 11 f0    mov    $0xf01136a0,%eaxf01000c4:29 d0                sub    %edx,%eaxf01000c6:50                   push   %eaxf01000c7:6a 00                push   $0x0f01000c9:52                   push   %edxf01000ca:e8 20 15 00 00       call   f01015ef &lt;memset&gt;// Initialize the console.// Can't call cprintf until after we do this!cons_init();f01000cf:e8 4e 05 00 00       call   f0100622 &lt;cons_init&gt;cprintf("6828 decimal is %o octal!\n", 6828);f01000d4:83 c4 08             add    $0x8,%espf01000d7:68 ac 1a 00 00       push   $0x1aacf01000dc:8d 83 6f 07 ff ff    lea    -0xf891(%ebx),%eaxf01000e2:50                   push   %eaxf01000e3:e8 72 09 00 00       call   f0100a5a &lt;cprintf&gt;// Test the stack backtrace function (lab 1 only)test_backtrace(5);f01000e8:c7 04 24 05 00 00 00 movl   $0x5,(%esp)f01000ef:e8 4c ff ff ff       call   f0100040 &lt;test_backtrace&gt;    //int x = 1, y = 3, z = 4;    //cprintf("x %d, y %x, z %d\n", x, y, z);//unsigned int i = 0x00646c72;    //cprintf("H%x Wo%s", 57616, &amp;i);//Sasm("pushl $200");cprintf("x=%d y=%d\n", 3);f01000f4:83 c4 08             add    $0x8,%espf01000f7:6a 03                push   $0x3f01000f9:8d 83 8a 07 ff ff    lea    -0xf876(%ebx),%eaxf01000ff:50                   push   %eaxf0100100:e8 55 09 00 00       call   f0100a5a &lt;cprintf&gt;f0100105:83 c4 10             add    $0x10,%esp</code></pre></li><li><p>问：Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>答：可以在最后push一个整数来表示参数的数目！</p></li></ol><h4 id="3-3有关内核栈"><a href="#3-3有关内核栈" class="headerlink" title="3-3有关内核栈"></a>3-3有关内核栈</h4><h5 id="练习九"><a href="#练习九" class="headerlink" title="练习九"></a>练习九</h5><p>内核是如何初始化栈的？我们结合下面的代码来看，首先把栈顶指针的内容赋值给<code>esp</code>，然后看下面，<code>bootstack</code>给分配了<code>KSTKSIZE</code>的内存空间，也就是8个页的大小。然后栈顶的值是分配的内存空间结束的地址，是高地址！</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># Set the stack pointermovl$(bootstacktop),%esp.data#################################################################### boot stack###################################################################.p2alignPGSHIFT# force page alignment.globlbootstackbootstack:.spaceKSTKSIZE.globlbootstacktop   bootstacktop:</code></pre><h5 id="练习十"><a href="#练习十" class="headerlink" title="练习十"></a>练习十</h5><p>对于<code>testbacktrace</code>，我们从源代码可以看出每次进入这个函数之后进行如下步骤：</p><ol><li>把栈底指针压入栈（然后让<code>ebp</code>变成新的栈底指针）</li><li>把<code>esi</code>和<code>ebx</code>推入栈中，保存寄存器</li><li>然后进行<code>cprintf</code>有关的处理</li><li>把<code>fmt</code>地址入栈</li><li>调用<code>cprintf</code></li><li>把<code>test_backtrace(x-1)</code>的参数压栈</li><li>递归调用</li></ol><p>后面是写代码的题目，懒得写了，先把代码贴上，后期再解释…</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">intmon_backtrace(int argc, char **argv, struct Trapframe *tf){// Your code here.uint32_t ebp, old_ebp, eip;uint32_t args[5] = {0};ebp = read_ebp();//ebp = *((uint32_t*)ebp);cprintf("Stack backtrace:\n");while(ebp != 0){old_ebp = *((uint32_t*)ebp);eip = *((uint32_t*)(ebp + 4));for(int i = 0; i &lt; 5; i++){args[i] = *((uint32_t*)(ebp + 8 + 4 * i));}cprintf("  ebp %x  eip %x  args %08x %08x %08x %08x %08x\n", ebp, eip, args[0], args[1], args[2], args[3], args[4]);struct Eipdebuginfo info;debuginfo_eip(eip, &amp;info);char fn_name[20];strncpy(fn_name, info.eip_fn_name, info.eip_fn_namelen);fn_name[info.eip_fn_namelen]='\0';cprintf("         %s:%d: %s+%d\n", info.eip_file, info.eip_line, fn_name,//info.eip_fn_name, eip - info.eip_fn_addr);ebp = old_ebp;}return 0;}</code></pre><h2 id="三-reference"><a href="#三-reference" class="headerlink" title="三.reference"></a>三.reference</h2><p>1.<a href="https://www.cnblogs.com/wuhualong/p/lab01_exercise02_trace_into_bios.html">《MIT 6.828 Lab 1 Exercise 2》实验报告 - whl1729 - 博客园 (cnblogs.com)</a></p><p>2.<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6 - DRAFT as of September 4, 2018 (mit.edu)</a></p><p>3.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">elf.pdf (mit.edu)</a></p><p>4.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Lanugage (mit.edu)</a></p><p>5.<a href="https://blog.csdn.net/u011728480/article/details/62044567">C 可变参数函数分析(va_start,va_end,va_list…)_Sky的专栏-CSDN博客___builtin_va_start</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记传输层</title>
      <link href="/2021/06/16/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2021/06/16/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-传输层简介transport-layer"><a href="#一-传输层简介transport-layer" class="headerlink" title="一.传输层简介transport layer"></a>一.传输层简介transport layer</h2><h3 id="1-传输层作用"><a href="#1-传输层作用" class="headerlink" title="1.传输层作用"></a>1.传输层作用</h3><ul><li>进程间通信<ul><li>应用进程间的多路复用和解复用</li><li>用端口实现</li></ul></li><li>为应用程序提供端到端的服务<ul><li>可靠的，按序的数据交付</li><li>很好的交付节奏</li></ul></li><li>TCP和UDP是常用的运输层协议<ul><li>还有其他的，就不说了</li></ul></li><li>UDP是极简化的传输层协议<ul><li>只提供复用和分解能力</li></ul></li><li>TCP提供可靠的，按序的，字节流的抽象<ul><li>有拥塞控制，但是没有性能担保</li></ul></li></ul><h3 id="2-应用程序和套接字"><a href="#2-应用程序和套接字" class="headerlink" title="2.应用程序和套接字"></a>2.应用程序和套接字</h3><p>套接字（socket）：给应用进程和操作系统之间交换网络消息的一个软件抽象</p><p>传输层寻址：**&lt;HostIP , Port&gt;**，叫做一个套接字</p><p>两个重要的套接字类型：</p><ul><li>UDP套接字：TYPE是SOCK_DGRAM</li><li>TCP套接字：TYPE是SOCK_STREAM</li></ul><h3 id="3-端口"><a href="#3-端口" class="headerlink" title="3.端口"></a>3.端口</h3><ul><li>帮助区别APP的16比特的数字<ul><li>分组在传输层头带着src和dst端口号</li><li>有常用端口（0-1023）和临时端口</li></ul></li><li>OS存储套接字和端口的映射<ul><li>端口在分组里面，套接字在OS里</li><li>对于UDP端口，OS存储（local port，local IP）来映射套接字</li><li>对于TCP端口，OS存储（local port，local IP，remote port， remote IP）来映射套接字</li></ul></li></ul><h3 id="4-多路复用和多路分解"><a href="#4-多路复用和多路分解" class="headerlink" title="4.多路复用和多路分解"></a>4.多路复用和多路分解</h3><p>在发送方：处理来自多个套接字的数据，添加传输层头。</p><p>在接收方：用header信息来把收到的传输层报文段交付给正确的套接字。</p><h4 id="4-1-如何多路分解"><a href="#4-1-如何多路分解" class="headerlink" title="4-1 如何多路分解"></a>4-1 如何多路分解</h4><p>主机收到IP数据报，里面有源和目的IP，数据报携带传输层报文段，保温段里面有源和目的端口</p><p>主机用IP地址和端口号来把报文段导向正确的套接字</p><p><img src="/picture/format.png"></p><h5 id="4-1-1-无连接的多路分解"><a href="#4-1-1-无连接的多路分解" class="headerlink" title="4-1-1 无连接的多路分解"></a>4-1-1 无连接的多路分解</h5><p>对于UDP协议，当我们收到了目的端口相同，但是源端口或源IP不同的报文段，仍然要引导向同一个目的套接字</p><p>4-1-2基于连接的多路分解</p><p><strong>对于TCP协议，我们确定一个套接字通过一个4元组</strong></p><ul><li>源IP地址</li><li>源端口号</li><li>目的IP地址</li><li>目的端口号</li></ul><p>多路分解：接收方用四元组来导向正确的套接字</p><p>服务器主机或许支持许多同时的TCP套接字：每个套接字通过4元组来确定</p><p>下面是一个例子：</p><p><img src="/picture/socket.png"></p><h2 id="二-传输层设计"><a href="#二-传输层设计" class="headerlink" title="二.传输层设计"></a>二.传输层设计</h2><p>为什么要用传输层？</p><ol><li>IP分组寻址到一个主机，但是端到端的交流是介于进程之间的，需要一种方式（多路复用和分解）来定位到应用进程</li><li>IP提供很弱的服务模型（尽力而为）<ul><li>分组可能错误，延迟，丢包…</li><li>对拥塞情况没有控制</li><li>这些事情还不能让应用程序来处理</li></ul></li></ol><p>尽力而为协议可能做很多很不好的事情，所以我们需要可靠传输</p><p>我们处理这些不好事情需要一些机制：</p><ul><li>检验和：来检测错误</li><li>ACK：接受者告诉发送者收到了包</li><li>NACK：接受者告诉发送者没有收到包</li><li>序号：一种识别分组的方式</li><li>重传</li><li>超时</li><li>发送纠正后的包</li><li>网络编码</li></ul><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p><img src="/picture/sw.png"></p><p>这个协议比较可靠，但是比较低效，浪费带宽。</p><p><img src="/picture/ine.png"></p><p><img src="/picture/ine1.png"></p><h3 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h3><p>流水线：发送方允许多个飞行中的等待“被ACK“的分组。序号的必须增加，在接收方和发送方缓存。</p><p><img src="/picture/uti.png"></p><h4 id="三种设计决策"><a href="#三种设计决策" class="headerlink" title="三种设计决策"></a>三种设计决策</h4><p>哪一个包可以发送根据<strong>滑动窗口</strong></p><p>接收方如何发送ACK？有两种，积累的，选择性的</p><p>发送方需要重传哪些包？Go-Back N（GBN）回退n帧，Selective Repeat(SR)选择重传</p><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>窗口就是一些相邻的序号的集合，集合的大小是窗口大小，假定窗口大小是n</p><p>一次发送n个包：</p><ul><li>发送者可以发送窗口里的包</li><li>接受者可以接受窗口里的包</li><li>当收到ACK，可接受的包的窗口滑动</li></ul><p><img src="/picture/slide.png"></p><h5 id="积累确认"><a href="#积累确认" class="headerlink" title="积累确认"></a>积累确认</h5><p>累计确认永远确认的是还没有收到的序列号最小的那个</p><p><img src="/picture/ca.png"></p><p><img src="/picture/ca1.png"></p><h5 id="选择性确认"><a href="#选择性确认" class="headerlink" title="选择性确认"></a>选择性确认</h5><p>选择确认确认的是收到的包本身的序列！！！</p><p>收到一个正确的包就进行确认，这样需要记录下来哪些已经收到了</p><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>重传包：两种标准的方法：回退n帧GBN和选择重传SR</p><h5 id="回退N帧"><a href="#回退N帧" class="headerlink" title="回退N帧"></a>回退N帧</h5><p>发送方发送最多n个没有被ACK的包</p><p>接收方只按序接收，时序的分组会被丢弃</p><p>接收方用积累确认：ACK的序号等于下一个被期待的正确顺序的序号</p><p>发送方为第一个未完成的ack设置定时器（A+1），如果超时就重传A+1，A+2……</p><h5 id="GBN的滑动窗口"><a href="#GBN的滑动窗口" class="headerlink" title="GBN的滑动窗口"></a>GBN的滑动窗口</h5><p><img src="/picture/gbn.png"></p><p>下面是没有出错的GBN滑动窗口</p><p><img src="/picture/gbn1.png"></p><p>下面是出错的GBN滑动窗口，可以看出4在传输图中丢失了，那么5和6倍接收方丢弃，而4超时没收到ACK之后发送方重传456！！！</p><p><img src="/picture/gbn2.png"></p><h5 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h5><p>发送方发送最多n个没有被ACK的包</p><p>假定分组k丢掉了，<code>K+1</code>没有丢掉</p><ul><li>那么接收方：发送k+1的ACK</li><li>发送方：k超时，只重传k</li></ul><p>高效重传但是记账很复杂，<strong>对于每个包都要一个定时器</strong>！！！</p><p><img src="/picture/sr.png"></p><h5 id="GBN-vs-SR"><a href="#GBN-vs-SR" class="headerlink" title="GBN vs SR"></a>GBN vs SR</h5><p>什么时候GBN更好？错误率低，否则重传多余的包会浪费带宽</p><p>什么时候SR更好？错误率高，否则会搞得很复杂</p><p>对于滑动窗口，只要窗口大小足够大，就可以充分利用链接。</p><p>发送方不得不缓存所有没有被ACK的包，因为可能需要重传</p><p>接收方或许能够接收失序的包，但是不能超过缓存大小！</p><p>实现的复杂度取决于协议的细节！！！</p><h2 id="三-UDP"><a href="#三-UDP" class="headerlink" title="三.UDP"></a>三.UDP</h2><p>UDP是User Datagram Protocol（用户数据报协议）</p><p>TCP是Transmission Control Protocol（传输控制协议）</p><ul><li>进程之间的轻量级交流，避免了额外开销</li><li>目的IP地址和端口来支撑多路分解</li><li>尽力而为服务，UDP报文段或许会丢失，失序交付给app</li><li>无连接的，没有握手，每个UDP报文段都独立被处理</li></ul><p>UDP用：</p><ul><li>流多媒体APP</li><li>DNS</li><li>SNMP</li></ul><p>为什么要有UDP？</p><ol><li>不需要连接建立（没有额外时间开销）</li><li>简单：收发方都没有连接状态</li><li>header比较小</li><li>没有拥塞控制：UDP速度可以爆炸增长</li></ol><h3 id="UDP报文段的格式"><a href="#UDP报文段的格式" class="headerlink" title="UDP报文段的格式"></a>UDP报文段的格式</h3><p><img src="/picture/udp.png"></p><h4 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h4><p>检测传输地报文段的错误</p><p>进行16bit和的反码运算，值得注意的是，在进行16bit加法运算的时候如果有溢出就要进行回卷（把溢出位加到后面！！！），对最后的和进行反码运算</p><p>检验和字段是0意味着没有用检验和</p><h2 id="四-TCP"><a href="#四-TCP" class="headerlink" title="四.TCP"></a>四.TCP</h2><p>TCP交付可靠的，按序的字节流</p><h3 id="TCP头"><a href="#TCP头" class="headerlink" title="TCP头"></a>TCP头</h3><p><img src="/picture/TCP.png"></p><p>用源端口和目的端口来进行多路复用和分解</p><p>checksum用来计算数据和伪头</p><p>序列号是字节偏移量（因为TCP是一个字节流）</p><h3 id="TCP做什么"><a href="#TCP做什么" class="headerlink" title="TCP做什么"></a>TCP做什么</h3><ol><li>检验和</li><li>序号是字节偏移量</li><li>接收方发送积累确认（像GBN）</li><li>接收方缓存时序分组（像SR）</li></ol><h3 id="TCP引入什么"><a href="#TCP引入什么" class="headerlink" title="TCP引入什么"></a>TCP引入什么</h3><p>引入了快速重传机制：冗余的ACK触发早期重传</p><p>发送方维护一个单独的重传计时器，当超时就重传</p><p>那么我们如何确定超时时间是多少呢？</p><p>要跟RTT成一定比例，我们怎么知道RTT呢</p><p>RTT样本的指数加权平均值</p><p><img src="/picture/exp.png"></p><p>我们如何区分真的ACK和重传分组的ACK呢？</p><p><img src="/picture/ACK.png"></p><h4 id="Karn-Partridge算法"><a href="#Karn-Partridge算法" class="headerlink" title="Karn/Partridge算法"></a>Karn/Partridge算法</h4><p>不用来自重传的ACK，一旦重传就忽略后面的ACK报文段</p><p>用α=0.125来计算<code>EstimatedRTT</code></p><p>超时的值设置成<code>EstimatedRTT</code>的2倍</p><p>使用指数回退：当超时就让<code>RTO=2* RTO</code>。每次新的估计值（收到不是重传的ACK）出现，就回退到<code>2*EstimatedRTT</code></p><h4 id="Jacobson-Karels算法"><a href="#Jacobson-Karels算法" class="headerlink" title="Jacobson/Karels算法"></a>Jacobson/Karels算法</h4><p><img src="/picture/JK.png"></p><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><h4 id="双向握手"><a href="#双向握手" class="headerlink" title="双向握手"></a>双向握手</h4><p>A发送SYN，B回复SYN</p><p>如何识别就连接中的报文段</p><p>如何识别冗余过期的SYN</p><h5 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h5><p>用一个和之前连接不同的初始化序列号开始每段新连接</p><p>连接请求的形式为SYN i+1，其中i是将在此连接上发送的第一个数据段的序列号。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/picture/3.png"></p><p><img src="/picture/shake.png"></p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>正常的终止，一次一边</p><p><img src="/picture/fin1.png"></p><p>正常的终止，两边同时</p><p><img src="/picture/fin2.png"></p><p>意外终止</p><p><img src="/picture/fin3.png"></p><p>下面是客户机的生命周期</p><p><img src="/picture/client.png"></p><p>下面是服务器的生命周期</p><p><img src="/picture/server.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记应用层</title>
      <link href="/2021/06/14/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2021/06/14/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-多媒体网络应用"><a href="#一-多媒体网络应用" class="headerlink" title="一.多媒体网络应用"></a>一.多媒体网络应用</h2><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>以恒定速率采样的模拟音频信号</p><ul><li>telephone：8000样本每秒</li><li>CD音乐：44100样本每秒</li></ul><p>每个样本被量化，例如四舍五入(比如2^8=256种可能的量化值)</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>以恒定速率播放的图片序列，比如24张图片每秒</p><p>数字图片：像素的数组，每张图片通过比特来表示</p><p>编码：利用图片之间的冗余（相同的地方）来编码可以节省空间</p><ul><li>空间上的冗余：比如同一排一样的颜色，只需要发送一个颜色和重复的次数即可</li><li>时间上的冗余：相邻两帧只需要发送不一样的地方即可</li></ul><h3 id="三种应用类型"><a href="#三种应用类型" class="headerlink" title="三种应用类型"></a>三种应用类型</h3><h4 id="1-流媒体"><a href="#1-流媒体" class="headerlink" title="1.流媒体"></a>1.流媒体</h4><p>因为整个视频文件太大，所以变成”流“来存储音频和视频，在完全下载下来之前就可以播放。在服务器上面的存储：可以比音频或者视频传输地更快（意味着在客户机缓存）。</p><p>流媒体存储的视频：</p><p><img src="/picture/streaming.png"></p><p>存在一些挑战：</p><ul><li>持续的播放约束，一旦客户播放开始，重放就要匹配得上原来的时间。但是网络延迟是可变的，所以我们需要客户机端的缓冲区来匹配播放需要</li><li>客户机需要交互：暂停，快进，回退…</li><li>视频包可能会丢失</li></ul><p>改进之后：（多了buffer）</p><p><img src="/picture/s.png"></p><h5 id="利用的协议"><a href="#利用的协议" class="headerlink" title="利用的协议"></a>利用的协议</h5><p>UDP</p><p>服务器以一个对于客户合适的速率发送</p><p>要有一个比较短的播放延迟来对抗网络抖动</p><p>UDP可能穿不过防火墙</p><p>HTTP</p><p>通过<code>HTTP GET</code>来获取多媒体文件。在TCP下以一个最小的可能速率发送</p><p><img src="/picture/HTTPTCP.png"></p><p>填充速率波动取决于TCP拥塞控制，重传机制。需要更大的播放延时。HTTP/TCP可以轻松穿过防火墙</p><p>DASH</p><p>Dynamic，Adaptive Streaming over HTTP</p><p>发送方：</p><ul><li>把视频文件分为多个块</li><li>每个块都存下来，以不同的速率编码</li><li>清单文件：提供不同块的URL</li></ul><p>接收方：</p><ul><li>周期性测量服务器到客户的带宽</li><li>询问清单，一次性请求一个块。选择给定当前带宽下可以忍受的最小的编码速率，可以在不同的时间点根据不同带宽选择不同的速率。</li></ul><h4 id="2-基于IP的会话视频或音频"><a href="#2-基于IP的会话视频或音频" class="headerlink" title="2.基于IP的会话视频或音频"></a>2.基于IP的会话视频或音频</h4><p>人和人交互式的场景限制了对延迟的容忍度</p><p>VoIP</p><p>VoIP端到端延迟要求：更高的延迟会明显影响交互性。小于150ms：好，大于400ms：坏。包括应用的等级（分组，播放），网络时延</p><p>会话初始化：接电话的人如何通知它的IP地址，端口号，编码算法呢？</p><p>增值业务：电话转移，筛选，记录</p><p>紧急服务：911</p><h4 id="3-流媒体直播视频或音频"><a href="#3-流媒体直播视频或音频" class="headerlink" title="3.流媒体直播视频或音频"></a>3.流媒体直播视频或音频</h4><p>比如，体育赛事</p><p>三.因特网QoS</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/2021/06/14/NP%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/14/NP%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一-NP问题"><a href="#一-NP问题" class="headerlink" title="一.NP问题"></a>一.NP问题</h2><h3 id="1-优化问题和判定问题"><a href="#1-优化问题和判定问题" class="headerlink" title="1.优化问题和判定问题"></a>1.优化问题和判定问题</h3><p>优化问题是关注某种特殊的结构，并且希望优化该结构的某种指标。判定问题是给出某个特定的指标，来判断某个特殊结构是否可以满足这个指标。一般来说，优化问题可以转化成对应判定问题。下面的最大团问题就是一种优化问题。</p><h4 id="CLIQUE优化问题"><a href="#CLIQUE优化问题" class="headerlink" title="CLIQUE优化问题"></a>CLIQUE优化问题</h4><p>最大团问题：给定一个无向图G，如果G的子图H是一个完全图，那么称H是G的一个团（clique）。定义一个团的大小是它所含节点的个数，那么最大问题就是，给定一个无向图，请找到无向图中最大团的大小。</p><p>那么根据上面的抽象概念，我们所说关注的特殊结构就是团，而指标就是团的大小。一个优化问题可以定义对应的判定问题，判定问题关注同样的结构和同样的指标。但是和优化问题不同的是，判定问题往往给出指标的一个具体的值，问你“能不能”，“可不可以”。</p><p>那么下面我们就可以引出最大团问题对应的判定问题</p><h4 id="CLIQUE判定问题"><a href="#CLIQUE判定问题" class="headerlink" title="CLIQUE判定问题"></a>CLIQUE判定问题</h4><p>问题：给定一个无向图G，请问G中是否存在大小为k的团？</p><p>优化问题比判定问题难。当我们得到优化问题的解，就很容易知道判定问题的解；但是当我们得到判定问题的解，就很难得到优化问题的解。举个例子，我们知道图G的最大团大小为a，那么我问是否存在大小为k的团的时候，只需要比较a和k的大小就可以得到答案；但是当我知道存在大小为k的团，但无法判断是否还有更大的团，所以无法知道最大团的大小！</p><p>由此，我们看出优化问题比判定问题要难！！！</p><h3 id="2-P问题"><a href="#2-P问题" class="headerlink" title="2.P问题"></a>2.P问题</h3><p>P问题就是多项式时间内可解的问题。具体定义如下：</p><p>一个问题是P问题，如果存在关于n的一个多项式<code>poly(n)</code>，并且存在解决该问题的一个算法，满足算法的代价是<code>f(n)=O(poly(n))</code></p><p>P问题可以内聚为一个问题类，是因为多项式运算的封闭性。多项式时间是一个非常大的范围，比如说<code>n^1000000</code>也是一个多项式，但在现实生活中非常不实用。那么有一个问题出现了，我们为什么要引入P问题来研究问题的难度？问题的难易是相对的，多项式时间算法不一定实用，但是如果当算法的代价不是多项式时间的，那么我们可以断定这个问题在较大规模输入的时候必然是不实用的。我们关注的一些难问题，P问题是一个很有意义的分类。</p><p>优化问题和判定问题在难度上往往差距不大，严格的说，<strong>很多优化问题在多项式时间内可解，等价于它的判定问题在多项式时间内可解！</strong></p><p>那么，对于最大团问题，我们有：<strong>最大团问题的优化问题是多项式时间可解的，当且仅当它的判定问题是多项式时间可解的</strong>。</p><p>3.NP问题</p><p>定义过P问题，我们进一步定义NP问题。NP的名称来自<code>Non-deterministic P</code>，含义是非确定性算法在多项式时间内可解，也可以理解为在多项式时间内可验证。具体如下：</p><p>我们定义一个问题为NP问题，如果该问题的解在多项式时间内可验证。这里可验证的含义是首先我们先随便猜一个解，然后可以在多项式时间内可以检查这个解是不是该问题的正确的解。</p><p>定理：**<code>CLIQUE∈NP</code>**</p><p>证明：我们可以通过O(n)来猜想图中的任意k个顶点，然后来检查他们之间是否两两都有边，那么验证过程复杂度是O(k^2)=O(n^2)，所以我们可以在多项式时间内完成问题的验证！</p><h2 id="二-问题的归约"><a href="#二-问题的归约" class="headerlink" title="二.问题的归约"></a>二.问题的归约</h2><h3 id="归约的定义"><a href="#归约的定义" class="headerlink" title="归约的定义"></a>归约的定义</h3><p>问题P可以规约到Q的含义是解决问题P可以间接通过解决问题Q来实现。下面是P到Q的归约的定义：</p><p>判定问题P到Q的归约为一个转换函数<code>T(x)</code>满足：</p><ul><li>它能够将问题P的任意一个合法输入x转换成问题Q的一个合法输入<code>T(x)</code>。假设已经有了解决问题Q的算法，将<code>T(x)</code>输入到该算法，得到问题Q的一个输出。</li><li>P问题对于任意输入x的输出是YES，当且仅当Q问题对输入<code>T(x)</code>的输出是YES</li></ul><p><img src="/picture/gy.png" alt="P到Q的归约"></p><p>在定义归约时，我们看到了研究判定问题带来的便利。不同算法问题的解可能非常不一样，但是如果仅仅讨论判定问题的话，问题的解都是YES或者NO，这样为两个判定问题之间的归约带来了很多便利！！！</p><h3 id="归约代价和问题难度的比较"><a href="#归约代价和问题难度的比较" class="headerlink" title="归约代价和问题难度的比较"></a>归约代价和问题难度的比较</h3><p>我们引入问题的归约是为了衡量问题间相对的难易程度。我们需要对归约作出一定限制，下面定义多项式时间归约<code>≤p</code>：</p><p>如果T是问题P到Q的归约，且T的代价为其输入规模的多项式，则称问题P可以多项式时间归约到问题Q，记为<code>P ≤p Q</code></p><p>对于一个难问题而言，输入转换代价如果是多项式的，那么这个代价对于解决问题的代价而言是一个小量，所以研究难问题之间的难以关系时，我们集中关注多项式时间归约。如果<code>P ≤p Q</code>，说明P的难度不超过Q的难度。对于多项式时间归约，我们有：</p><p><strong>多项式时间归约关系是一个传递关系，即对于问题P，Q，R，如果<code>P ≤p Q</code>，<code>Q ≤p R</code>，那么<code>P ≤p R</code>。</strong></p><h2 id="三-NP完全问题"><a href="#三-NP完全问题" class="headerlink" title="三.NP完全问题"></a>三.NP完全问题</h2><p><strong>NP难问题定义：一个问题P是NP难问题，如果对于属于NP的任意问题Q，<code>Q ≤p P</code></strong></p><p><strong>NP完全问题：一个问题P是NP完全问题，如果<code>P∈NP</code>，并且P是NP难问题</strong></p><p>参考书：《算法设计与分析》第二版–黄宇</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP复杂性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-零钱兑换问题</title>
      <link href="/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="零钱兑换系列问题"><a href="#零钱兑换系列问题" class="headerlink" title="零钱兑换系列问题"></a>零钱兑换系列问题</h1><h2 id="1-零钱兑换1"><a href="#1-零钱兑换1" class="headerlink" title="1.零钱兑换1"></a>1.零钱兑换1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这道题目是力扣上面的题目，最近正好在学DP就做了个题解</p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>提示</p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><pre class="line-numbers language-none"><code class="language-none">输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们先从暴力方法入手，我们只需要<code>DFS</code>遍历所有可能的组合数量就可以从中找到一个最优解，但是这样暴力枚举的复杂度相当大，我们需要想一个更加优秀的算法。这种问题我们还是用递归更加恰当，试想我们想知道金额x最少需要多少，那么我只需要知道金额<code>x-coin_i(i&gt;=0 &amp;&amp; i&lt;size)</code>最少需要多少枚硬币，然后找到它们最小那个加一就行了，这样利用了动态规划的思想，站在前人的成果之上来解题，就方便了很多，所以我们只需要从1开始计算到amount分别最少需要多少钱就可以了</p><p>状态转移方程：<code>dp[i]=min(dp[i-coin_j]+1) (j&gt;=0 &amp;&amp; j&lt;coins.size)</code></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {        vector&lt;int&gt; dp(amount+1,INT_MAX-1);        dp[0]=0;        for(int i=1;i&lt;=amount;i++){            for(auto coin:coins){                if(i-coin&gt;=0){                    dp[i]=min(dp[i],dp[i-coin]+1);                }            }        }                return dp[amount]&lt;INT_MAX-1?dp[amount]:-1;    }};</code></pre><h2 id="2-零钱兑换2"><a href="#2-零钱兑换2" class="headerlink" title="2.零钱兑换2"></a>2.零钱兑换2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><pre class="line-numbers language-none"><code class="language-none">输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题跟</p><p>类似，但是他们要求解的东西不一样，那道题要求凑成总金额需要最少的硬币数，这道题要求有多少种可以凑成总金额的组合</p><p>对于某一个金额x，我们可以查看<code>x-coin_i</code>的组合数，加到一起即可，等等…我是不是忘了什么，这样很可能出现重复的组合，比如说<code>amount=5</code>，<code>coins=[1,2,5]</code>，那么1+2可以组合成3，那么3+2可以组合成5；2+2可以组合成4，那么4+1可以组合成5，所以<code>1+2+2=5</code>这个组合至少用了两次！！！所以这种做法需要被<code>pass</code>掉！！！</p><p>那么正确的做法应该是什么呢？我们可以在外层对硬币金额进行遍历，内层更新每一个金额。这样每层循环解释起来就是，我用前k种硬币，凑成每一种金额有多少组合。那么我进行每一次遍历的时候，我之前积累起来的是用前k种硬币有多少种，那么加上第k+1种硬币能够有多少种。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int change(int amount, vector&lt;int&gt;&amp; coins) {        vector&lt;int&gt; dp(amount+1,0);        dp[0]=1;        for(auto coin:coins){            for(int i=coin;i&lt;=amount;i++){                dp[i]+=dp[i-coin];            }        }        return dp[amount];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记网络层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-网络层的功能"><a href="#一-网络层的功能" class="headerlink" title="一.网络层的功能"></a>一.网络层的功能</h2><ol><li>从发送主机到接收主机传送报文段</li><li>在发送端把运输层报文段封装进网络层数据报</li><li>在接收方，把报文段递交给运输层</li><li>在每一个主机和路由器都有运输层协议</li><li>路由器检查IP数据报的header域，然后通过它传递</li></ol><p><img src="/picture/zzy.png"></p><p>两个关键的功能：</p><p>交换和路由：运用路由算法决定从源到目的发包的路由路线，找到从源到目的最短路线（路由决定转发表）</p><p>转发：从输入端口转发到特定的输出端口，进行错误处理排队和调度</p><p>连接建立：在数据报开始发送之前，终端主机和路由器之间建立虚拟连接（和运输层对比，网络层的连接建立是包括主机和路由器，而运输层是在两个主机进程之间！）</p><h2 id="二-网络服务模型"><a href="#二-网络服务模型" class="headerlink" title="二.网络服务模型"></a>二.网络服务模型</h2><p>信道的什么服务模型来从发送方到接收方传输数据报？</p><h3 id="例子：ATM的网络服务模型"><a href="#例子：ATM的网络服务模型" class="headerlink" title="例子：ATM的网络服务模型"></a>例子：ATM的网络服务模型</h3><p>恒定比特率（CBR）和可变比特率（VBR），有效比特率和未定义比特率</p><p><img src="/picture/atm.png"></p><h3 id="例子：IP的网络服务模型"><a href="#例子：IP的网络服务模型" class="headerlink" title="例子：IP的网络服务模型"></a>例子：IP的网络服务模型</h3><p>尽力而为</p><p><img src="/picture/ip.png"></p><h2 id="三-IP路由器"><a href="#三-IP路由器" class="headerlink" title="三.IP路由器"></a>三.IP路由器</h2><p>互联网基础设施的核心！</p><p>路由器的容量=NXR（其中N是外部路由端口的数量，R是每个端口的速率）</p><p><img src="/picture/isp.png"></p><h3 id="不同类型的路由器"><a href="#不同类型的路由器" class="headerlink" title="不同类型的路由器"></a>不同类型的路由器</h3><h4 id="1-核心路由器"><a href="#1-核心路由器" class="headerlink" title="1.核心路由器"></a>1.核心路由器</h4><p>R = 10/40/100/200/400 Gbps  NR = O(100) Tbps (总共)</p><h4 id="2-边缘路由器"><a href="#2-边缘路由器" class="headerlink" title="2.边缘路由器"></a>2.边缘路由器</h4><p>R = 1/10/40/100 Gbps NR = O(100) Gbps</p><h4 id="2-小型商用"><a href="#2-小型商用" class="headerlink" title="2.小型商用"></a>2.小型商用</h4><p>R = 1 Gbps  NR &lt; 10 Gbps</p><h3 id="路由器的内部：架构概览"><a href="#路由器的内部：架构概览" class="headerlink" title="路由器的内部：架构概览"></a>路由器的内部：架构概览</h3><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h4><p><img src="/picture/router%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88.png"></p><h4 id="2-输入端口"><a href="#2-输入端口" class="headerlink" title="2.输入端口"></a>2.输入端口</h4><p><img src="/picture/11.png"></p><p>输入端口的任务：</p><ul><li>收到包（物理层的任务）</li><li>更新IP头：TTL，checksum，可选字段，切片等</li><li>查找目的IP对应的合适的输出端口</li><li>排队：如果包到达太快就要缓存排队</li></ul><h5 id="查找合适的输出端口"><a href="#查找合适的输出端口" class="headerlink" title="查找合适的输出端口"></a>查找合适的输出端口</h5><p>如果一个表项对应一个地址就要有40亿个表项，为了可扩展性，地址是聚合的，目标地址按一定范围映射。<strong>按照最长前缀匹配规则</strong></p><p><img src="/picture/%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80.png"></p><p>由于一个个表项匹配复杂度有点高，我们可以利用树形结构</p><p><img src="/picture/tree.png"></p><h5 id="处理速度"><a href="#处理速度" class="headerlink" title="处理速度"></a>处理速度</h5><p>输入端口的任务要更新包头还有转发表查询，大多数被硬件处理！</p><h4 id="3-输出端口"><a href="#3-输出端口" class="headerlink" title="3.输出端口"></a>3.输出端口</h4><p><img src="/picture/outputport.png"></p><p>输出端口任务：</p><ul><li>包分类：把包映射到流里面</li><li>缓冲处理：决定什么时候和哪些包要扔掉</li><li>调度：决定哪些包什么时候传输（从排队的包里面选择进行传输，当buffer满了就要选择包丢弃）</li></ul><p>缓冲处理先进先出：最简单，没有分类，buffer满了的话就丢掉后来的包</p><p><img src="/picture/fifo.png"></p><p>包分类：根据header域来把IP包分类，比如源和目的的IP地址，源和目的的TCP端口号，服务类型，协议类型……</p><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>对于每一个流（“flow”）都有一个队列，调度器决定什么时候才能够哪个队列发包。调度器的目标是：快！</p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>在最高优先级的要在低优先级之前转发</p><h6 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h6><p>轮转：每个队列里的包被轮流调度</p><p>公平排队（FQ）：对于不同大小的队列进行轮转调度</p><p>加权公平队列（WFQ）：按照权重比例来调度</p><h4 id="4-交换结构"><a href="#4-交换结构" class="headerlink" title="4.交换结构"></a>4.交换结构</h4><p>交换结构用来连接输入端口和输出端口，从输入buffer传送到合适的输出buffer。</p><p>交换速率：包可以从输入端口到输出端口传送的速率</p><p>有三种结构来交换：</p><ul><li>通过共享内存交换</li><li>通过总线交换</li><li>通过物联的网络交换：比如横梁</li></ul><p><img src="/picture/3%E7%A7%8D.png" alt="三种交换结构"></p><h5 id="4-1-通过共享内存交换"><a href="#4-1-通过共享内存交换" class="headerlink" title="4-1 通过共享内存交换"></a>4-1 通过共享内存交换</h5><p>第一代路由器采用这种，它是一种直接在CPU控制下交换的传统的电脑，分组被拷贝到系统的内存里面。速度被内存的带宽限制</p><h5 id="4-2-通过总线交换"><a href="#4-2-通过总线交换" class="headerlink" title="4-2 通过总线交换"></a>4-2 通过总线交换</h5><p>数据报通过共享总线从输入端口内存传送到输出端口内存，速率被总线的带宽限制</p><h5 id="4-3-通过网状结构交换"><a href="#4-3-通过网状结构交换" class="headerlink" title="4-3 通过网状结构交换"></a>4-3 通过网状结构交换</h5><p>克服了总线带宽的限制</p><h2 id="四-虚电路和数据报网络"><a href="#四-虚电路和数据报网络" class="headerlink" title="四.虚电路和数据报网络"></a>四.虚电路和数据报网络</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>为了传输数据会预留端到端的资源（比如带宽和交换能力）</p><p>专用的资源，没有共享</p><p>对性能有保证</p><p>连接需要建立和撤销</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>每个端到端的数据流被划分为分组</p><p>应用A，B的分组共享网络资源</p><p>存储和转发：分组一次移动一跳，并且在交换机里需要排队</p><p>资源争夺：总共的资源需要量可以超过可获得的资源总量总量</p><p>拥塞：分组排队和等待链路</p><h4 id="分组交换的两种类型"><a href="#分组交换的两种类型" class="headerlink" title="分组交换的两种类型"></a>分组交换的两种类型</h4><p>虚电路网络：对信息流提供网络服务，VC网络提供基于服务的网络连接，比如ATM，X.25，Frame Relay</p><p>数据报网络：对单个的分组提供网络服务，数据报网络提供网络层无连接服务，例如IP网络</p><p><img src="/picture/%E8%99%9A%E7%94%B5%E8%B7%AF%E8%B7%AF%E7%94%B1.png" alt="虚电路路由"></p><p><img src="/picture/%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%B7%AF%E7%94%B1.png" alt="数据报路由"></p><h5 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h5><ul><li>对于每个信息流要进行连接建立和拆除</li><li>每个分组带着VC号</li><li>在源到目的路径上的每个交换机维护每个传输连接的状态</li><li>连接，交换资源（带宽，缓存）或许被分配给虚电路</li></ul><h6 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h6><p>这个是虚电路网络的必要功能，两个主机和中间交换机预留一条路径给虚连接，路由没用来找到一条合适的路径</p><h6 id="虚电路的实现"><a href="#虚电路的实现" class="headerlink" title="虚电路的实现"></a>虚电路的实现</h6><p>一个虚电路包括一条从源到目的的路径，还包括VC号（每个链路一个），交换机里面转发表的表项。</p><p>注意：属于VC的分组携带VC号（而不是地址！！！），VC号可能在每条链路上被改变，转发表列出了新的VC号</p><p>VC的转发表如下：</p><p><img src="/picture/vc%E8%BD%AC%E5%8F%91%E8%A1%A8.png" alt="vc转发表"></p><h6 id="信令协议"><a href="#信令协议" class="headerlink" title="信令协议"></a>信令协议</h6><p>被用来建立，维护，拆除虚电路</p><p>被用在ATM，frame-relay，X.25</p><p>现在已经不用了</p><p><img src="/picture/%E4%BF%A1%E4%BB%A4%E5%8D%8F%E8%AE%AE.png" alt="信令协议"></p><h5 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h5><p>在网络层不需要连接建立，没有网络层的“连接”概念</p><p>交换：没有端对端的链接的状态</p><p>用目的主机地址来进行分组转发</p><p>在同一组源和目的之间或许会有不同的路径</p><p><img src="/picture/sjbwl.png" alt="数据报网络发包"></p><p>数据报网络的转发表：</p><p><img src="/picture/datagram.png" alt="数据报网络转发表"></p><h5 id="数据报网络和虚电路的对比"><a href="#数据报网络和虚电路的对比" class="headerlink" title="数据报网络和虚电路的对比"></a>数据报网络和虚电路的对比</h5><p>数据报：</p><ul><li>在计算机间交换数据，有弹性，没有严格的计时</li><li>聪明的端系统：可以适应，控制，错误恢复，网络内部简单，边缘复杂</li><li>不同的链路类型：不同的特点，统一的服务是很困难的</li></ul><p>虚电路：</p><ul><li>从电话演变而来</li><li>人类的交流，有严格的时限，需要可靠性，需要服务保障</li><li>沉默的端系统：电话，网络内部复杂</li><li>链路类型统一化</li></ul><h2 id="五-IP协议"><a href="#五-IP协议" class="headerlink" title="五.IP协议"></a>五.IP协议</h2><p><code>IP=Internet Protocol</code>，最著名的因特网协议，它被<code>ARPANET</code>开发</p><p>IP层的内容位于各个主机和路由器上，提供无连接服务</p><p>网络层的概览：</p><p><img src="/picture/ipwlc.png" alt="网络层"></p><h3 id="因特网寻址"><a href="#因特网寻址" class="headerlink" title="因特网寻址"></a>因特网寻址</h3><h5 id="寻址等级"><a href="#寻址等级" class="headerlink" title="寻址等级"></a>寻址等级</h5><p>物理因特网地址：用于PDU（目的MAC地址）在单个物理网络中的路由</p><p>因特网地址：IP地址或者因特网地址，用于在网络中路由PDU。对于每个端系统或者介质系统都有唯一的地址</p><p>应用层地址：在目的主机分配的进程ID，比如TCP/IP端口</p><h5 id="寻址作用域"><a href="#寻址作用域" class="headerlink" title="寻址作用域"></a>寻址作用域</h5><p>全局地址</p><p>网络连接地址</p><p>端口地址：在网络层之上并且在一个系统独一无二，例如端口80-TCP/IP的网络服务器监听端口</p><h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>个人或者单播寻址</p><p>广播地址</p><p>多播地址</p><p>任播地址</p><p><img src="/picture/al.png" alt="地址层级"></p><h3 id="IP的操作"><a href="#IP的操作" class="headerlink" title="IP的操作"></a>IP的操作</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li><p>主机和路由器维护路由表，指出数据报应被发送到的下一个路由器，静态-可能包含可替代的路径，动态-对拥塞和错误灵活的回复</p></li><li><p>路由策略：距离向量，链路状态，路径向量</p></li></ul><h4 id="数据报的生存期"><a href="#数据报的生存期" class="headerlink" title="数据报的生存期"></a>数据报的生存期</h4><p>数据报可能无限期地在两个路由器间循环</p><p>我们给数据报一个生存时间可以解决这个问题：在IP头里面放了一个TTL域（Time to live）</p><h3 id="IP结构"><a href="#IP结构" class="headerlink" title="IP结构"></a>IP结构</h3><p>IP分组包括头和负载：</p><ul><li>负载对于网络层是不透明的</li><li>头是我们需要关注的</li><li>IP层第一个端到端的层级（从下往上看）</li></ul><p>IP头是如何设计出来的呢？</p><p>我们思考一下IP头是一种在源和目的，源和中间路由器间传递网络信息的接口，那么我们设计它的话需要考虑他有多少使命要完成，很多东西既然存在必然会尤其需要的地方：需要它-&gt;被设计出来。</p><p>IP的功能：</p><ul><li>解析包</li><li>能把包送到目的</li><li>处理路上的一些问题：循环（bugs），错误，包过大</li><li>可以根据情况调节革新</li><li>处理特殊情况</li></ul><h4 id="1-解析包"><a href="#1-解析包" class="headerlink" title="1.解析包"></a>1.解析包</h4><p>首先，想要解析包，就要根据固定的格式，不同的版本格式可能不同，所以我们需要<code>IP version number（4bit）</code>，包的长度（16bit，用来查看是否有optional域，如果没有就是20byte）</p><p><code>Header length</code>表明头里面有多少个4字节，一般是5（20bype），如果有<code>Options</code>域的话可能就更多</p><h4 id="2-把包送到目的"><a href="#2-把包送到目的" class="headerlink" title="2.把包送到目的"></a>2.把包送到目的</h4><p>需要目的IP地址，32bit</p><p>我们插入一个小插曲，辨析一下MAC地址和IP地址的区别</p><table><thead><tr><th>MAC地址</th><th>IP地址</th></tr></thead><tbody><tr><td>在适配器生产时被硬编码</td><td>后期被配置的，可以被动态学习到</td></tr><tr><td>扁平的48bit的名空间</td><td>层级式的32bit名空间</td></tr><tr><td>类似身份证号</td><td>类似邮政地址</td></tr><tr><td>可携带的，不管主机移动到哪都不变</td><td>不可携带，取决于主机在哪个地方</td></tr><tr><td>被用来在同一个网络下传送包</td><td>用来给目的IP子网传送包</td></tr></tbody></table><h4 id="3-处理路径上的问题"><a href="#3-处理路径上的问题" class="headerlink" title="3.处理路径上的问题"></a>3.处理路径上的问题</h4><p>循环：为了破除循环，设计了<code>TTL(Time to Live)</code>，8bit</p><p>错误：检验和<code>checksum(16bit)</code></p><p>包太大：分段域，一共32bit，里面还有更细致的划分</p><h5 id="3-1TTL"><a href="#3-1TTL" class="headerlink" title="3-1TTL"></a>3-1TTL</h5><p>因为一些<code>bugs</code>造成包在网络中循环，这样积累起来会慢慢消耗掉网络的所有容量，所以我们设计了TTL域，开始的时候设置一个值，在每一跳都减一，当减为0的时候就丢弃这个包并且给源地址发送”Time exceeded”超时错误包</p><h5 id="3-2错误"><a href="#3-2错误" class="headerlink" title="3-2错误"></a>3-2错误</h5><p>需要检验和，在包头有一个特定的格式，如果检查出错误就丢包。</p><p>有一个问题，就是为什么在每一个路由器都要重新计算检验和呢？是因为<code>TTL</code>的改变或者包的切片会导致<code>checksum</code>发生变化！</p><h5 id="3-3分片"><a href="#3-3分片" class="headerlink" title="3-3分片"></a>3-3分片</h5><p>每一个链路都有最大传输单元（<code>MTU</code>），就是它所能承载的最大比特数量</p><p>如果包的大小超出了链路的MTU，一个路由器可以把包分成多个片。我们在目的主机必须重组恢复成最原始的包。</p><p>下面我们举一个例子：</p><p>一个<code>4000byte</code>大小的包要穿越一个<code>MTU</code>是<code>1500byte</code>的链路</p><p>那么可以切成下面这样的3片</p><p><img src="/picture/qp1.png" alt="切片"></p><p>有一个问题，切片之后为什么还要重组？下面的图片给了解答</p><p>因为上层协议的包头都在一个包的前面，后面都是数据的部分，所以我们要重组以便能够完整地交付给上层</p><p><img src="/picture/whyre.png" alt="why重组"></p><p>那么又有问题来了，我们在哪里重组？目的主机？还是路由器？</p><p>这个是端到端原理的典型案例</p><p>在如果由路由器重组就给网络带来了负担，因为重组算法比较复杂，要维护各种状态；而且切片不一定走同一条路径，所以可能很多路由器得到的切片是一些碎片。所以在中间路由器重组是事倍功半的，所以在目的主机重组</p><p>那么我们重组需要那些信息来填充字段呢？</p><p>我们需要来找到切片属于哪个分组，所以分组的ID被需要；我们还要知道每个切片是分组的哪部分，所以需要偏移量字段；<code>Flag</code>字段：</p><ul><li><code>Reserved</code>：目前被忽略</li><li>DF：不要被切片，可能会触发错误包发回发送者</li><li>MF：置1，表示这个不是末尾的切片</li></ul><p>下面我们来举个分片的例子</p><p><img src="/picture/%E5%88%86%E7%89%871.png"></p><p><img src="/picture/%E5%88%86%E7%89%872.png"></p><p><img src="/picture/%E5%88%86%E7%89%873.png"></p><p><img src="/picture/%E5%88%86%E7%89%874.png"></p><p><img src="/picture/%E5%88%86%E7%89%875.png"></p><h4 id="4-支持更新"><a href="#4-支持更新" class="headerlink" title="4.支持更新"></a>4.支持更新</h4><p>通过版本号<code>version number(4 bit)</code>，或许还可以算上”特殊处理域“</p><h4 id="5-支持一些特殊处理"><a href="#5-支持一些特殊处理" class="headerlink" title="5.支持一些特殊处理"></a>5.支持一些特殊处理</h4><h5 id="5-1特殊处理域"><a href="#5-1特殊处理域" class="headerlink" title="5-1特殊处理域"></a>5-1特殊处理域</h5><p><code>Type of Service</code>服务类型域</p><p>允许包被按需对待，比如不同的优先级，不同的拥塞提醒之类的（比如说一些实时语音通话比较注重时延，一些文件比较注重准确率）。在不同的运营商（自治域）可能要被重新定义</p><h5 id="5-2Options"><a href="#5-2Options" class="headerlink" title="5-2Options"></a>5-2Options</h5><p>它是可变长度，解析时候通过<code>packet len</code>字段来判断是否有<code>Options</code></p><h4 id="6-其他一些字段"><a href="#6-其他一些字段" class="headerlink" title="6.其他一些字段"></a>6.其他一些字段</h4><h5 id="源地址"><a href="#源地址" class="headerlink" title="源地址"></a>源地址</h5><p>我们需要告诉目的端系统是谁发来的包，所以需要<code>Source Address</code>字段</p><h5 id="协议Protocol"><a href="#协议Protocol" class="headerlink" title="协议Protocol"></a>协议Protocol</h5><p>告诉我们上层协议是什么，对于接收主机端的多路分解很重要，告诉主机要交付给哪个上层协议</p><p><img src="/picture/protocol.png" alt="协议栈"></p><h3 id="IPv4头"><a href="#IPv4头" class="headerlink" title="IPv4头"></a>IPv4头</h3><p><img src="/picture/ipv4.png" alt="IPv4"></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4地址枯竭迫使它的出现，专注于简化IP协议，抛弃一些不必要的字段，形成了一种优雅，无二义性的协议</p><p><img src="/picture/%E5%AF%B9%E6%AF%94.png" alt="IPv4和IPv6的对比"></p><p>总结一下这些变化：</p><ol><li>切片被清除</li><li>校验和被清除</li><li>options字段被清除</li><li>头的长度字段被清除</li><li>扩展了地址大小</li><li>添加了流标签</li></ol><h4 id="IPv6头"><a href="#IPv6头" class="headerlink" title="IPv6头"></a>IPv6头</h4><p><img src="/picture/ipv6.png" alt="IPv6头"></p><h5 id="Traffic-Class字段"><a href="#Traffic-Class字段" class="headerlink" title="Traffic Class字段"></a>Traffic Class字段</h5><h5 id="Flow-Label字段"><a href="#Flow-Label字段" class="headerlink" title="Flow Label字段"></a>Flow Label字段</h5><p>什么是流？</p><p>它是一个从特定源到特定目的的分组的序列</p><p>从主机的视角来看，由一个应用生成并且有同样的传输服务要求，或许包含一个单独的或者多个TCP连接。一个应用可能生成一个或者多个流</p><p>从路由器的视角看，这个是影响这些包如何被路由器处理的共享属性</p><p>流是独一无二的标识，被源和目的地址标识和非零的流标签所定义。流需求被定义优先于流的发端。路由器通过简单的在一个表中查询流标签来决定如何路由和处理分组。</p><h5 id="IPv6头的结构（包含拓展的header）"><a href="#IPv6头的结构（包含拓展的header）" class="headerlink" title="IPv6头的结构（包含拓展的header）"></a>IPv6头的结构（包含拓展的header）</h5><p><img src="/picture/ipv6s.png"></p><p>可选的部分在拓展headers里面，在主header后面呈菊花链状</p><p><img src="/picture/header.png"></p><p>这些header是按序出现的</p><p>路由器在ipv6里面不切片，因为要在核心里面更有效率的处理，切片已经在主机里面做好了。如果包在下一跳发现太大了，那么就发送包太大error消息（ICMPv6消息）</p><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>iPv6没有广播，有一个“全部节点”多播群组：ff02::1</p><p>广播的缺点，它唤醒了全部节点，实际上只有很少的设备被需要，可能造成广播风暴</p><h5 id="邻居节点探索"><a href="#邻居节点探索" class="headerlink" title="邻居节点探索"></a>邻居节点探索</h5><p>IPv6没有ARP，取而代之的是<code>Neighbor Discovery</code>，使用<code>ICMPv6</code>和多播</p><p><code>Neighbor Discovery</code>被节点使用为了获取地址，发现邻居路由器，跟踪地址变化，检查邻居可达性，做地址复制检测</p><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>128bit，单个接口或许有多个单播地址，有三种类型地址：单播，多播，任播</p><h4 id="从IPv4迁移到IPv6"><a href="#从IPv4迁移到IPv6" class="headerlink" title="从IPv4迁移到IPv6"></a>从IPv4迁移到IPv6</h4><p>所有节点不可以同时更新，所以需要有一种机制让IPv4和IPv6同时工作。</p><p>两种可能：</p><ul><li>双栈技术</li><li>隧道：在IPv4路由器中，在IPv4数据报中的IPv6头被当做数据负载</li></ul><h2 id="六-IP地址"><a href="#六-IP地址" class="headerlink" title="六.IP地址"></a>六.IP地址</h2><p>IP地址是32位的全局地址，分为网络部分（高位）和主机部分（低位）</p><p>对于主机和路由器的每个物理接口都需要一个通向一个网络的分离的地址。</p><p>使用十进制点的记法</p><p>网络部分ID被如下的三个机构管辖：</p><ul><li>American Registry for Internet Numbers (ARIN)</li><li>Reseaux IP Europeens (RIPE）</li><li>Asia Pacific Network Information Centre (APNIC)</li></ul><p>主机部分ID被指定的组织来分配</p><h3 id="IPv4地址格式"><a href="#IPv4地址格式" class="headerlink" title="IPv4地址格式"></a>IPv4地址格式</h3><p>分为A类地址，B类地址，C类地址……</p><p><img src="/picture/ipv4dizhi.png" alt="IPv4地址"></p><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p><img src="/picture/A.png" alt="A类地址"></p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p><img src="/picture/B.png" alt="B类地址"></p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p><img src="/picture/C.png" alt="C类地址"></p><h3 id="子网和子网掩码"><a href="#子网和子网掩码" class="headerlink" title="子网和子网掩码"></a>子网和子网掩码</h3><p>处理网络地址不足，地址的主机部分分为子网号和主机号。子网掩码指出哪些比特是子网号，哪些是主机号，每个局域网被分配一个子网号，本地路由器在子网里面路由</p><p>子网对于因特网的其余部分看起来像一个单独的网络，把全部的网络从网络号和路由的复杂中隔离出来</p><p><img src="/picture/subtorest.png"></p><p><img src="/picture/route.png"></p><h3 id="CIDR记法"><a href="#CIDR记法" class="headerlink" title="CIDR记法"></a>CIDR记法</h3><p>无类域间路由，一个IP地址以“A.B.C.D/n”的形式被呈现，n叫做IP前缀</p><p><img src="/picture/CIDR.png"></p><h2 id="七-网络层协议簇"><a href="#七-网络层协议簇" class="headerlink" title="七.网络层协议簇"></a>七.网络层协议簇</h2><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h3><p>对内部和外部流量启用不同的IP地址</p><p>网络地址转换发生在带有更广阔的因特网的内联网接口</p><p>目的：</p><ul><li>作为一个防火墙隐藏内部IP地址</li><li>允许一个组织使用更多的内部IP地址</li><li>隔离组织的变化</li></ul><p>下面有3种NAT：</p><ul><li>静态NAT：一个私有的IP地址映射到一个预留的共有IP地址，用于网络服务器</li><li>动态NAT：NAT路由器保持一个已注册IP地址池，在需要的时候分配给私有IP地址，通常用于客户内部网PC</li><li>单地址：NAT/Overloading/Masquerading/Network Address  Port Translation (NAPT）</li></ul><p>图解NAT：</p><p><img src="/picture/NAT.png"></p><p><img src="/picture/overload.png"></p><p><img src="/picture/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="网络地址转换"></p><p>NAT是很有争议的，地址不时会发生变化，必须被P2P应用纳入考虑</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><code>Internet Control Message Protocol</code></p><p>用来在主机和路由器间传播错误和控制消息</p><ul><li>Echo请求和Echo回复被用来诊断网络</li><li>还会传达关于问题的反馈，比如超时，不可达主机……</li></ul><p>被封装在IP数据报里面</p><ul><li><code>Protocol type=1</code></li><li>不可靠</li></ul><p><img src="/picture/ICMP.png" alt="ICMP信息格式"></p><p><img src="/picture/ICMP1.png" alt="ICMP类型"></p><p><img src="/picture/ICMP2.png" alt="ICMP不同类型格式"></p><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>测试目的地址是否可达，源发送一个<code>echo request</code>给遥远的主机或者路由器。如果远程系统收到了<code>ICMP</code>包，他会给源回复一个<code>echo reply</code>。</p><p>ping的实用程序可以做得更好，比如计算从发送到接收时间，计算到目的有多少跳</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>用来测量到目的地址需要多少跳</p><ol><li>源发送TTL等于1的第一个IP（UDP）包，第一个路由器把TTL减为0，然后发送TTL超时错误给源。源计算RTT，然后重复三次</li><li>源发送第二个IP包（TTL设置为2），第二个路由器发回TTL超时错误，源计算RTT，然后重复三次</li><li>源继续增加TTL知道到达目的</li></ol><p>Path MTU</p><p>用来找到路径上的最小MTU</p><ol><li>源发送不带有切片位的大IP包</li><li>如果包太大，相关路由器会发送错误包</li><li>源相应减小包的大小，再次尝试</li><li>重复直到包到达目的（没有收到错误包）</li></ol><h2 id="八-移动IP"><a href="#八-移动IP" class="headerlink" title="八.移动IP"></a>八.移动IP</h2><p>移动IP标准在1996年被IESG批准，同年被IETF作为一种被提议的标准发布。它被发明出来是为了应对日益增长的PDA和Laptop的使用需求。</p><p>数据报从一个网络移动到另一个网络需要用到目的的IP地址，IP地址被划分为两部分<code>&lt;netID,hostID&gt;</code>，大多数网络应用支持<code>TCP</code>连接，<code>TCP</code>使用IP地址和端口号来路由和交付。当移动设备从一个网络移动到另一个的时候，它的IP地址动态改变，因此TCP连接在每次移动的时候需要重启正在进行的会话。移动IP正在解决动态变化的IP地址的问题，就不必重启TCP，就好像移动设备的IP地址假装没改变</p><p><img src="/picture/mip.png"></p><h3 id="不同的实体"><a href="#不同的实体" class="headerlink" title="不同的实体"></a>不同的实体</h3><p>移动节点：一个或许会改变它的接入点或者从一个网络到另一个网络连接的主机</p><p>通信节点：一个要给移动节点发包的主机</p><p>归属代理：一个在归属网络上维护一个已注册移动节点列表的节点</p><p>外部代理：一个在外部网络上帮助移动节点发送数据报的路由器</p><h3 id="三角路由"><a href="#三角路由" class="headerlink" title="三角路由"></a>三角路由</h3><p><img src="/picture/%E4%B8%89%E8%A7%92%E8%B7%AF%E7%94%B1.png"></p><h3 id="协议的细节"><a href="#协议的细节" class="headerlink" title="协议的细节"></a>协议的细节</h3><p>移动路由有三种能力：发现，注册，隧道技术</p><h4 id="1-发现"><a href="#1-发现" class="headerlink" title="1.发现"></a>1.发现</h4><p>移动（外部）代理：周期性发送带有移动代理广告扩展的ICMP路由广告来表明它的存在</p><p>移动节点：可以向代理请求广告或者简单地等待下一个广告</p><h4 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h4><p>移动节点：需要来自外部代理的转交地址。请求它的归属代理来转发数据包到外部代理。</p><p>四步：</p><ol><li>移动节点发送<code>registration request</code>给外部代理</li><li>外部代理转发这个请求给归属代理</li><li>归属代理发送<code>registration reply</code>给外部代理</li><li>外部代理转发这个<code>reply</code>给移动节点</li></ol><p><img src="/picture/registration.png"></p><p>下面是一个注册的例子</p><p><img src="/picture/%E4%BE%8B%E5%AD%90.png"></p><h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h4><p>在注册之后，一个IP隧道建立起来了，在归属代理和移动节点的COA之间建立。归属节点广播把移动节点IP地址绑定到归属代理MAC地址的ARP请求。因此，归属代理收到了发送给移动节点的包，会通过IP隧道转发给外部代理</p><p><img src="/picture/111.png"></p><h2 id="九-路由算法"><a href="#九-路由算法" class="headerlink" title="九.路由算法"></a>九.路由算法</h2><p>路由分为中心化的路由和分布式路由</p><p>中心化：固定的并且需要配置</p><p>分布式：通过洪泛，随机的，自适应的</p><p><img src="/picture/cvd.png"></p><h3 id="插播：洪泛（分布式）"><a href="#插播：洪泛（分布式）" class="headerlink" title="插播：洪泛（分布式）"></a>插播：洪泛（分布式）</h3><p>洪泛不需要全局网络信息，分组被交换机发送给所有邻居，分组在除了入链路的每个链路都会转发，最后很多拷贝会到达目的。</p><p>洪泛的性质：所有可能的路由都会被尝试，至少一个包会通过最小cost路由，所有的交换机都被访问过（分布式，可能用于路由）</p><h3 id="随机路由（分布式）"><a href="#随机路由（分布式）" class="headerlink" title="随机路由（分布式）"></a>随机路由（分布式）</h3><p>节点选择一个出链路来转发到来的包，选择是随机或者轮流的，基于概率。不需要什么网络信息，适合强连通网络，路由不是最佳的。</p><p>以下说明如何分配概率：</p><p><img src="/picture/p.png"></p><h3 id="自适应路由"><a href="#自适应路由" class="headerlink" title="自适应路由"></a>自适应路由</h3><p>被用作几乎所有分组交换网络，当网络状况改变时候路由决策也会改变。需要网络的信息，需要在网络质量和开销之间权衡。有助于拥塞控制</p><h3 id="两种最小花费算法"><a href="#两种最小花费算法" class="headerlink" title="两种最小花费算法"></a>两种最小花费算法</h3><p><code>Dijkstra</code>算法和<code>Bellman-Ford</code>算法</p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>找到从给定源到其他所有节点的最短路径</p><ul><li>N是网络中的节点集合</li><li>s是源节点</li><li>T是到目前为止已经被算法合并的节点</li><li><code>w(i,j)</code>是从i到j的链路消耗<ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li></ul><h5 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h5><p><code>L(n)</code>是从源s到当前已知的节点n的最小路径花费</p><ol><li>初始化<ul><li><code>T={s}</code>是只包含源点s被合并其中的节点的集合</li><li><code>L(n)=w(s,n) for n≠s</code></li><li>初始化到邻居节点的路径花费</li></ul></li><li>得到下一个节点<ul><li>找到不在T中的到源点s的最短路径的x，<code>min L(x)</code></li><li>把x合并在T中</li></ul></li><li>更新路径<ul><li><code>L(n)=min{L(n),L(x)+w(x,n)} for all n∉T</code></li><li>如果后者更小的话，那么从s到n的路径就变成了从s到x再从x到n的路径</li></ul></li></ol><p>算法在所有节点被添加到T中时结束</p><p>步骤2和3的一次迭代会添加一个新节点到T中</p><p><img src="/picture/dijkstra.png"></p><p>但是可能会出现震荡，解决办法就是非同步运行路由算法，链路代价更新随机化（让每台路由器发送链路通告的时间随机化）</p><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>找到一条从给定节点包含最多一条链路的最短路径，</p><p>找到一条从给定节点包含最多两条链路的最多路径（基于前面的步骤）</p><p>找到一条…不断进行迭代</p><ul><li><p>s是源点</p></li><li><p><code>w(i,j)</code>是从i到j的链路消耗</p><ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li><li><p>h是在当前阶段路径上链路的最大数量</p></li><li><p><code>L_h(n)</code>是在当前不超过h条链路的限制下从s到n的最短链路消耗</p></li></ul><h5 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>初始化<ul><li><code>L_0(n) = ∞, for all n ≠ s</code> </li><li><code>L_1(n) = w(s, n) </code></li><li><code>L_h(s) = 0, for all h</code></li></ul></li><li>更新<ul><li>对于每个连续的<code>h&gt;0</code></li><li>对于每个<code>n≠s</code>，计算<code>L_(h+1)(n) = min_j [Lh(j)+w(j,n)]</code></li><li>用已经找到最小的预处理节点j连接n</li><li>消除在早期迭代过程中形成的n的任何连接</li></ul></li><li>重复一直到没有改变</li></ol><p><img src="/picture/Bellman.png"></p><h5 id="链路花费改变"><a href="#链路花费改变" class="headerlink" title="链路花费改变"></a>链路花费改变</h5><p>当链路代价改变时候：</p><ul><li>节点检测到本地链路代价改变了</li><li>更新路由信息，重新计算距离向量</li><li>如果<code>DV</code>，改变了，就通知周围邻居<ul><li><img src="/picture/dv.png"></li><li>t0:y检测到链路代价改变，更新dv，通知邻居</li><li>t1:z收到来自y的更新，更新自己的表，计算到x的最小距离，发送给邻居</li><li>t2:y收到z的更新，更新自己的表，没有改变，所以不用给z发送消息</li></ul></li></ul><p>这样会出现无穷计数问题，当链路代价改变时候需要非常多次迭代才可以稳定下来！！！所以我们需要一种机制，叫做<strong>毒性逆转</strong></p><p>毒性逆转：当一个节点a通过b到达c，那么我向b声称我到c的距离是无穷！！！</p><h4 id="Dijkstra-VS-Bellman-Ford"><a href="#Dijkstra-VS-Bellman-Ford" class="headerlink" title="Dijkstra VS Bellman-Ford"></a>Dijkstra VS Bellman-Ford</h4><p>基于DIjkstra路由：</p><ul><li><strong>链路状态</strong>洪泛到其他所有节点</li><li>每个节点将会有一个完整的拓扑，并且建立他自己的路由表</li><li>不能处理负权值</li></ul><p>基于Bellman-Ford路由：</p><ul><li>每个节点维护一个到其他已知节点的<strong>距离向量</strong></li><li>距离向量要发送给直接邻居来更新路径和cost</li><li>路由表是分布式的</li></ul><h5 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h5><p>DK：n个节点，e个链路，有O(ne)个消息</p><p>BF：取决于收敛时间</p><h5 id="收敛时间："><a href="#收敛时间：" class="headerlink" title="收敛时间："></a>收敛时间：</h5><p>DK：O(n^2)并且很快，或许会有震动</p><p>BF：很慢并且取决于链路代价改变，或许包含路由环</p><h5 id="鲁棒性："><a href="#鲁棒性：" class="headerlink" title="鲁棒性："></a>鲁棒性：</h5><p>DK：可能广播不正确的链路代价，但是错误的范围被限制</p><p>BF：错误节点可能交换不正确的路径代价，错误可能会传播到网络中</p><h3 id="路由算法分类："><a href="#路由算法分类：" class="headerlink" title="路由算法分类："></a>路由算法分类：</h3><h4 id="中心化算法和去中心化（分布式）算法"><a href="#中心化算法和去中心化（分布式）算法" class="headerlink" title="中心化算法和去中心化（分布式）算法"></a>中心化算法和去中心化（分布式）算法</h4><p>中心化：所有节点都要有完整的拓扑，链路代价信息，比如<strong>链路状态算法</strong></p><p>分布式：路由器知道物理上直接连接的邻居，还有到邻居的代价，通过迭代的计算过程和邻居交换信息，比如<strong>距离向量算法</strong></p><h4 id="静态或动态"><a href="#静态或动态" class="headerlink" title="静态或动态"></a>静态或动态</h4><p>静态：经过时间，路由很慢的改变</p><p>动态：路由很快进行改变，为了回应链路代价的改变，周期化进行更新</p><h3 id="如何判断链路代价？"><a href="#如何判断链路代价？" class="headerlink" title="如何判断链路代价？"></a>如何判断链路代价？</h3><p>在ARPANET中有3个阶段：</p><h4 id="1969年第一个阶段"><a href="#1969年第一个阶段" class="headerlink" title="1969年第一个阶段"></a>1969年第一个阶段</h4><p>输出队列的长度作为链路代价</p><p>Bell-Ford被用于路由</p><h4 id="1979年第二个阶段"><a href="#1979年第二个阶段" class="headerlink" title="1979年第二个阶段"></a>1979年第二个阶段</h4><p>测量出来的延时作为链路代价，其中混合了排队时延，传输时延，传播时延。Dijkstra算法用于路由</p><h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>为了处理Dijkstra的震荡问题，让一些连接保持在加载的链路上来平衡流量。把链路利用率来表示链路状态，用之前的值和新的利用率结合起来更新。也有的用跳归一化指标来计算链路代价。</p><p>链路利用率：</p><ul><li>p=2（Ts-T）/(Ts-2T)</li><li>T是当前测量的时延</li><li>Ts是分组的长度除以传输速率（传输时延）</li></ul><p>更新利用率</p><ul><li><code>Un=αp+(1-α)Un-1</code></li><li>Un是第n次的链路利用率</li><li>α是常数，现在设置为0.5</li></ul><h2 id="十-因特网路由"><a href="#十-因特网路由" class="headerlink" title="十.因特网路由"></a>十.因特网路由</h2><p>层级化路由：把路由器整合到一个个域里面，叫自治系统（autonomous system，AS）。同一个AS里面的运行同样的路由协议（AS内部路由协议）；不同AS可以运行不同的AS内部路由协议。网关路由器负责目的地址在AS外部的路由，跟外面的路由器一起运行AS间路由协议，和内部路由器运行AS内部路由协议。</p><h3 id="自治系统（Autonomous-Systems，AS）"><a href="#自治系统（Autonomous-Systems，AS）" class="headerlink" title="自治系统（Autonomous  Systems，AS）"></a>自治系统（Autonomous  Systems，AS）</h3><p>它是被单个ISP或者更大组织掌管的路由器和网络的集合。一个被分配独一无二的AS号（ASN）的网络，使用普通的路由协议。</p><p>IGP是Interior Gateway Protocol，用于AS内路由。EGP是Exterior Gateway Protocol，用于AS间路由</p><h4 id="IGP"><a href="#IGP" class="headerlink" title="IGP"></a>IGP</h4><ul><li>RIP: Routing Information Protocol, use distance  vector</li><li>OSPF: Open Shortest Path First, use link state</li><li>IGRP: Interior Gateway Routing Protocol (Cisco proprietary)</li></ul><h4 id="EGP"><a href="#EGP" class="headerlink" title="EGP"></a>EGP</h4><ul><li>BGP: Border Gateway Protoco</li></ul><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>每个节点和邻居节点交换信息。节点维护自己到邻居链路代价，下一跳到目的的距离向量。DV根据跟邻居交换信息来更新路由表</p><h3 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h3><p>要把消息告知拓扑中的所有其他路由器（不只是邻居）</p><p>每一个路由器都可以构建出整个拓扑，可以计算出到达每个目的网络的最短路径。路由器实际上使用<code>Dijkstra</code>算法</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>使用距离向量算法。距离靠多少跳来度量，距离向量每三十秒跟邻居交换一次。如果180秒没收到信息，说明邻居没了。用UDP包。</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先，利用链路状态路由算法。每十秒更新一次，直接用IP承载，不用UDP。</p><p>网络，主机和BGP路由器都是目的，每个路由器计算它到其他目的最短路径的SPF tree</p><p><img src="/picture/SPF.png"></p><h4 id="OSPF高级的功能"><a href="#OSPF高级的功能" class="headerlink" title="OSPF高级的功能"></a>OSPF高级的功能</h4><ul><li>安全性：所有的OSPF消息需要认证来组织恶意入侵</li><li>可以允许多个相同路径</li><li>对于每个链路，对于不同TOS有多种不同代价度量方式</li><li>综合单播和多播支持</li><li>在更大的域里面用层级OSPF</li></ul><h4 id="层级式OSPF"><a href="#层级式OSPF" class="headerlink" title="层级式OSPF"></a>层级式OSPF</h4><p>为了提升可扩充性，AS或许被划分为不同区域</p><ul><li>区域被32位Aera ID认定</li><li>区域里的路由器只知道区域内部的拓扑</li><li>限制链路状态信息洪泛到其他区域</li><li>区域边界路由器从其他区域总结信息</li></ul><p>每个区域必须连接到骨干区域(0.0.0.0)</p><ul><li>在区域间的分布式路由信息</li></ul><p>好处：划分区域的好处是将洪泛交换链路状态信息的范围局限于每一个区域 而不是整个的自治系统。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其 他区域的网络拓扑的情况。主干区域用于连通其他下层区域</p><p><img src="/picture/OSPFarea.png"></p><h4 id="RIP-vs-OSPF"><a href="#RIP-vs-OSPF" class="headerlink" title="RIP vs OSPF"></a>RIP vs OSPF</h4><p>RIP</p><ul><li>配置简单，适用于小型网络（小于15跳）</li><li>可分布式实现</li><li>收敛速度较慢</li><li>网络是一个平面，不适用于大规模网络</li></ul><p>OSPF</p><ul><li>收敛速度快，无跳数限制</li><li>支持不同服务类型选路</li><li>支持身份认证</li><li>支持层次式网络，适用于大规模复杂网络</li><li>集中式算法</li><li>每个节点需要维护全局拓扑</li><li>配置复杂</li></ul><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><h4 id="由于跨AS业务关系形成的拓扑和策略"><a href="#由于跨AS业务关系形成的拓扑和策略" class="headerlink" title="由于跨AS业务关系形成的拓扑和策略"></a>由于跨AS业务关系形成的拓扑和策略</h4><p>AS间的三种基本关系</p><ul><li>A是B的客户</li><li>A是B的供应商</li><li>A是B的伙伴</li></ul><p>客户给供应商交钱。伙伴之间不需要交钱，大概网络程度类似</p><p><img src="/picture/AS%E4%B8%9A%E5%8A%A1%E5%85%B3%E7%B3%BB.png"></p><p>为什么要伙伴关系</p><p><img src="/picture/peer.png"></p><p>AS为他们的客户提供传输服务，但是不提供它的peers之间的传输服务</p><p><img src="/picture/allow.png"></p><p>总结来说，AS拓扑反映了AS之间的业务关系，AS之间的业务关系反映了什么样的路由选择是可接受的</p><h4 id="基本想法"><a href="#基本想法" class="headerlink" title="基本想法"></a>基本想法</h4><p><img src="/picture/basic.png"></p><p>BGP是被DV算法所启发</p><p>每个目的地址进行通知，没有全局共享拓扑信息，在路径上进行迭代和分布式收敛。不过有四种关键的不同之处</p><h4 id="和BGP的不同之处"><a href="#和BGP的不同之处" class="headerlink" title="和BGP的不同之处"></a>和BGP的不同之处</h4><h5 id="1-不选择最短路径"><a href="#1-不选择最短路径" class="headerlink" title="1.不选择最短路径"></a>1.不选择最短路径</h5><p>BGP基于策略选择最好的路由，而不是最短的距离（比如最小的花费），如下图可能A可能选择ABC而不是AC</p><p><img src="/picture/abc.png"></p><h5 id="2-路径向量路由"><a href="#2-路径向量路由" class="headerlink" title="2.路径向量路由"></a>2.路径向量路由</h5><p>主要思想：message要记录整个路径</p><ul><li>DV：发送到目的的距离度量</li><li>BGP：发送到目的的整个路径</li></ul><p>好处：避免循环（遇到路径上有我自己的直接丢弃）；灵活并且有表现力</p><h5 id="3-选择性的路由通告"><a href="#3-选择性的路由通告" class="headerlink" title="3.选择性的路由通告"></a>3.选择性的路由通告</h5><p>出于策略上的原因，AS可以选择不发布到目的地的路由。因此，即使物理上相连，也不一定可达</p><h5 id="4-BGP或许会合并路由"><a href="#4-BGP或许会合并路由" class="headerlink" title="4.BGP或许会合并路由"></a>4.BGP或许会合并路由</h5><p>为了稳定性，BGP或许会把不同前缀地址的路由进行合并</p><h4 id="BGP的细节"><a href="#BGP的细节" class="headerlink" title="BGP的细节"></a>BGP的细节</h4><p>谁来运行BGP呢？自治系统中的边界路由器</p><p><img src="/picture/border.png"></p><p>Speak BGP意味着什么？</p><ul><li>实现BGP协议标准</li><li>说明要和其他BGP speaker交换什么消息</li><li>如何处理这些消息</li></ul><p>边界路由器之间使用eBGP会话，边界路由器和同一个AS内的其他路由器使用iBGP会话</p><p>eBGP：在不同AS的边界路由器之间的BGP会话</p><p>IBGP：在边界路由器和同一个AS下的其他路由器之间的BGP会话</p><p>IGP：内部网关协议提供内部可达性，比如OSPF，RIP</p><h5 id="BGP里面的基础消息"><a href="#BGP里面的基础消息" class="headerlink" title="BGP里面的基础消息"></a>BGP里面的基础消息</h5><h6 id="open"><a href="#open" class="headerlink" title="open"></a>open</h6><p>建立BGP会话（利用TCP）</p><h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><p>报道不寻常的情况</p><h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><p>通知新邻居路由器</p><p>通知不活跃的老邻居路由器</p><h6 id="保持开放"><a href="#保持开放" class="headerlink" title="保持开放"></a>保持开放</h6><p>告诉邻居连接依然保持</p><h5 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h5><p>格式<code>&lt;IP prefix : route attributes&gt;</code>（<code>attributes</code>描述了路由的性质）</p><p>两种更新</p><p>通告：有新的路由或者已存在路由发生改变</p><p>撤回：移除不再存在的路由</p><h5 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h5><p>路由用属性来描述，一些属性是本地的（在AS内部，不在通告中）；一些属性通过eBGP通告被传播出去</p><h6 id="ASPATH"><a href="#ASPATH" class="headerlink" title="ASPATH"></a>ASPATH</h6><p>在路由通告里面被装载，列出了经过的所有AS的向量（反向列出）</p><p><img src="/picture/AS.png"></p><h6 id="Local-Pref"><a href="#Local-Pref" class="headerlink" title="Local Pref"></a>Local Pref</h6><p>本地偏好是用来在不同AS路径中做出选择，只在iBGP消息中，值越大越偏好</p><p><img src="/picture/pref.png"></p><h6 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h6><p>当AS通过2个或多个链路互连时，使用多出口识别器;它指定前缀离宣布它的链接有多近。越低越好</p><p><img src="/picture/MED.png"></p><p>下面是BGP更新的过程</p><p><img src="/picture/BGP.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>主要用于表示路由的可达性，不一定走最短路径路由</p></li><li><p>通过携带AS路径信息，可以解决路由循环问题</p></li><li><p>使用TCP协议，端口号179，可实现协议的可靠性</p></li><li><p>BGP 协议交换路由信息的结点数量级是自治系统数的量级。</p></li><li><p>由于自治系统中 BGP Speaker（或边界路由器）的数 目是很少的，使得自治系统之间的路由选择不致过分复杂。</p></li><li><p>支持 CIDR，可以进行路由聚合。</p></li><li><p>在BGP 刚刚运行时，BGP的邻站交换整个的BGP路由表</p><p>。但以后只需要在发生变化时增量更新有变化的部分，减少开销。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DP-有向无环图的最长路径</title>
      <link href="/2021/06/07/DP-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/06/07/DP-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图中的最长路径"><a href="#有向无环图中的最长路径" class="headerlink" title="有向无环图中的最长路径"></a>有向无环图中的最长路径</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为一个数字<code>n</code>，表示总点数。之后点的标号为从<code>0</code>到<code>n-1</code>。</p><p>之后的每一行，格式为<code>3</code>个数字，以空格隔开，分别为相连的两个点的编号，它们的边的权值。</p><p>注：输入为有向图。如果出现了<code>“0 1 50”</code>表示点<code>0</code>到点<code>1</code>之间有一条边，权值为<code>50</code>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>点0到其他所有点的最长路径，以空格隔开。注：点0到其他所有点都是可达的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度要求在<strong>O(m+n)</strong></p><p>样例输入输出</p><pre class="line-numbers language-none"><code class="language-none">输入：60 1 10 3 21 2 62 4 12 5 23 4 33 1 44 5 1输出：6 12 2 13 14 </code></pre><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先，看到复杂度是线性时间复杂度，我们想到不太可能用类似<code>Dijkstra</code>，<code>Prime</code>之类的算法，大概是用一个<code>DFS</code>或者<code>BFS</code>框架来完成。</p><p>对于有向无环图，我们会敏锐地发觉它的一些特性：从0经过某些顶点之前，路径上必然会经过另一些顶点！！！如果我们在处理顶点A之前，对它之前的所有顶点的路径进行处理的话，我们就可以依托之前的路径来对顶点A进行处理。这句话怎么听起来这么耳熟？没错，这似乎就是动态规划的具体做法！</p><p>众所周知，动态规划的思路就是<strong>利用前面已经求出的子问题来解决其他的子问题</strong>。我们通过前面经过的顶点来求后面的顶点，与这个思想相符。那么我们怎么判断谁在前谁在后呢？联系算法需要的线性复杂度，我们联想到<code>Topo</code>排序，对顶点进行拓扑序小的在前面，拓扑序大的在后面。那么基本的思路逐渐清晰了。</p><p>先利用拓扑排序对顶点进行排序，这样我在遍历某一个顶点A的时候，从0到A的路径上的所有顶点必然已经被遍历过！那么我们如何找到他前面的顶点呢？做法有两种，第一种是建立一个逆邻接表，这样就可以找到哪一个路径通向点A；第二种做法是在遍历A前面节点X的时候，直接对X的邻居进行处理，这样在遍历到A的时候，A已经被处理完了，A的任务就只变成了对A的邻居进行处理。这两种做法本质上是一样的，但是鉴于省下更多的时间和空间，我采用了第二种方法！</p><p>复杂度分析：<code>topo</code>排序是线性复杂度，后面的<code>DP</code>也是线性复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面我们就可以进行Coding了！代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std; //邻接表节点，存储邻居节点和路径长度struct node {    int v, weight;    node(int _v, int _w) { v = _v; weight = _w; }};//邻接表，二维矩阵vector&lt;vector&lt;node&gt;&gt; table;//topo的本质是DFS，需要visit数组vector&lt;bool&gt; visit;//存储topo序，顶端的topo序更小stack&lt;int&gt; topo;//存储答案vector&lt;int&gt; res; void dfs(int v) {    visit[v] = true;    for (int i = 0; i &lt; table[v].size(); i++) {        if(!visit[table[v][i].v])dfs(table[v][i].v);    }    topo.push(v);//在处理过v后面所有的节点之后，v的节点topo序要小于它后面的所有节点} int main() {    int n;    scanf("%d", &amp;n);//初始化         res = vector&lt;int&gt;(n, 0);    visit = vector&lt;bool&gt;(n, false);    table = vector&lt;vector&lt;node&gt;&gt;(n);    int v1, v2, w;    while (scanf("%d %d %d",&amp;v1,&amp;v2,&amp;w)!=-1) {        table[v1].push_back(node(v2, w));    }     dfs(0);//topo排序     while (!topo.empty()) {        int cur = topo.top();        topo.pop();        for (int i = 0; i &lt; table[cur].size(); i++) {//处理cur的邻居            res[table[cur][i].v] = max(res[table[cur][i].v], res[cur] + table[cur][i].weight);        }    }    for (int i = 1; i &lt; n; i++) {        printf("%d ", res[i]);    }     return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记链路层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-直接链路"><a href="#一-直接链路" class="headerlink" title="一.直接链路"></a>一.直接链路</h2><p>主机和路由器都是节点。连接相邻结点的信道叫做链路。</p><p>链路的不同类型：</p><ul><li>有线点对点链路</li><li>有线多址链路（LANs）</li><li>无线链路（WIFI）</li></ul><h2 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二.数据链路层"></a>二.数据链路层</h2><p>二层分组（链路层分组）：帧，封装了网络层数据报</p><p>在相邻节点之间或者同一个局域网中的节点之间传送数据</p><p><img src="/picture/image-20210607210230081.png"></p><h3 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h3><p>在主机，路由器，交换机中实现。</p><p>链路层被实现在适配器中<code>"adaptor"</code>，比如网络接口卡（<code>NIC</code>）。以太网卡，802.11卡。</p><p>实现链路层和物理层，和主机的系统总线相连</p><p>硬件软件和固件的结合体</p><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p>提供了4种初级服务</p><h4 id="1-成帧"><a href="#1-成帧" class="headerlink" title="1.成帧"></a>1.成帧</h4><p>添加头尾封装上层数据报成帧</p><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>把数据报封装在帧中，添加错误检测比特，流控信息等等</p><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>寻找错误，进行流控等等。然后提取数据报交付给上层</p><h4 id="2-链路接入"><a href="#2-链路接入" class="headerlink" title="2.链路接入"></a>2.链路接入</h4><p>协调多路媒体访问，MAC地址被用在帧的头部来确定源和目的主机</p><p>全双工和半双工：接收和发送是否同时进行</p><p>有两种链路：</p><ul><li>点对点链路：专用的成对通信<ul><li>长距离光纤链路</li><li>在以太网交换机和主机之间的点对点链路</li></ul></li><li>广播链路：共享线路和媒介<ul><li>传统的以太网</li><li>802.11无线局域网</li></ul></li></ul><p><img src="/picture/image-20210607212004381.png"></p><h5 id="多路访问控制（MAC）"><a href="#多路访问控制（MAC）" class="headerlink" title="多路访问控制（MAC）"></a>多路访问控制（MAC）</h5><p>环境是一个共享的广播信道，它必须避免多个节点同时传送信息，否则碰撞导致数据错误！所以需要一个分布式的算法来决定哪一个节点可以传输数据，这样多路访问协议就诞生了。</p><p>多路访问协议是一个决定节点如何共享信道的分布式的算法，比如决定节点什么时候可以传输数据。关于信道共享的交流必须用到信道本身来交流（没有带外通道进行协作）</p><h5 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h5><p>这里有三种方式</p><h6 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h6><p>把信道分成不同的片，把这些片分配给节点，让节点单独占用</p><h6 id="轮流"><a href="#轮流" class="headerlink" title="轮流"></a>轮流</h6><p>节点轮流传送数据，但是需要发送更多数据的节点可能会等待较长时间</p><h6 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h6><p>信道不被分割，并且允许碰撞。碰撞之后要进行恢复。</p><h4 id="3-可靠交付"><a href="#3-可靠交付" class="headerlink" title="3.可靠交付"></a>3.可靠交付</h4><p>这种服务很少被用在像光纤这样的低比特错误率的链路，用在无线链路是高比特错误率。</p><p>进行流控：控制收发速率，确保发送者不会发送太快导致接收者的buffer溢出，有两种方法：</p><ul><li>停等协议</li><li>滑动窗口协议</li></ul><h5 id="3-1停等协议"><a href="#3-1停等协议" class="headerlink" title="3-1停等协议"></a>3-1停等协议</h5><h6 id="源主机传输帧，目的主机接收帧并且回复ACK"><a href="#源主机传输帧，目的主机接收帧并且回复ACK" class="headerlink" title="源主机传输帧，目的主机接收帧并且回复ACK"></a>源主机传输帧，目的主机接收帧并且回复ACK</h6><p>源主机在收到ACK之前不发送下一个包，目的主机可以通过不发送ACK来停止流</p><p>这种对于大型帧工作得很好</p><p><img src="/picture/image-20210607224657108.png"></p><h5 id="3-2滑动窗口协议"><a href="#3-2滑动窗口协议" class="headerlink" title="3-2滑动窗口协议"></a>3-2滑动窗口协议</h5><p>允许多个帧同时传送。接收者有一个大小为WIn得buffer（窗口），发送者可以发送最多Win个没有收到ACK的帧。每一个帧都被标号，ACK包含了下一个期待的帧的编号。序号被size域的大小k限制，帧的大小以2的k次方取模。</p><p>有一个问题：如果给定WIn，那么如何设置k？Win&lt;=2^k</p><p><img src="/picture/image-20210607224627065.png"></p><p>下面的图帮助理解滑动窗口</p><p><img src="/picture/image-20210607224804564.png"></p><h6 id="3-2-1后退n帧"><a href="#3-2-1后退n帧" class="headerlink" title="3-2-1后退n帧"></a>3-2-1后退n帧</h6><p>如果出现错误就恢复NAK，错误的帧和后面的所有帧都需要重传</p><h6 id="3-2-2选择性拒绝（选择重传）"><a href="#3-2-2选择性拒绝（选择重传）" class="headerlink" title="3-2-2选择性拒绝（选择重传）"></a>3-2-2选择性拒绝（选择重传）</h6><p>只有被拒绝的错误帧需要重传，接收者需要维护一个足够大的buffer</p><h4 id="4-错误检测和纠正"><a href="#4-错误检测和纠正" class="headerlink" title="4.错误检测和纠正"></a>4.错误检测和纠正</h4><p>处理由信号衰减和噪声导致的错误。接收者检测错误的出现，让信号发送者重传或者直接丢弃帧</p><p><img src="/picture/image-20210607225210550.png"></p><p>EDC是错误检测纠正码（冗余码），D是被错误检查保护的数据（包括头）</p><p>注意错误检测不是百分百可靠！比较大的EDC能更好的检测和纠正错误</p><h5 id="4-1奇偶校验法"><a href="#4-1奇偶校验法" class="headerlink" title="4-1奇偶校验法"></a>4-1奇偶校验法</h5><p>单比特奇偶校验：只能检测一位错误</p><p><img src="/picture/image-20210607225453805.png"></p><p>二维奇偶校验：能够检测和纠正单比特错</p><p><img src="/picture/image-20210607225658684.png"></p><h5 id="4-2CRC循环冗余码"><a href="#4-2CRC循环冗余码" class="headerlink" title="4-2CRC循环冗余码"></a>4-2CRC循环冗余码</h5><p>CRC被广泛运用硬件实现。数据部分D是二进制数字，有d位。选择一个<code>r+1</code>位的模式串G（生成多项式）<br>$$<br>𝐷∗2^𝑟=𝑎∗𝐺⊕𝑅, so 𝐷∗2^𝑟⊕R=a*G<br>$$<br>发送方发送左侧的<code>𝐷∗2^𝑟⊕R</code>代表<code>&lt;D,R&gt;</code></p><p>接收方当收到<code>&lt;D,R&gt;</code>的时候，如果被G整除就没错，否则就有错</p><p>限制：只可以检测出少于r+1位的突发错误</p><p><img src="/picture/image-20210607230618063.png"></p><h2 id="三-不同类型的局域网"><a href="#三-不同类型的局域网" class="headerlink" title="三.不同类型的局域网"></a>三.不同类型的局域网</h2><p>局域网有不同的拓扑</p><p><img src="/picture/image-20210607205650526.png"></p><h3 id="1-令牌环Token-Ring"><a href="#1-令牌环Token-Ring" class="headerlink" title="1.令牌环Token Ring"></a>1.令牌环Token Ring</h3><p>令牌环是一种局域网协议（IEEE802.5）</p><p>从IBM的商业的令牌环开始发展。因为IBM，令牌环获得了广泛的接受，但是从来没有达到以太网的流行程度</p><h4 id="环的操作"><a href="#环的操作" class="headerlink" title="环的操作"></a>环的操作</h4><p>每一个转发器（repeater）通过单向的传输链路连接另外两个，转发器扮演连接点的角色。</p><p><img src="/picture/image-20210607202641735.png"></p><p>数据一个比特一个比特地从一个转发器到另一个转发器传输。</p><ul><li>转发器重新生成和重传每一个比特</li><li>转发器执行数据插入，数据接收，数据删除的功能</li></ul><p>帧再进行一个循环的传递之后被发送器移除</p><h5 id="不同的状态"><a href="#不同的状态" class="headerlink" title="不同的状态"></a>不同的状态</h5><p><img src="/picture/image-20210607203827632.png"></p><h6 id="侦听状态"><a href="#侦听状态" class="headerlink" title="侦听状态"></a>侦听状态</h6><ul><li>扫描通过的比特流的模式：<ul><li>相连的站点的地址和目的站点的地址</li><li>令牌的传输权限</li></ul></li><li>复制输入位，发送给相连的站点<ul><li>如果目的地址匹配</li><li>再传发每一个比特</li></ul></li><li>当经过的的时候修改比特<ul><li>比如，表示数据包已经被复制（ACK）</li><li>或者做一个保留</li></ul></li></ul><h6 id="传输状态"><a href="#传输状态" class="headerlink" title="传输状态"></a>传输状态</h6><ul><li>回收帧，然后传回站点（为了ACK）</li><li>缓存别人的帧等候重传</li></ul><h6 id="路过的状态"><a href="#路过的状态" class="headerlink" title="路过的状态"></a>路过的状态</h6><ul><li>什么也不做</li></ul><h4 id="802-5MAC协议"><a href="#802-5MAC协议" class="headerlink" title="802.5MAC协议"></a>802.5MAC协议</h4><p>一个小的帧（令牌）在等候的时候循环，站点等待令牌</p><p>改变令牌的一个bit让它变成SOF（Start of Frame），然后再后面添加剩下的数据帧的内容</p><p>帧进行一个环形的旅行，然后被某一个传输站点吸收。然后站台当传输结束的时候插入新令牌</p><p>轻负载的时候有点效率底下，高度负载的时候，进行轮询</p><p><img src="/picture/image-20210607204827237.png"></p><h5 id="802-5的物理层"><a href="#802-5的物理层" class="headerlink" title="802.5的物理层"></a>802.5的物理层</h5><p><img src="/picture/image-20210607205538538.png"></p><h3 id="2-以太网Ethernet"><a href="#2-以太网Ethernet" class="headerlink" title="2.以太网Ethernet"></a>2.以太网Ethernet</h3><p>以太网是一种主导有线局域网的技术，有如下的好处：</p><ul><li>NIC网卡比较便宜</li><li>首先被广泛运用于局域网技术</li><li>比令牌局域网和ATM简单廉价</li><li>速度比较不错</li></ul><h4 id="以太网的物理拓扑"><a href="#以太网的物理拓扑" class="headerlink" title="以太网的物理拓扑"></a>以太网的物理拓扑</h4><h5 id="总线：在90年代中期很流行"><a href="#总线：在90年代中期很流行" class="headerlink" title="总线：在90年代中期很流行"></a>总线：在90年代中期很流行</h5><p>所有节点在同一个碰撞域中，可以互相碰撞</p><h5 id="星型拓扑：现在比较盛行"><a href="#星型拓扑：现在比较盛行" class="headerlink" title="星型拓扑：现在比较盛行"></a>星型拓扑：现在比较盛行</h5><p>每一个节点运行一个分离的以太网协议，不会相互碰撞（一般用交换机作为星型中心）</p><p><img src="/picture/image-20210607141806849.png"></p><p>下面说说他们的比较；广播vs交换以太网</p><p>总线拓扑是一种广播技术</p><ul><li>主机之间共享信道</li><li>每个包被所有相连的主机收到</li><li>通过CSMA/CD来进行媒体访问控制</li></ul><p>现代的以太网是交换以太网</p><ul><li>链路是交换机之间或者交换机和主机之间的</li><li>不需要共享信道-&gt;不用CSMA/CD</li><li>依靠自学习和生成树算法来路由！！</li></ul><h4 id="以太网的发展演变"><a href="#以太网的发展演变" class="headerlink" title="以太网的发展演变"></a>以太网的发展演变</h4><p>几乎除了帧的格式以外的所有东西都变了</p><ul><li>从共享媒介的线缆变成专用链路！</li></ul><ul><li>速度从3Mbps变成100Gbps！</li></ul><ul><li>从电子信号变成光信号！</li></ul><p>我们从中学到什么？正确的方法（比如以太网）可以经受得住很多改变，并且在保持方法的时候要更新技术！（后向兼容）</p><h4 id="以太网：不可靠，无连接"><a href="#以太网：不可靠，无连接" class="headerlink" title="以太网：不可靠，无连接"></a>以太网：不可靠，无连接</h4><p>无连接是说在收发的NIC之间没有握手的过程</p><p>不可靠是说接收者的NIC不给发送者的NIC发送确认消息，这样只有更上层的协议有可靠传输协议（TCP）才可以让丢掉的包得到恢复，否则抛弃的包就丢了！</p><h4 id="以太网帧的格式"><a href="#以太网帧的格式" class="headerlink" title="以太网帧的格式"></a>以太网帧的格式</h4><p>前导码Preamble：有七个字节，为了时钟同步，有一个字节指出帧的开始！</p><p>MAC地址Addresses：6字节，一共48bit</p><p>类型Type：2字节，填入上层协议，比如IP</p><p>数据负载Data payload：最大1500字节，最小46字节</p><p>CRC循环冗余码：4字节，一共32bit，进行错误检测</p><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>MAC地址是一个和网络适配器有关的数值地址</p><p>有48bit的名空间，比如16进制的00-15-C5-49-04-A9</p><p>当适配器生产时候就有一个独一无二的硬编码MAC地址</p><h6 id="MAC地址的分配"><a href="#MAC地址的分配" class="headerlink" title="MAC地址的分配"></a>MAC地址的分配</h6><p>分为不同的块，在MAC地址的前3个字节，被分配给不同的厂家，下面的3个字节由厂家来分配给每一个适配器</p><h5 id="成帧Framing-frames"><a href="#成帧Framing-frames" class="headerlink" title="成帧Framing frames"></a>成帧Framing frames</h5><p>物理层把bit放入链路，但是两个联通在相同物理媒介的主机需要交换帧，这个服务由链路层提供，由网络适配器来实现！</p><p>那么有一个问题：链路层如何判断每个帧的起止位置呢？</p><ol><li><p>简单的方法：比特计数，在帧的开始填入后面所跟的数据的大小，然后接受者根据这个值来解析！有一个缺点就是，如果这个计数的数值错了，将导致后面的帧全部错误！</p></li><li><p>哨兵位：用哨兵来标记帧的起止位置，<code>01111110</code>表示开始，<code>01111111</code>表示结束。但是有一个问题，如果在数据里面有哨兵怎么办？问题的解决办法是比特填充，如果在内容里面遇到5个1就在后面插入一个0，然后接收方每遇到5个1就拿掉后面的1个0！</p><p><img src="/picture/image-20210607145115984.png"></p></li></ol><p>举个例子，如果接收者看见了5个1：后面如果是0，那么就移走它继续解析；如果后面是1的话再看下一位，下一位是0，说明是帧的开始，否则是帧的结束！</p><h4 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h4><p><img src="/picture/image-20210607145201877.png"></p><h5 id="802-3的物理层"><a href="#802-3的物理层" class="headerlink" title="802.3的物理层"></a>802.3的物理层</h5><p>有许多不同的标准：</p><ul><li><p>类似的MAC协议和帧格式</p></li><li><p>不同的速率：2Mbps，10Mbps，100Mbps，1Gbps，10Gbps</p></li><li><p>不同的物理媒介：线缆，光纤</p><p><img src="/picture/image-20210607145639218.png"></p></li></ul><h2 id="四-媒体访问控制（MAC）"><a href="#四-媒体访问控制（MAC）" class="headerlink" title="四.媒体访问控制（MAC）"></a>四.媒体访问控制（MAC）</h2><p> 多路访问链路的性质：</p><ul><li>单一的共享广播信道</li><li>两个或以上的节点同时发送数据就会相互干扰</li><li>碰撞：节点同时接收两个或者更多信号</li></ul><h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><ul><li>决定节点如何共享信道的分布式算法，比如决定节点什么时候可以传输</li><li>关于信道共享的规划需要用到信道本身</li></ul><p>一个理想的多路访问协议是下面这样，给定一个广播信道的速率<code>R bps</code>，我们想要</p><ol><li>一个节点发送时，速率可以达到R</li><li>M个节点发送时，每个节点速率可达到R/ M</li><li>纯粹的分布式（去中心化）<ol><li>不需要特殊节点来协调传输</li><li>不需要同步时钟</li></ol></li><li>尽可能简单！</li></ol><h4 id="1-信道划分"><a href="#1-信道划分" class="headerlink" title="1.信道划分"></a>1.信道划分</h4><h5 id="1-1时分多路复用time-division-multiple-access"><a href="#1-1时分多路复用time-division-multiple-access" class="headerlink" title="1-1时分多路复用time division multiple access"></a>1-1时分多路复用time division multiple access</h5><p>把时间切分成等大的时间片，分为不同的轮次。每个站点得到固定大小的时间片（slot），如果轮到某个节点的时间片了，但是节点没有发送，那么这个时间片空闲！</p><p>可以达到的目标234</p><p>例如下面：6个站点，134要发包，256空闲</p><p><img src="/picture/TDMA.png"></p><h5 id="1-2频分多路复用frequence-division-muliple-access"><a href="#1-2频分多路复用frequence-division-muliple-access" class="headerlink" title="1-2频分多路复用frequence division muliple access"></a>1-2频分多路复用frequence division muliple access</h5><p>把信道划分为不同的频段，每个站点分配固定的频段，没有用到的频段空闲！FDMA和TDMA类似</p><h5 id="1-3码分多址复用（CDMA）"><a href="#1-3码分多址复用（CDMA）" class="headerlink" title="1-3码分多址复用（CDMA）"></a>1-3码分多址复用（CDMA）</h5><p>多用于无线广播网络，例如蜂窝网，卫星等等。</p><p>所有的节点共享相同的频率，但是每个节点有自己的chipping序号来编码数据</p><p>编码求原始数据 X chipping序号；解码求原始数据和chipping序号的内积</p><p>S1(D1XS1+D2XS2+D2XS3)/(|S1|^2)</p><p>需要code是正交的，多个节点可以以最小的干扰同时传输</p><p>CDMA计算比较复杂</p><p><img src="/picture/CDMA.png"></p><h4 id="2-轮流"><a href="#2-轮流" class="headerlink" title="2.轮流"></a>2.轮流</h4><h5 id="2-1轮询Polling"><a href="#2-1轮询Polling" class="headerlink" title="2-1轮询Polling"></a>2-1轮询Polling</h5><p>主节点邀请从节点轮流传输，傻瓜式从节点设备，比如蓝牙</p><p>问题：产生轮询开销，时延，master出问题所有都出问题，不是完全的分布式</p><p><img src="/picture/%E8%BD%AE%E8%AF%A2.png"></p><h5 id="2-2令牌传递"><a href="#2-2令牌传递" class="headerlink" title="2-2令牌传递"></a>2-2令牌传递</h5><p>控制令牌按照顺序从一个节点发送到下一个节点</p><p>问题：令牌的额外开销，时延，单个节点出错导致令牌丢失</p><h4 id="3-随机访问"><a href="#3-随机访问" class="headerlink" title="3.随机访问"></a>3.随机访问</h4><p>当节点有分组要发送的时候，以全速R进行发送，节点之间没有提前协调！如果多个节点同时传输就造成<strong>碰撞</strong></p><p>随机访问MAC协议指定如何检测和避免碰撞，如何从碰撞中恢复</p><p>随机访问多路媒体访问控制协议有：</p><ul><li>ALOHA，slotted ALOHA</li><li>CSMA，CSMA/CD，CSMA/CA</li></ul><h5 id="3-1ALOHA"><a href="#3-1ALOHA" class="headerlink" title="3-1ALOHA"></a>3-1ALOHA</h5><p>Additive Link On-line HAwaii system，被夏威夷大学设计</p><p>对于发送方：</p><ol><li>如果有帧要发就发</li><li>如果得到ACK就继续，否则以概率p重传，或者以1-p的概率等待</li><li>如果重复重传还没有ACK就放弃</li></ol><p>对于接收方：</p><ol><li>检查帧是否有问题</li><li>如果帧没问题，并且地址正确就发送ACK</li></ol><p>帧有可能被噪声和碰撞毁坏，有可能是另一个站点同时在发送，帧的任何一种重叠都会造成碰撞</p><p><img src="/picture/ALOHA.png"></p><h5 id="3-2时隙ALOHA"><a href="#3-2时隙ALOHA" class="headerlink" title="3-2时隙ALOHA"></a>3-2时隙ALOHA</h5><p>所有的帧大小相同，每一个时隙等于帧的传输时间。节点是同步的，需要一个中心时钟来同步时间。从一个时隙起点开始传输。帧要么不冲突，要么就完全冲突。</p><p>具体做法：节点如果有帧要传输，要在下一个时隙开始传输，如果没有碰撞节点下一个时隙就继续传输；如果有碰撞就每个时隙以p的概率重传</p><p><img src="/picture/slotALOHA.png"></p><h5 id="3-3CSMA载波侦听多路访问"><a href="#3-3CSMA载波侦听多路访问" class="headerlink" title="3-3CSMA载波侦听多路访问"></a>3-3CSMA载波侦听多路访问</h5><p>在传输之前先侦听，如果信道空闲就发送，否则停下来等待再发送。类比到人类就是在别人讲话时候不要打断别人。但是不可以消除所有碰撞，因为有传播时延！！！</p><p><img src="/picture/csma%E7%A2%B0%E6%92%9E.png"></p><h6 id="3-3-1-非持续CSMA"><a href="#3-3-1-非持续CSMA" class="headerlink" title="3-3-1 非持续CSMA"></a>3-3-1 非持续CSMA</h6><ol><li>站点要传输的时候就监听，如果空闲就传输，否则转到2</li><li>如果繁忙，等待一个随机的时间，转到1</li></ol><p>随机时间减小了碰撞的可能性，但是信道空间会被浪费，因为在传输完当前的包之后可能会等待</p><h6 id="3-3-2-1-坚持CSMA"><a href="#3-3-2-1-坚持CSMA" class="headerlink" title="3-3-2 1-坚持CSMA"></a>3-3-2 1-坚持CSMA</h6><p>为了避免等待信道时间造成的浪费，采用1坚持</p><ol><li>站点希望传输的时候监听，如果空闲就传输，否则转到2</li><li>如果繁忙就一直监听到空闲，空闲时立刻重传</li></ol><p>这是一种比较自私的做法，如果多个站点同时监听等待，肯定会造成碰撞</p><h6 id="3-3-3-p-坚持CSMA"><a href="#3-3-3-p-坚持CSMA" class="headerlink" title="3-3-3 p-坚持CSMA"></a>3-3-3 p-坚持CSMA</h6><p>一个折中的办法是p坚持CSMA，像非持续CSMA一样尽量减少碰撞，像1持续CSMA那样尽量减少等待时间</p><ol><li>如果监听信道空闲，以概率p的概率发送，以1-p的概率延迟一个时间单元（时间单元等于传播时延的最大值）</li><li>如果信道繁忙，监听知道空闲，然后转到1</li><li>延迟了一个时间单元之后，转到1</li></ol><p>那么p的值最好取多少呢？</p><p>我们p值的目标是避免在高负载的情况下的不稳定性</p><p>如果N个站点等候发送，理论上最好的值是1/N；如果是高负载的话，p是很小的，从而站点等候时间变长，造成很长时间的延迟！</p><h6 id="3-3-4比较！"><a href="#3-3-4比较！" class="headerlink" title="3-3-4比较！"></a>3-3-4比较！</h6><p>下面是不同类型CSMA的比较</p><p><img src="/picture/dCSMA.png"></p><h5 id="3-4-CSMA-CD-collision-detection"><a href="#3-4-CSMA-CD-collision-detection" class="headerlink" title="3-4 CSMA/CD(collision detection)"></a>3-4 CSMA/CD(collision detection)</h5><p>在使用CSMA的话，碰撞在传输期间仍然会发生，所以CSMA/CD碰撞传输一旦被检测到就会中断。具体做法如下：</p><ol><li>站点在传输的时候侦听，如果空闲就传输，否则转2</li><li>如果繁忙，持续侦听直到空闲。然后立刻传输</li><li>如果检测到碰撞，发送拥塞信号然后终止传输</li><li>在拥塞之后，等待一个随机的时间然后转到1</li></ol><p>下面是碰撞的发生</p><p><img src="/picture/CSMAcd.png"></p><h6 id="帧的最小长度"><a href="#帧的最小长度" class="headerlink" title="帧的最小长度"></a>帧的最小长度</h6><p>为了能够检测出碰撞，我们需要限制最小的帧的长度，否则有可能检测不到碰撞。</p><p>如下图，我们假设信道长度是L，传播的速度是V，带宽是B，帧的大小是size，那么从一端到另一端传播时延是<code>L/V</code>，如果在主机2即将传播到4的时候（t=L/V），4发送了帧，这样从主机4发送的帧到达主机2的时间t=2L/V，这样只有当传输时间大于2L/V时才可以检测到碰撞，也就是<code>size/B&gt;2L/V</code>！</p><p><img src="/picture/%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E.png"></p><h5 id="总结-随机访问的三个重要思想"><a href="#总结-随机访问的三个重要思想" class="headerlink" title="总结.随机访问的三个重要思想"></a>总结.随机访问的三个重要思想</h5><h6 id="载波侦听"><a href="#载波侦听" class="headerlink" title="载波侦听"></a>载波侦听</h6><ul><li>在讲话之前先侦听，不要打扰其他人讲话</li><li>检测是否已经有人在说话了</li><li>等到别人说完</li></ul><h6 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h6><ul><li>有别人同时说话就停下来，但是要确保所有人都知道碰撞了（最小帧长度的限制）</li><li>了解什么时候两个节点立刻传输</li><li>通过检测数据是否混乱来检测碰撞</li></ul><h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><ul><li>不要立刻重传</li><li>等一个随机时间再重传</li></ul><p>应该等待多久时间？</p><p>IEEE802.3使用1持续的CSMA，采用二进制指数退避的方式</p><ol><li>在前十次尝试发送中，每一次随机延迟的时间加倍，比如第一次重传从1 2里面选，第二次重传从1 2 3 4里面选….</li><li>超过十次重传的话，就保持第十次的最大时间不变，从中选择一个时间重传</li><li>超过16次重传说明信道过于繁忙，就会放弃，并且报告错误！</li></ol><p>1持续的二进制指数退避算法在很大范围的负载内表现得不错：低负载的时候保证了效率，高负载的时候保证了稳定性</p><h5 id="以太网CSMA-CD算法"><a href="#以太网CSMA-CD算法" class="headerlink" title="以太网CSMA/CD算法"></a>以太网CSMA/CD算法</h5><p>下面是以太网CSMA/CD算法的描述：</p><p><img src="/picture/ethernetcsmacd.png"></p><p>流程图</p><p><img src="/picture/cdmacdliuchengtu.png"></p><h3 id="多路访问协议的性能分析"><a href="#多路访问协议的性能分析" class="headerlink" title="多路访问协议的性能分析"></a>多路访问协议的性能分析</h3><h4 id="1-没有ACK的点到点链路"><a href="#1-没有ACK的点到点链路" class="headerlink" title="1.没有ACK的点到点链路"></a>1.没有ACK的点到点链路</h4><p>不管对于大型帧还是小型帧来说，利用率等于传输时间占总时间的比值。（<strong>总时间是指这个帧发出的时间到下一个帧发出的间隔时间</strong>）</p><p>假设传输时间为1，传播时间为a，那么总时间为<br>$$<br>U=1/(1+a)<br>$$</p><h4 id="2-令牌环"><a href="#2-令牌环" class="headerlink" title="2.令牌环"></a>2.令牌环</h4><p>对于大的令牌环来说，令牌从<code>t0</code>开始传输，然后在<code>t0+1</code>时候，帧的最后一个bit发送出去并且第一个比特回来，令牌开始传送，在<code>t=t0+1+a/n</code>到达下一个站点，这个时候下一个站点开始传输。</p><p>对于小的令牌环来说，令牌从<code>t0</code>开始传输，然后在<code>t0+a</code>从站点完全释放并且第一个比特回来，这时候令牌开始传给下一个站点，在<code>t=t0+a+a/N</code>时候令牌到达下一个站点</p><p>两种情况：</p><ol><li>case1：a&lt;1（当帧比环长）<br>$$<br>U=1/(1+a/N)<br>$$</li><li>case2：a&gt;1（帧比环短）<br>$$<br>U=1/(a+a/N)<br>$$</li><li></li></ol><h4 id="3-时隙ALOHA"><a href="#3-时隙ALOHA" class="headerlink" title="3.时隙ALOHA"></a>3.时隙ALOHA</h4><p>所有的帧有相同的大小，时间被同一分割，各个节点是同步的，传输在时隙的开始部分开始，帧要么全部碰撞要么就不碰撞。</p><p>假定N个节点有帧要发送，每一个在以p的概率在时隙发送，那么一个节点成功发送的概率是<code>p * (1-p)^(N-1)</code>，那么N个节点成功的概率是<code>A = N * p * (1-p)^(N-1)</code>。</p><p>如何找到成功概率，那么就是让<code>p=1/N</code>，<code>A=(1-1/N)^(N-1)</code>（利用函数求导）</p><p>如果能够被成功利用，信道的利用率<code>Us=1/(1+2α)</code></p><p>因为A是成功的概率，所以成功传送的利用率是<code>U=UsXA=(1-1/N)^(N-1)</code>，让N等于正无穷，U约等于<code>1/e</code></p><h4 id="4-纯ALOHA"><a href="#4-纯ALOHA" class="headerlink" title="4.纯ALOHA"></a>4.纯ALOHA</h4><p>更简单但是碰撞概率更高。当我t0发送一个帧的时候，我在<code>[t0-1,t0+1]</code></p><p><code>A=N*P(一个人在时隙传输)*P(没人在t0-1~t0传输)*P(没人在t0~t0+1传输)</code><br>$$<br>U=A=N<em>p</em>(1-p)^{2N-1}<br>$$<br>当<code>p=1/2N</code>并且N趋于无穷时，<code>U=1/(2e)</code></p><h4 id="5-CSMA-CD"><a href="#5-CSMA-CD" class="headerlink" title="5.CSMA/CD"></a>5.CSMA/CD</h4><p>暂时略</p><h3 id="MAC地址和它的发现"><a href="#MAC地址和它的发现" class="headerlink" title="MAC地址和它的发现"></a>MAC地址和它的发现</h3><p><img src="/picture/123.png"></p><p>一个主机A被制造时只有他自己的mac地址，那么我要联系主机B却不知道它的MAC地址，怎么办呢？</p><h4 id="1-链路层发现协议"><a href="#1-链路层发现协议" class="headerlink" title="1.链路层发现协议"></a>1.链路层发现协议</h4><p>ARP：Address Resolution Protocols</p><p>DHCP：Dynamic Host Configuration Protocol</p><p>被限制在单一局域网里，依靠广播能力</p><p>它们有两个功能：</p><ol><li>发现局域终端设备</li><li>辅助远程主机的交流</li></ol><h4 id="2-DHCP"><a href="#2-DHCP" class="headerlink" title="2.DHCP"></a>2.DHCP</h4><p>主机用DHCP来找到它自己的IP地址，网络掩码，DNS服务器的IP地址，默认的第一跳路由器的IP地址（默认网关）</p><h5 id="DHCP的标准过程"><a href="#DHCP的标准过程" class="headerlink" title="DHCP的标准过程"></a>DHCP的标准过程</h5><p><img src="/picture/dhcp.png"></p><h6 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h6><ol><li>客户在它所在的子网广播一个DHCP-Discover消息</li><li>每一个服务器都可能用一个DHCP-Offer消息回复</li><li>客户机选择一个服务器广播一个包含服务器IP地址的DHCP-Request消息</li><li>被选择的服务器确认绑定，用一个DHCP-ACK消息回复！</li><li>客户机根据DHCP-ACK设置它的配置参数</li></ol><h6 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h6><ol><li>客户机通过发送DHCP-RELEASE消息废除绑定</li><li>如果客户机不更新之前绑定的关系，绑定会过期</li></ol><p><img src="/picture/guocheng.png"></p><h5 id="当DHCP出现问题怎么办"><a href="#当DHCP出现问题怎么办" class="headerlink" title="当DHCP出现问题怎么办"></a>当DHCP出现问题怎么办</h5><p><img src="/picture/dhcphd.png"></p><h4 id="3-ARP"><a href="#3-ARP" class="headerlink" title="3.ARP"></a>3.ARP</h4><p>用户137.196.7.23想要ping 137.196.7.88</p><ul><li>源IP：137.196.7.23</li><li>目的IP：137.196.7.88</li><li>源MAC：71-65-F7-2B-08-53</li><li>目的MAC是多少呢？？？？？？？</li></ul><p>我们需要目的主机的MAC地址才可以传输数据，在局域网中，我们用ARP来获得MAC地址，需要给定目的主机IP地址！</p><p>ARP是一种IP到MAC地址的映射，只在局域网中起作用。对比DNS服务，DNS服务是域名到IP地址的映射！</p><h5 id="ARP的运行过程"><a href="#ARP的运行过程" class="headerlink" title="ARP的运行过程"></a>ARP的运行过程</h5><p>每一个主机都维护一个ARP表（IP地址到MAC地址的映射表），其中表项在一段时间之后会过期被删除</p><h6 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h6><ol><li>先查看本地的cache（ARP表）</li><li>如果没有发现目的IP对应的MAC地址的话，就构建一个ARP请求插入&lt;发送方IP，发送方MAC，目的IP&gt;</li><li>用MAC帧进行广播</li><li>收到ARP回复，进行缓存（加上时间戳）！</li></ol><h6 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h6><ol><li>检查ARP包的目的IP</li><li>如果目的IP是我的某个接口，构建一个ARP回复，插入&lt;目的IP，目的MAC&gt;</li><li>用MAC帧发送给发送</li><li>把发送方的&lt;IP,MAC&gt;存入cache</li></ol><p>但如果目的地址很远不在局域网之内怎么办？</p><p>我们要先用ARP查找第一跳路由器的MAC地址</p><p>那么主机如何知道我和目的没有在同一个局域网里？</p><p>通过子网掩码！</p><p>那么主机咋知道第一跳路由器在哪？</p><p>通过DHCP协议！！！（默认网关）</p><p>下面是ARP的一个具体例子</p><p><img src="/picture/arpex.png"></p><h4 id="4-ARP和DHCP的关键"><a href="#4-ARP和DHCP的关键" class="headerlink" title="4.ARP和DHCP的关键"></a>4.ARP和DHCP的关键</h4><p>广播：通过广播来交流</p><p>缓存：在一定时间内记住过去的记录，存储信息来减少一定查询开销</p><p>软状态：记录最终会被删除</p><table><thead><tr><th>层</th><th>例子</th><th>结构</th><th>配置</th><th>解决服务</th></tr></thead><tbody><tr><td>应用层</td><td>p.nju.edu.cn</td><td>组织层级</td><td>根据手册</td><td>DNS（应用层-网络层）</td></tr><tr><td>网络层</td><td>123.23.88.66</td><td>拓扑层级</td><td>DHCP</td><td></td></tr><tr><td>链路层</td><td>45-CD-AC-38</td><td>供应商</td><td>硬编码</td><td>ARP（网络层-链路层）</td></tr></tbody></table><h4 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h4><h5 id="发现机制"><a href="#发现机制" class="headerlink" title="发现机制"></a>发现机制</h5><p>广播（ARP，DHCP）</p><p>洪泛，没有非常关键的中心化节点，不需要手动配置</p><p>目录服务（DNS）</p><p>不洪泛，可扩充，根目录是容易受到攻击的，需要辅助程序配置</p><h2 id="五-桥和二层交换机"><a href="#五-桥和二层交换机" class="headerlink" title="五.桥和二层交换机"></a>五.桥和二层交换机</h2><h3 id="局域网的互联"><a href="#局域网的互联" class="headerlink" title="局域网的互联"></a>局域网的互联</h3><p>要具备拓展到单一局域网之外的能力，提供到其他局域网或者广域网的互联服务，所以用到了桥</p><p>桥<code>bridge</code>的作用：</p><ul><li>连接不同的局域网，通常超过两个</li><li>同样使用链路层和物理层协议</li><li>存储转发局域网的帧</li><li>精准的位复制帧</li><li>需要交换路由的功能</li></ul><p><img src="/picture/bridge.png"></p><p>桥需要的特性：</p><ul><li>存储和转发<ul><li>读取在局域网中传播的帧，检查帧的MAC地址，选择性地存储这些地址</li><li>利用第二局域网的MAC协议，重传每一个帧</li></ul></li><li>透明度<ul><li>站点不应该感受到桥的存在</li></ul></li><li>即插即用，自学习<ul><li>桥不需要配置</li></ul></li></ul><h3 id="桥协议体系架构"><a href="#桥协议体系架构" class="headerlink" title="桥协议体系架构"></a>桥协议体系架构</h3><p>IEEE802.1D</p><p><img src="/picture/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png"></p><p>桥的机制：帧广播，环的破除，地址学习</p><h3 id="广播以太网"><a href="#广播以太网" class="headerlink" title="广播以太网"></a>广播以太网</h3><p>发送方通过一个广播链路来广播帧。如果目的MAC地址和接受者的MAC地址匹配或者是广播MAC地址<code>FF:FF:FF:FF:FF:FF</code>的话，每一个接受者的链路层把帧递交给网络层</p><p>广播以太网即插即用，不需要人工配置，广播作为一种辅助交流的方式</p><h4 id="广播风暴问题"><a href="#广播风暴问题" class="headerlink" title="广播风暴问题"></a>广播风暴问题</h4><p>在有环的扩充局域网里面广播会造成不断广播，造成帧不断重复并且永生，那么究竟是什么造成这个问题呢？答案是：环</p><p><img src="/picture/huan.png"></p><p>Perlman提出了她的解决办法：在拓扑中破除环，最简单的方法就是构建一个最小生成树！</p><h4 id="生成树协议（Perlman’85）"><a href="#生成树协议（Perlman’85）" class="headerlink" title="生成树协议（Perlman’85）"></a>生成树协议（Perlman’85）</h4><p>这个协议判断这个扩充局域网里面如何构建一个生成树。它有很好的性质：不需要人工配置，一旦出现错误会自恢复。因为它很方便好用，至今仍被使用！</p><h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><p>以任意的网络拓扑作为输入，找到一个形成生成树的链路的子集</p><p>它有两个方面：</p><ul><li>先找到一个根，其他节点都到根有一个最短路径，找到一个id最小的节点作为根</li><li>计算到根的最短路径。最短路径不可能有环，节点之间只要保持到最短路径的链路即可。如果有多个最短路径我们就选择相邻接点ID最小的那一条路径</li></ul><p>那么具体如何构建一个生成树呢？</p><p>我们需要一个特殊的消息来辅助，这个消息包含一个三元组（Y,d,X），表明包是来自X，以Y为根，和Y的距离为d。</p><p>当收到包的时候，交换机选择最小ID的节点作为root</p><p>每一个节点决定它的链路是否在到根的最短路径上，如果不是就排除它</p><h5 id="具体算法执行过程"><a href="#具体算法执行过程" class="headerlink" title="具体算法执行过程"></a>具体算法执行过程</h5><ol><li><p>最开始，每一个节点声称它自己是节点</p><p>交换机X把（X,0,X）发送给邻居</p></li><li><p>节点更新他们的信息：根是谁，举例根多远</p><p>当收到（Y，d，Z）的时候，检查Y的id是否小于当前root的id，如果是的话就让root=Y</p></li><li><p>节点计算他们的到根的距离</p><p>一般来说+1</p></li><li><p>如果根或者根到节点的最短路径改变了，就把新的三元组消息发送给邻居</p></li></ol><p><img src="/picture/%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95.png"></p><h5 id="鲁棒的生成树算法"><a href="#鲁棒的生成树算法" class="headerlink" title="鲁棒的生成树算法"></a>鲁棒的生成树算法</h5><p>算法必须对于错误作出应对：根节点错误，桥和链路错误</p><p>根节点需要周期性地发送root announcement消息，其他的桥继续转发消息</p><p>这样我们就可以通过超时来检测错误！如果没有定期收到来自跟的消息，那么就超市，所以我就声称自己是根然后进行更新生成树！</p><h4 id="在生成树里面洪泛"><a href="#在生成树里面洪泛" class="headerlink" title="在生成树里面洪泛"></a>在生成树里面洪泛</h4><p>洪泛需要使用下面的规则：</p><ol><li>忽略所有不在生成树里面的接口</li><li>起源的桥发包给所有可以的端口</li><li>当数据包到达一个接收端口时，将它发送到除接收端口以外的所有端口</li></ol><p>洪泛是不是一种对资源的浪费呢？</p><p>是这样的，但我们可以让它辅助很多有效的转发！</p><p>我们收到“没有用“的包的时候，它不一定没有用，因为我们可以从它里面”学习“到一些东西。如果节点A看见了B的分组从某个端口进来了，A就知道可以通过这个端口到达B！！！因为在生成树中只有一条到达B的路径，所以这个很有效</p><h5 id="节点可以学习路由"><a href="#节点可以学习路由" class="headerlink" title="节点可以学习路由"></a>节点可以学习路由</h5><p>每一个桥维护了一个转发表数据库。转发表是可以不断更新的：当一个帧到达端口X，它一定来自和X端口相连的局域网。我们使用源地址来更新转发表，因为端口X所能到达的区域包含这个地址！！！</p><p>转发表的每个表项都有一个定时器，到时之后会自动删除对应表项！</p><p>每次当帧到达的时候，源地址都会在数据库里面检查一下是否有更新</p><h3 id="桥的转发功能总结"><a href="#桥的转发功能总结" class="headerlink" title="桥的转发功能总结"></a>桥的转发功能总结</h3><p>桥维护一个转发表，表项是一个三元组&lt;MAC地址，端口，时间戳&gt;</p><p>对于到达端口X的每一个帧，首先查找转发表，看看是否有目的MAC地址在转发表里的：</p><ul><li>如果没有，转发到除了X的所有端口</li><li>如果目的MAC地址对应端口就是X，就丢弃</li><li>如果目的MAC对应的端口是Y，检查Y是在阻塞态还是转发态，如果是转发态就转发到Y（不在生成树里的就是阻塞态）</li></ul><h3 id="互联不同局域网的设备类型"><a href="#互联不同局域网的设备类型" class="headerlink" title="互联不同局域网的设备类型"></a>互联不同局域网的设备类型</h3><ol><li>集线器（Hubs）：物理层的转发器</li><li>桥：连接局域网（转发和自学习）</li><li>二层交换机：连接主机和局域网（桥的功能加上无碰撞）</li><li>三层交换机（路由器）：还包含了路由功能</li></ol><h4 id="1-集线器"><a href="#1-集线器" class="headerlink" title="1.集线器"></a>1.集线器</h4><p>星型布局活跃的中心元素。</p><p>每一个站点通过两根线连接集线器，用来发送和接收</p><p>集线器是一种转发器，当站点传输的时候，集线器在输出的线路上面单纯重复转发给其它站点</p><p>物理拓扑是星型，但在逻辑上相当于总线。从一个站点接收的包会被其他所有站点接收，如果两个站点同时传输就会导致碰撞！</p><h5 id="共享媒体总线和集线器的区别"><a href="#共享媒体总线和集线器的区别" class="headerlink" title="共享媒体总线和集线器的区别"></a>共享媒体总线和集线器的区别</h5><p><img src="/picture/busvshub.png"></p><h4 id="2-二层交换机"><a href="#2-二层交换机" class="headerlink" title="2.二层交换机"></a>2.二层交换机</h4><p>需要什么样的性质？</p><ul><li>链路层设备：<ul><li>存储转发以太网帧</li><li>检查收到的帧的MAC地址，有选择性的转发到一个或者多个出链路，用CSMA/CD</li></ul></li><li>透明性，主机不知道交换机的存在</li><li>即插即用，自学习</li></ul><p>交换机vs桥</p><ul><li>桥连接不同局域网，有2-4个端口</li><li>交换机连接各种不同的主机和局域网，有很多端口，可以实现无碰撞传输</li></ul><p>为什么要用交换以太网呢？</p><p>站点是专用直接地连到交换机上</p><p>交换机缓存和转发帧</p><p>以太网协议在每个入链路上被使用，但没有碰撞，全双工</p><p>A-A’和B-B‘可以同时发送，但是没有碰撞！</p><p><img src="/picture/switch.png"></p><p>局域网容量加倍：每一个端口/链路形成一个局域网段（无碰撞），有多个站点同时传输</p><h5 id="集线器和二层交换机的区别"><a href="#集线器和二层交换机的区别" class="headerlink" title="集线器和二层交换机的区别"></a>集线器和二层交换机的区别</h5><p><img src="/picture/difhs.png"></p><p>二层交换机的好处：</p><ul><li>从总线或集线器局域网转变成交换机局域网很方便</li><li>站点相对于原始的局域网有相同的能力（假定交换机有足够的能力来跟得上所有站点）</li><li>二层交换机扩充规模很容易</li></ul><h4 id="3-三层交换机"><a href="#3-三层交换机" class="headerlink" title="3.三层交换机"></a>3.三层交换机</h4><p>当站点数目变多的时候，二层交换机显示出了缺点：</p><ul><li>广播有额外开销，比如要往100万个节点的局域网里广播就很麻烦</li><li>缺乏多条路径选择，因为生成树只有唯一路径，如果一条路断了可能影响很多节点</li></ul><p>三层交换机在硬件实现了路由器IP转发的逻辑，互联类似的局域网，就像二层交换机一样</p><h2 id="六-无线网络和移动网络"><a href="#六-无线网络和移动网络" class="headerlink" title="六.无线网络和移动网络"></a>六.无线网络和移动网络</h2><p>无线网络和移动网络在当今非常盛行，用户数量大大超过有线网络！但是面临着两种挑战：</p><ul><li>无线：在无线链路上面交流</li><li>移动：移动用户可能在不同的网络接入点接入，非无线网络也可能要处理移动的问题。基站也要提供接入有线网络的连接</li></ul><p><img src="/picture/wireless.png" alt="无线网络的基础设施"></p><ul><li>基站：用来接入有线网络；用来中继，负责在优先网络和无线主机中传包，例如蜂窝塔，802.11接入点</li><li>无线链路：用来讲移动设备连接到基站，也被用作主干链路，多路访问协议来协调链路访问，不同链路有不同的传播速率和传输距离</li></ul><p><img src="/picture/%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF.png" alt="各种无线链路标准"></p><h3 id="两种操作模式"><a href="#两种操作模式" class="headerlink" title="两种操作模式"></a>两种操作模式</h3><ul><li>基础设施模式：依靠基站把无线网络接入有线网络</li><li>自组织模式（Ad-hoc mode）：无线主机们自动组织成网络</li></ul><h4 id="基础设施模式"><a href="#基础设施模式" class="headerlink" title="基础设施模式"></a>基础设施模式</h4><p>基站把移动设备连接到有线网络，移动设备在不同的区域可能会改变基站</p><h4 id="自组织模式"><a href="#自组织模式" class="headerlink" title="自组织模式"></a>自组织模式</h4><p>不需要基站，节点只可以和链路范围覆盖的其他节点进行传输，节点把它们自己组织成网络</p><h3 id="无线网络分类"><a href="#无线网络分类" class="headerlink" title="无线网络分类"></a>无线网络分类</h3><p><img src="/picture/taxonomy.png" alt="无线网络分类"></p><h3 id="无线链路的特点"><a href="#无线链路的特点" class="headerlink" title="无线链路的特点"></a>无线链路的特点</h3><h4 id="1-信号强度衰减"><a href="#1-信号强度衰减" class="headerlink" title="1.信号强度衰减"></a>1.信号强度衰减</h4><p>由于反射，衍射，吸收地形，湿度等原因，路径上会有信号衰减</p><p><code>Free Space Path Loss叫FSPL</code><br>$$<br>FSPL=(4Πdf/c)^2<br>$$<br><code>d</code>是距离，<code>λ=c/f</code>是波长，<code>f</code>是频率，<code>c</code>是光速</p><h5 id="1-1-SNR和BER"><a href="#1-1-SNR和BER" class="headerlink" title="1-1 SNR和BER"></a>1-1 SNR和BER</h5><p>SNR是信噪比（signal-to-noise ratio），信噪比越大从中提出正确的信号越容易！</p><p>BER是误码率</p><p>给定一个物理链路，我们要提升链路的能力就要提升信噪比，减小误码率</p><p>在不同链路会有不同的信噪比和误码率，根据链路动态调整</p><p><img src="/picture/SNRBER.png"></p><h4 id="2-多路传播"><a href="#2-多路传播" class="headerlink" title="2.多路传播"></a>2.多路传播</h4><p>广播信号由于反射之类的干扰，在不同时间到达终点，导致主机无法判断是否是一个新的packet</p><p>多路效应：信号从一些表面进行反弹，干扰其他信号（自干扰）</p><h4 id="3-相互干扰"><a href="#3-相互干扰" class="headerlink" title="3.相互干扰"></a>3.相互干扰</h4><p>不同的设备共享频率，相互干扰</p><h3 id="IEEE-802-11无线局域网（WIFI）"><a href="#IEEE-802-11无线局域网（WIFI）" class="headerlink" title="IEEE 802.11无线局域网（WIFI）"></a>IEEE 802.11无线局域网（WIFI）</h3><p>single-cell配置和multi-cell配置</p><p><img src="/picture/single.png"></p><p><img src="/picture/multi.png"></p><h4 id="1-802-11架构"><a href="#1-802-11架构" class="headerlink" title="1.802.11架构"></a>1.802.11架构</h4><p>基站：符合MAC和物理层的设备</p><p>接入点（AP）：通过无线媒介提供分发式系统的接入服务</p><p>基础服务集（BSS）：被一个AP协调的cell</p><p>扩展服务集（ESS）：被分发式系统互联的多个BSS。分发式系统可能是一个交换机，一个有线网络，或者无线网络。一个ESS看起来就像一个单独的逻辑上的局域网，路由器提供到因特网的接入</p><p>分发式系统（DS）：一个被用来互联BSS集并且整合局域网以构成ESS的系统</p><p><img src="/picture/poss.png"></p><p>802.11b：2.4GHz-2.485GHz的频段被划分成不同频率的11个信道。AP的管理员选择AP的频段，但是如果邻居AP选择了和我相同的频段，我们可能出现相互干扰。</p><p>主机：必须和AP关联。扫描信道监听包含AP名字和MAC地址的信标帧，然后选择一个AP来关联或许还要身份验证（WIFI密码），连接之后通过DHCP来获得在AP子网下的IP地址</p><h5 id="1-关联的方式"><a href="#1-关联的方式" class="headerlink" title="1.关联的方式"></a>1.关联的方式</h5><p>有两种，分别是被动扫描和主动扫描</p><h6 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h6><ol><li>AP发送信标帧（Beacon frames）</li><li>主机发送关联请求帧（Associaion Request frame）给自己选择的AP</li><li>然后AP发送关联回复帧（Association Response frame）给刚才的主机</li></ol><h6 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h6><ol><li>主机广播探查请求帧（Probe Request frame）</li><li>AP收到后给予探查回复帧（Probe Response frame）</li><li>主机发送关联请求帧</li><li>AP发送关联回复帧</li></ol><p><img src="/picture/%E5%85%B3%E8%81%94.png"></p><h5 id="2-多路访问"><a href="#2-多路访问" class="headerlink" title="2.多路访问"></a>2.多路访问</h5><p>多个无线发送者和接受者可能会造成一些问题（不仅仅是多路访问控制的问题）</p><ul><li>隐藏终端问题</li></ul><p><img src="/picture/yczd.png"></p><ul><li>信号衰减问题</li></ul><p><img src="/picture/xhsj.png"></p><ul><li>暴露终端问题</li></ul><p><img src="/picture/blzd.png"></p><p>我们主要来讨论隐藏终端问题，解决方法：<strong>4帧交换</strong></p><ol><li>源（广播）发送一个发送请求帧（Request to Send,RTS）给目的</li><li>目的用CTS（Clear to Send）回复，发送给所有节点，告诉他们有人要发送帧了！</li><li>在收到CTS之后，源节点开始传送数据</li><li>目的节点用ACK回复，还是发送给所有节点，告诉他们上一个已经发送完了</li></ol><p><img src="/picture/rtscts.png"></p><h5 id="3-媒体访问控制"><a href="#3-媒体访问控制" class="headerlink" title="3.媒体访问控制"></a>3.媒体访问控制</h5><p><img src="/picture/mac.png"></p><h6 id="3种优先级"><a href="#3种优先级" class="headerlink" title="3种优先级"></a>3种优先级</h6><p>帧间距inter frame space</p><ul><li>SIFS(short inter frame space)最短帧间距</li><li>PIFS(point coordination function IFS)点协调控制</li><li>DIFS(distributed coordination function IFS)分布式协调控</li></ul><p>SIFS的使用</p><ul><li>站点在一个SIFS时间间隔后回复ACK</li><li>LLC</li><li>轮询回复</li><li>CTS</li></ul><p>PIFS和DIFS</p><p>PIFS被集中控制器使用，DIFS被使用于异步网络</p><p><img src="/picture/80211.png"></p><h6 id="PCF点协调控制"><a href="#PCF点协调控制" class="headerlink" title="PCF点协调控制"></a>PCF点协调控制</h6><p>通过中心化的轮询控制器来轮询</p><ul><li>使用分配轮询的时候用PIFS</li><li>当它发出轮询和接收响应时，它可以捕获媒介并锁定所有异步通信量</li></ul><p>无线网络由多个具有时效性的站点组成，由点协调器控制</p><ul><li>点协调器轮流轮询站点</li><li>当轮询发出时候，轮询的站点用SIFS回复轮询</li><li>如果点协调器收到回复，那么用PIFS发出另一个轮询</li><li>如果点协调器没有收到回复，它就发出另一个轮询</li><li>重复，直到当前一轮截止</li></ul><p>超级帧：一种时间间隔。在超级帧间隔的第一部分，点协调器对所有轮询站点进行轮询；在剩下的部分允许争夺异步访问。在超级帧的开头，点协调器创建一个避免争夺期，因为回复的站点发出对的帧的大小的变化来辩护这个时期持续的时间；在超级帧的后面，点协调控制器用PIFS来争夺访问，最后通过信标帧来标志下一个循环！</p><p>超级帧： 点协调器不断发布轮询，会封锁所有异步通信量。为了避免这种情况，在超帧时间的前一部分，由点协调器轮询，在超帧时间的后一部分，允许异步通 信量争用接入。</p><p><img src="/picture/%E8%B6%85%E7%BA%A7%E5%B8%A7.png"></p><h6 id="DCF分布式协调控制"><a href="#DCF分布式协调控制" class="headerlink" title="DCF分布式协调控制"></a>DCF分布式协调控制</h6><p>DCF使用CSMA/CA（拥塞避免），站点在传送前感知媒介，不会和正在传输的站点碰撞</p><p>DCF包含了时延，在传输之前等待一个帧间距</p><p><strong>为什么不需要碰撞检测？</strong></p><ol><li>当传输时候因为信号衰减很难收到别人发的信号！</li><li>传输站点不能区分噪声和弱信号！</li><li>不能感觉到所有碰撞，比如发生隐藏终端问题，信号衰减等待</li><li>ACK用起来很好！</li></ol><h6 id="802-11的MAC协议：CSMA-CA"><a href="#802-11的MAC协议：CSMA-CA" class="headerlink" title="802.11的MAC协议：CSMA/CA"></a>802.11的MAC协议：CSMA/CA</h6><p>发送方：</p><ol><li>如果感知到DIFS信道空闲就传输整个帧</li><li>如果信道繁忙，就开始随机时间回退，当信道空闲时候计时器倒计时，当时间到了就传输，如果没有ACK，就增加随机的回退间隔，重复2</li></ol><p>接收方：</p><ol><li>如果帧接收没问题，在SIFS之后返回一个ACK</li></ol><p><strong>碰撞避免</strong></p><p>允许发送方预约信道而不是信号针的随机接入，避免长数据帧的碰撞</p><p>发送方先用CSMA传送很小的RTS给基站</p><p>基站广播CTS来回应RTS</p><p>CTS被所有站点收到，发送方传输数据，其他站点推迟传输</p><p>这样就通过用一个预约分组来预约信道，完全避免了碰撞！</p><p><img src="/picture/%E9%A2%84%E7%BA%A6.png"></p><h5 id="4-802-11帧"><a href="#4-802-11帧" class="headerlink" title="4.802.11帧"></a>4.802.11帧</h5><p><img src="/picture/frame.png"></p><p>为什么要用地址3？</p><p><img src="/picture/why.png"></p><p>需要实现803.11帧到802.3帧的转换，首先传到AP之后，AP要传给路由器R1</p><h5 id="5-移动性：在同一个子网下移动"><a href="#5-移动性：在同一个子网下移动" class="headerlink" title="5.移动性：在同一个子网下移动"></a>5.移动性：在同一个子网下移动</h5><p>H1保持在同样的IP子网，IP地址可能保持不变</p><p>但如果H1从BBS1移动到BBS2的话怎么办？</p><p>依靠自学习，先看H1来自第一个端口，然后又来自第二个端口，就更新了转发表</p><h5 id="6-先进的能力"><a href="#6-先进的能力" class="headerlink" title="6.先进的能力"></a>6.先进的能力</h5><p>速率控制：基站，移动设备根据信噪比来动态调节比特率！</p><p>功率控制：节点会告诉AP，你给我下一个信标帧之前，我先睡一会！你给我信标帧我会被叫醒。</p><h3 id="蜂窝网络"><a href="#蜂窝网络" class="headerlink" title="蜂窝网络"></a>蜂窝网络</h3><p><img src="/picture/cell.png"></p><p>两种技术用来共享移动广播频谱：</p><ul><li>FDMA和TDMA的结合：用频率划分频谱，然后把每个信道划分为时间槽</li><li>利用CDMA</li></ul><h4 id="2G网络架构"><a href="#2G网络架构" class="headerlink" title="2G网络架构"></a>2G网络架构</h4><p><img src="/picture/2G.png"></p><h4 id="3G网络架构"><a href="#3G网络架构" class="headerlink" title="3G网络架构"></a>3G网络架构</h4><p><img src="/picture/3G.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
