<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DP-零钱兑换问题</title>
      <link href="/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="零钱兑换系列问题"><a href="#零钱兑换系列问题" class="headerlink" title="零钱兑换系列问题"></a>零钱兑换系列问题</h1><h2 id="1-零钱兑换1"><a href="#1-零钱兑换1" class="headerlink" title="1.零钱兑换1"></a>1.零钱兑换1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这道题目是力扣上面的题目，最近正好在学DP就做了个题解</p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>提示</p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><pre class="line-numbers language-none"><code class="language-none">输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们先从暴力方法入手，我们只需要<code>DFS</code>遍历所有可能的组合数量就可以从中找到一个最优解，但是这样暴力枚举的复杂度相当大，我们需要想一个更加优秀的算法。这种问题我们还是用递归更加恰当，试想我们想知道金额x最少需要多少，那么我只需要知道金额<code>x-coin_i(i&gt;=0 &amp;&amp; i&lt;size)</code>最少需要多少枚硬币，然后找到它们最小那个加一就行了，这样利用了动态规划的思想，站在前人的成果之上来解题，就方便了很多，所以我们只需要从1开始计算到amount分别最少需要多少钱就可以了</p><p>状态转移方程：<code>dp[i]=min(dp[i-coin_j]+1) (j&gt;=0 &amp;&amp; j&lt;coins.size)</code></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {        vector&lt;int&gt; dp(amount+1,INT_MAX-1);        dp[0]=0;        for(int i=1;i&lt;=amount;i++){            for(auto coin:coins){                if(i-coin&gt;=0){                    dp[i]=min(dp[i],dp[i-coin]+1);                }            }        }                return dp[amount]&lt;INT_MAX-1?dp[amount]:-1;    }};</code></pre><h2 id="2-零钱兑换2"><a href="#2-零钱兑换2" class="headerlink" title="2.零钱兑换2"></a>2.零钱兑换2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><pre class="line-numbers language-none"><code class="language-none">输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题跟</p><p>类似，但是他们要求解的东西不一样，那道题要求凑成总金额需要最少的硬币数，这道题要求有多少种可以凑成总金额的组合</p><p>对于某一个金额x，我们可以查看<code>x-coin_i</code>的组合数，加到一起即可，等等…我是不是忘了什么，这样很可能出现重复的组合，比如说<code>amount=5</code>，<code>coins=[1,2,5]</code>，那么1+2可以组合成3，那么3+2可以组合成5；2+2可以组合成4，那么4+1可以组合成5，所以<code>1+2+2=5</code>这个组合至少用了两次！！！所以这种做法需要被<code>pass</code>掉！！！</p><p>那么正确的做法应该是什么呢？我们可以在外层对硬币金额进行遍历，内层更新每一个金额。这样每层循环解释起来就是，我用前k种硬币，凑成每一种金额有多少组合。那么我进行每一次遍历的时候，我之前积累起来的是用前k种硬币有多少种，那么加上第k+1种硬币能够有多少种。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int change(int amount, vector&lt;int&gt;&amp; coins) {        vector&lt;int&gt; dp(amount+1,0);        dp[0]=1;        for(auto coin:coins){            for(int i=coin;i&lt;=amount;i++){                dp[i]+=dp[i-coin];            }        }        return dp[amount];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记网络层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-网络层的功能"><a href="#一-网络层的功能" class="headerlink" title="一.网络层的功能"></a>一.网络层的功能</h2><ol><li>从发送主机到接收主机传送报文段</li><li>在发送端把运输层报文段封装进网络层数据报</li><li>在接收方，把报文段递交给运输层</li><li>在每一个主机和路由器都有运输层协议</li><li>路由器检查IP数据报的header域，然后通过它传递</li></ol><p><img src="/picture/zzy.png"></p><p>两个关键的功能：</p><p>交换和路由：运用路由算法决定从源到目的发包的路由路线，找到从源到目的最短路线（路由决定转发表）</p><p>转发：从输入端口转发到特定的输出端口，进行错误处理排队和调度</p><p>连接建立：在数据报开始发送之前，终端主机和路由器之间建立虚拟连接（和运输层对比，网络层的连接建立是包括主机和路由器，而运输层是在两个主机进程之间！）</p><h2 id="二-网络服务模型"><a href="#二-网络服务模型" class="headerlink" title="二.网络服务模型"></a>二.网络服务模型</h2><p>信道的什么服务模型来从发送方到接收方传输数据报？</p><h3 id="例子：ATM的网络服务模型"><a href="#例子：ATM的网络服务模型" class="headerlink" title="例子：ATM的网络服务模型"></a>例子：ATM的网络服务模型</h3><p>恒定比特率（CBR）和可变比特率（VBR），有效比特率和未定义比特率</p><p><img src="/picture/atm.png"></p><h3 id="例子：IP的网络服务模型"><a href="#例子：IP的网络服务模型" class="headerlink" title="例子：IP的网络服务模型"></a>例子：IP的网络服务模型</h3><p>尽力而为</p><p><img src="/picture/ip.png"></p><h2 id="三-IP路由器"><a href="#三-IP路由器" class="headerlink" title="三.IP路由器"></a>三.IP路由器</h2><p>互联网基础设施的核心！</p><p>路由器的容量=NXR（其中N是外部路由端口的数量，R是每个端口的速率）</p><p><img src="/picture/isp.png"></p><h3 id="不同类型的路由器"><a href="#不同类型的路由器" class="headerlink" title="不同类型的路由器"></a>不同类型的路由器</h3><h4 id="1-核心路由器"><a href="#1-核心路由器" class="headerlink" title="1.核心路由器"></a>1.核心路由器</h4><p>R = 10/40/100/200/400 Gbps  NR = O(100) Tbps (总共)</p><h4 id="2-边缘路由器"><a href="#2-边缘路由器" class="headerlink" title="2.边缘路由器"></a>2.边缘路由器</h4><p>R = 1/10/40/100 Gbps NR = O(100) Gbps</p><h4 id="2-小型商用"><a href="#2-小型商用" class="headerlink" title="2.小型商用"></a>2.小型商用</h4><p>R = 1 Gbps  NR &lt; 10 Gbps</p><h3 id="路由器的内部：架构概览"><a href="#路由器的内部：架构概览" class="headerlink" title="路由器的内部：架构概览"></a>路由器的内部：架构概览</h3><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h4><p><img src="/picture/router%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88.png"></p><h4 id="2-输入端口"><a href="#2-输入端口" class="headerlink" title="2.输入端口"></a>2.输入端口</h4><p><img src="/picture/11.png"></p><p>输入端口的任务：</p><ul><li>收到包（物理层的任务）</li><li>更新IP头：TTL，checksum，可选字段，切片等</li><li>查找目的IP对应的合适的输出端口</li><li>排队：如果包到达太快就要缓存排队</li></ul><h5 id="查找合适的输出端口"><a href="#查找合适的输出端口" class="headerlink" title="查找合适的输出端口"></a>查找合适的输出端口</h5><p>如果一个表项对应一个地址就要有40亿个表项，为了可扩展性，地址是聚合的，目标地址按一定范围映射。<strong>按照最长前缀匹配规则</strong></p><p><img src="/picture/%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80.png"></p><p>由于一个个表项匹配复杂度有点高，我们可以利用树形结构</p><p><img src="/picture/tree.png"></p><h5 id="处理速度"><a href="#处理速度" class="headerlink" title="处理速度"></a>处理速度</h5><p>输入端口的任务要更新包头还有转发表查询，大多数被硬件处理！</p><h4 id="3-输出端口"><a href="#3-输出端口" class="headerlink" title="3.输出端口"></a>3.输出端口</h4><p><img src="/picture/outputport.png"></p><p>输出端口任务：</p><ul><li>包分类：把包映射到流里面</li><li>缓冲处理：决定什么时候和哪些包要扔掉</li><li>调度：决定哪些包什么时候传输（从排队的包里面选择进行传输，当buffer满了就要选择包丢弃）</li></ul><p>缓冲处理先进先出：最简单，没有分类，buffer满了的话就丢掉后来的包</p><p><img src="/picture/fifo.png"></p><p>包分类：根据header域来把IP包分类，比如源和目的的IP地址，源和目的的TCP端口号，服务类型，协议类型……</p><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>对于每一个流（“flow”）都有一个队列，调度器决定什么时候才能够哪个队列发包。调度器的目标是：快！</p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>在最高优先级的要在低优先级之前转发</p><h6 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h6><p>轮转：每个队列里的包被轮流调度</p><p>公平排队（FQ）：对于不同大小的队列进行轮转调度</p><p>加权公平队列（WFQ）：按照权重比例来调度</p><h4 id="4-交换结构"><a href="#4-交换结构" class="headerlink" title="4.交换结构"></a>4.交换结构</h4><p>交换结构用来连接输入端口和输出端口，从输入buffer传送到合适的输出buffer。</p><p>交换速率：包可以从输入端口到输出端口传送的速率</p><p>有三种结构来交换：</p><ul><li>通过共享内存交换</li><li>通过总线交换</li><li>通过物联的网络交换：比如横梁</li></ul><p><img src="/picture/3%E7%A7%8D.png" alt="三种交换结构"></p><h5 id="4-1-通过共享内存交换"><a href="#4-1-通过共享内存交换" class="headerlink" title="4-1 通过共享内存交换"></a>4-1 通过共享内存交换</h5><p>第一代路由器采用这种，它是一种直接在CPU控制下交换的传统的电脑，分组被拷贝到系统的内存里面。速度被内存的带宽限制</p><h5 id="4-2-通过总线交换"><a href="#4-2-通过总线交换" class="headerlink" title="4-2 通过总线交换"></a>4-2 通过总线交换</h5><p>数据报通过共享总线从输入端口内存传送到输出端口内存，速率被总线的带宽限制</p><h5 id="4-3-通过网状结构交换"><a href="#4-3-通过网状结构交换" class="headerlink" title="4-3 通过网状结构交换"></a>4-3 通过网状结构交换</h5><p>克服了总线带宽的限制</p><h2 id="四-虚电路和数据报网络"><a href="#四-虚电路和数据报网络" class="headerlink" title="四.虚电路和数据报网络"></a>四.虚电路和数据报网络</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>为了传输数据会预留端到端的资源（比如带宽和交换能力）</p><p>专用的资源，没有共享</p><p>对性能有保证</p><p>连接需要建立和撤销</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>每个端到端的数据流被划分为分组</p><p>应用A，B的分组共享网络资源</p><p>存储和转发：分组一次移动一跳，并且在交换机里需要排队</p><p>资源争夺：总共的资源需要量可以超过可获得的资源总量总量</p><p>拥塞：分组排队和等待链路</p><h4 id="分组交换的两种类型"><a href="#分组交换的两种类型" class="headerlink" title="分组交换的两种类型"></a>分组交换的两种类型</h4><p>虚电路网络：对信息流提供网络服务，VC网络提供基于服务的网络连接，比如ATM，X.25，Frame Relay</p><p>数据报网络：对单个的分组提供网络服务，数据报网络提供网络层无连接服务，例如IP网络</p><p><img src="/picture/%E8%99%9A%E7%94%B5%E8%B7%AF%E8%B7%AF%E7%94%B1.png" alt="虚电路路由"></p><p><img src="/picture/%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%B7%AF%E7%94%B1.png" alt="数据报路由"></p><h5 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h5><ul><li>对于每个信息流要进行连接建立和拆除</li><li>每个分组带着VC号</li><li>在源到目的路径上的每个交换机维护每个传输连接的状态</li><li>连接，交换资源（带宽，缓存）或许被分配给虚电路</li></ul><h6 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h6><p>这个是虚电路网络的必要功能，两个主机和中间交换机预留一条路径给虚连接，路由没用来找到一条合适的路径</p><h6 id="虚电路的实现"><a href="#虚电路的实现" class="headerlink" title="虚电路的实现"></a>虚电路的实现</h6><p>一个虚电路包括一条从源到目的的路径，还包括VC号（每个链路一个），交换机里面转发表的表项。</p><p>注意：属于VC的分组携带VC号（而不是地址！！！），VC号可能在每条链路上被改变，转发表列出了新的VC号</p><p>VC的转发表如下：</p><p><img src="/picture/vc%E8%BD%AC%E5%8F%91%E8%A1%A8.png" alt="vc转发表"></p><h6 id="信令协议"><a href="#信令协议" class="headerlink" title="信令协议"></a>信令协议</h6><p>被用来建立，维护，拆除虚电路</p><p>被用在ATM，frame-relay，X.25</p><p>现在已经不用了</p><p><img src="/picture/%E4%BF%A1%E4%BB%A4%E5%8D%8F%E8%AE%AE.png" alt="信令协议"></p><h5 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h5><p>在网络层不需要连接建立，没有网络层的“连接”概念</p><p>交换：没有端对端的链接的状态</p><p>用目的主机地址来进行分组转发</p><p>在同一组源和目的之间或许会有不同的路径</p><p><img src="/picture/sjbwl.png" alt="数据报网络发包"></p><p>数据报网络的转发表：</p><p><img src="/picture/datagram.png" alt="数据报网络转发表"></p><h5 id="数据报网络和虚电路的对比"><a href="#数据报网络和虚电路的对比" class="headerlink" title="数据报网络和虚电路的对比"></a>数据报网络和虚电路的对比</h5><p>数据报：</p><ul><li>在计算机间交换数据，有弹性，没有严格的计时</li><li>聪明的端系统：可以适应，控制，错误恢复，网络内部简单，边缘复杂</li><li>不同的链路类型：不同的特点，统一的服务是很困难的</li></ul><p>虚电路：</p><ul><li>从电话演变而来</li><li>人类的交流，有严格的时限，需要可靠性，需要服务保障</li><li>沉默的端系统：电话，网络内部复杂</li><li>链路类型统一化</li></ul><h2 id="五-IP协议"><a href="#五-IP协议" class="headerlink" title="五.IP协议"></a>五.IP协议</h2><p><code>IP=Internet Protocol</code>，最著名的因特网协议，它被<code>ARPANET</code>开发</p><p>IP层的内容位于各个主机和路由器上，提供无连接服务</p><p>网络层的概览：</p><p><img src="/picture/ipwlc.png" alt="网络层"></p><h3 id="因特网寻址"><a href="#因特网寻址" class="headerlink" title="因特网寻址"></a>因特网寻址</h3><h5 id="寻址等级"><a href="#寻址等级" class="headerlink" title="寻址等级"></a>寻址等级</h5><p>物理因特网地址：用于PDU（目的MAC地址）在单个物理网络中的路由</p><p>因特网地址：IP地址或者因特网地址，用于在网络中路由PDU。对于每个端系统或者介质系统都有唯一的地址</p><p>应用层地址：在目的主机分配的进程ID，比如TCP/IP端口</p><h5 id="寻址作用域"><a href="#寻址作用域" class="headerlink" title="寻址作用域"></a>寻址作用域</h5><p>全局地址</p><p>网络连接地址</p><p>端口地址：在网络层之上并且在一个系统独一无二，例如端口80-TCP/IP的网络服务器监听端口</p><h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>个人或者单播寻址</p><p>广播地址</p><p>多播地址</p><p>任播地址</p><p><img src="/picture/al.png" alt="地址层级"></p><h3 id="IP的操作"><a href="#IP的操作" class="headerlink" title="IP的操作"></a>IP的操作</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li><p>主机和路由器维护路由表，指出数据报应被发送到的下一个路由器，静态-可能包含可替代的路径，动态-对拥塞和错误灵活的回复</p></li><li><p>路由策略：距离向量，链路状态，路径向量</p></li></ul><h4 id="数据报的生存期"><a href="#数据报的生存期" class="headerlink" title="数据报的生存期"></a>数据报的生存期</h4><p>数据报可能无限期地在两个路由器间循环</p><p>我们给数据报一个生存时间可以解决这个问题：在IP头里面放了一个TTL域（Time to live）</p><h3 id="IP结构"><a href="#IP结构" class="headerlink" title="IP结构"></a>IP结构</h3><p>IP分组包括头和负载：</p><ul><li>负载对于网络层是不透明的</li><li>头是我们需要关注的</li><li>IP层第一个端到端的层级（从下往上看）</li></ul><p>IP头是如何设计出来的呢？</p><p>我们思考一下IP头是一种在源和目的，源和中间路由器间传递网络信息的接口，那么我们设计它的话需要考虑他有多少使命要完成，很多东西既然存在必然会尤其需要的地方：需要它-&gt;被设计出来。</p><p>IP的功能：</p><ul><li>解析包</li><li>能把包送到目的</li><li>处理路上的一些问题：循环（bugs），错误，包过大</li><li>可以根据情况调节革新</li><li>处理特殊情况</li></ul><h4 id="1-解析包"><a href="#1-解析包" class="headerlink" title="1.解析包"></a>1.解析包</h4><p>首先，想要解析包，就要根据固定的格式，不同的版本格式可能不同，所以我们需要<code>IP version number（4bit）</code>，包的长度（16bit，用来查看是否有optional域，如果没有就是20byte）</p><p><code>Header length</code>表明头里面有多少个4字节，一般是5（20bype），如果有<code>Options</code>域的话可能就更多</p><h4 id="2-把包送到目的"><a href="#2-把包送到目的" class="headerlink" title="2.把包送到目的"></a>2.把包送到目的</h4><p>需要目的IP地址，32bit</p><p>我们插入一个小插曲，辨析一下MAC地址和IP地址的区别</p><table><thead><tr><th>MAC地址</th><th>IP地址</th></tr></thead><tbody><tr><td>在适配器生产时被硬编码</td><td>后期被配置的，可以被动态学习到</td></tr><tr><td>扁平的48bit的名空间</td><td>层级式的32bit名空间</td></tr><tr><td>类似身份证号</td><td>类似邮政地址</td></tr><tr><td>可携带的，不管主机移动到哪都不变</td><td>不可携带，取决于主机在哪个地方</td></tr><tr><td>被用来在同一个网络下传送包</td><td>用来给目的IP子网传送包</td></tr></tbody></table><h4 id="3-处理路径上的问题"><a href="#3-处理路径上的问题" class="headerlink" title="3.处理路径上的问题"></a>3.处理路径上的问题</h4><p>循环：为了破除循环，设计了<code>TTL(Time to Live)</code>，8bit</p><p>错误：检验和<code>checksum(16bit)</code></p><p>包太大：分段域，一共32bit，里面还有更细致的划分</p><h5 id="3-1TTL"><a href="#3-1TTL" class="headerlink" title="3-1TTL"></a>3-1TTL</h5><p>因为一些<code>bugs</code>造成包在网络中循环，这样积累起来会慢慢消耗掉网络的所有容量，所以我们设计了TTL域，开始的时候设置一个值，在每一跳都减一，当减为0的时候就丢弃这个包并且给源地址发送”Time exceeded”超时错误包</p><h5 id="3-2错误"><a href="#3-2错误" class="headerlink" title="3-2错误"></a>3-2错误</h5><p>需要检验和，在包头有一个特定的格式，如果检查出错误就丢包。</p><p>有一个问题，就是为什么在每一个路由器都要重新计算检验和呢？是因为<code>TTL</code>的改变或者包的切片会导致<code>checksum</code>发生变化！</p><h5 id="3-3分片"><a href="#3-3分片" class="headerlink" title="3-3分片"></a>3-3分片</h5><p>每一个链路都有最大传输单元（<code>MTU</code>），就是它所能承载的最大比特数量</p><p>如果包的大小超出了链路的MTU，一个路由器可以把包分成多个片。我们在目的主机必须重组恢复成最原始的包。</p><p>下面我们举一个例子：</p><p>一个<code>4000byte</code>大小的包要穿越一个<code>MTU</code>是<code>1500byte</code>的链路</p><p>那么可以切成下面这样的3片</p><p><img src="/picture/qp1.png" alt="切片"></p><p>有一个问题，切片之后为什么还要重组？下面的图片给了解答</p><p>因为上层协议的包头都在一个包的前面，后面都是数据的部分，所以我们要重组以便能够完整地交付给上层</p><p><img src="/picture/whyre.png" alt="why重组"></p><p>那么又有问题来了，我们在哪里重组？目的主机？还是路由器？</p><p>这个是端到端原理的典型案例</p><p>在如果由路由器重组就给网络带来了负担，因为重组算法比较复杂，要维护各种状态；而且切片不一定走同一条路径，所以可能很多路由器得到的切片是一些碎片。所以在中间路由器重组是事倍功半的，所以在目的主机重组</p><p>那么我们重组需要那些信息来填充字段呢？</p><p>我们需要来找到切片属于哪个分组，所以分组的ID被需要；我们还要知道每个切片是分组的哪部分，所以需要偏移量字段；<code>Flag</code>字段：</p><ul><li><code>Reserved</code>：目前被忽略</li><li>DF：不要被切片，可能会触发错误包发回发送者</li><li>MF：置1，表示这个不是末尾的切片</li></ul><p>下面我们来举个分片的例子</p><p><img src="/picture/%E5%88%86%E7%89%871.png"></p><p><img src="/picture/%E5%88%86%E7%89%872.png"></p><p><img src="/picture/%E5%88%86%E7%89%873.png"></p><p><img src="/picture/%E5%88%86%E7%89%874.png"></p><p><img src="/picture/%E5%88%86%E7%89%875.png"></p><h4 id="4-支持更新"><a href="#4-支持更新" class="headerlink" title="4.支持更新"></a>4.支持更新</h4><p>通过版本号<code>version number(4 bit)</code>，或许还可以算上”特殊处理域“</p><h4 id="5-支持一些特殊处理"><a href="#5-支持一些特殊处理" class="headerlink" title="5.支持一些特殊处理"></a>5.支持一些特殊处理</h4><h5 id="5-1特殊处理域"><a href="#5-1特殊处理域" class="headerlink" title="5-1特殊处理域"></a>5-1特殊处理域</h5><p><code>Type of Service</code>服务类型域</p><p>允许包被按需对待，比如不同的优先级，不同的拥塞提醒之类的（比如说一些实时语音通话比较注重时延，一些文件比较注重准确率）。在不同的运营商（自治域）可能要被重新定义</p><h5 id="5-2Options"><a href="#5-2Options" class="headerlink" title="5-2Options"></a>5-2Options</h5><p>它是可变长度，解析时候通过<code>packet len</code>字段来判断是否有<code>Options</code></p><h4 id="6-其他一些字段"><a href="#6-其他一些字段" class="headerlink" title="6.其他一些字段"></a>6.其他一些字段</h4><h5 id="源地址"><a href="#源地址" class="headerlink" title="源地址"></a>源地址</h5><p>我们需要告诉目的端系统是谁发来的包，所以需要<code>Source Address</code>字段</p><h5 id="协议Protocol"><a href="#协议Protocol" class="headerlink" title="协议Protocol"></a>协议Protocol</h5><p>告诉我们上层协议是什么，对于接收主机端的多路分解很重要，告诉主机要交付给哪个上层协议</p><p><img src="/picture/protocol.png" alt="协议栈"></p><h3 id="IPv4头"><a href="#IPv4头" class="headerlink" title="IPv4头"></a>IPv4头</h3><p><img src="/picture/ipv4.png" alt="IPv4"></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4地址枯竭迫使它的出现，专注于简化IP协议，抛弃一些不必要的字段，形成了一种优雅，无二义性的协议</p><p><img src="/picture/%E5%AF%B9%E6%AF%94.png" alt="IPv4和IPv6的对比"></p><p>总结一下这些变化：</p><ol><li>切片被清除</li><li>校验和被清除</li><li>options字段被清除</li><li>头的长度字段被清除</li><li>扩展了地址大小</li><li>添加了流标签</li></ol><h4 id="IPv6头"><a href="#IPv6头" class="headerlink" title="IPv6头"></a>IPv6头</h4><p><img src="/picture/ipv6.png" alt="IPv6头"></p><h5 id="Traffic-Class字段"><a href="#Traffic-Class字段" class="headerlink" title="Traffic Class字段"></a>Traffic Class字段</h5><h5 id="Flow-Label字段"><a href="#Flow-Label字段" class="headerlink" title="Flow Label字段"></a>Flow Label字段</h5><p>什么是流？</p><p>它是一个从特定源到特定目的的分组的序列</p><p>从主机的视角来看，由一个应用生成并且有同样的传输服务要求，或许包含一个单独的或者多个TCP连接。一个应用可能生成一个或者多个流</p><p>从路由器的视角看，这个是影响这些包如何被路由器处理的共享属性</p><p>流是独一无二的标识，被源和目的地址标识和非零的流标签所定义。流需求被定义优先于流的发端。路由器通过简单的在一个表中查询流标签来决定如何路由和处理分组。</p><h5 id="IPv6头的结构（包含拓展的header）"><a href="#IPv6头的结构（包含拓展的header）" class="headerlink" title="IPv6头的结构（包含拓展的header）"></a>IPv6头的结构（包含拓展的header）</h5><p><img src="/picture/ipv6s.png"></p><p>可选的部分在拓展headers里面，在主header后面呈菊花链状</p><p><img src="/picture/header.png"></p><p>这些header是按序出现的</p><p>路由器在ipv6里面不切片，因为要在核心里面更有效率的处理，切片已经在主机里面做好了。如果包在下一跳发现太大了，那么就发送包太大error消息（ICMPv6消息）</p><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>iPv6没有广播，有一个“全部节点”多播群组：ff02::1</p><p>广播的缺点，它唤醒了全部节点，实际上只有很少的设备被需要，可能造成广播风暴</p><h5 id="邻居节点探索"><a href="#邻居节点探索" class="headerlink" title="邻居节点探索"></a>邻居节点探索</h5><p>IPv6没有ARP，取而代之的是<code>Neighbor Discovery</code>，使用<code>ICMPv6</code>和多播</p><p><code>Neighbor Discovery</code>被节点使用为了获取地址，发现邻居路由器，跟踪地址变化，检查邻居可达性，做地址复制检测</p><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>128bit，单个接口或许有多个单播地址，有三种类型地址：单播，多播，任播</p><h4 id="从IPv4迁移到IPv6"><a href="#从IPv4迁移到IPv6" class="headerlink" title="从IPv4迁移到IPv6"></a>从IPv4迁移到IPv6</h4><p>所有节点不可以同时更新，所以需要有一种机制让IPv4和IPv6同时工作。</p><p>两种可能：</p><ul><li>双栈技术</li><li>隧道：在IPv4路由器中，在IPv4数据报中的IPv6头被当做数据负载</li></ul><h2 id="六-IP地址"><a href="#六-IP地址" class="headerlink" title="六.IP地址"></a>六.IP地址</h2><p>IP地址是32位的全局地址，分为网络部分（高位）和主机部分（低位）</p><p>对于主机和路由器的每个物理接口都需要一个通向一个网络的分离的地址。</p><p>使用十进制点的记法</p><p>网络部分ID被如下的三个机构管辖：</p><ul><li>American Registry for Internet Numbers (ARIN)</li><li>Reseaux IP Europeens (RIPE）</li><li>Asia Pacific Network Information Centre (APNIC)</li></ul><p>主机部分ID被指定的组织来分配</p><h3 id="IPv4地址格式"><a href="#IPv4地址格式" class="headerlink" title="IPv4地址格式"></a>IPv4地址格式</h3><p>分为A类地址，B类地址，C类地址……</p><p><img src="/picture/ipv4dizhi.png" alt="IPv4地址"></p><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p><img src="/picture/A.png" alt="A类地址"></p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p><img src="/picture/B.png" alt="B类地址"></p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p><img src="/picture/C.png" alt="C类地址"></p><h3 id="子网和子网掩码"><a href="#子网和子网掩码" class="headerlink" title="子网和子网掩码"></a>子网和子网掩码</h3><p>处理网络地址不足，地址的主机部分分为子网号和主机号。子网掩码指出哪些比特是子网号，哪些是主机号，每个局域网被分配一个子网号，本地路由器在子网里面路由</p><p>子网对于因特网的其余部分看起来像一个单独的网络，把全部的网络从网络号和路由的复杂中隔离出来</p><p><img src="/picture/subtorest.png"></p><p><img src="/picture/route.png"></p><h3 id="CIDR记法"><a href="#CIDR记法" class="headerlink" title="CIDR记法"></a>CIDR记法</h3><p>无类域间路由，一个IP地址以“A.B.C.D/n”的形式被呈现，n叫做IP前缀</p><p><img src="/picture/CIDR.png"></p><h2 id="七-网络层协议簇"><a href="#七-网络层协议簇" class="headerlink" title="七.网络层协议簇"></a>七.网络层协议簇</h2><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h3><p>对内部和外部流量启用不同的IP地址</p><p>网络地址转换发生在带有更广阔的因特网的内联网接口</p><p>目的：</p><ul><li>作为一个防火墙隐藏内部IP地址</li><li>允许一个组织使用更多的内部IP地址</li><li>隔离组织的变化</li></ul><p>下面有3种NAT：</p><ul><li>静态NAT：一个私有的IP地址映射到一个预留的共有IP地址，用于网络服务器</li><li>动态NAT：NAT路由器保持一个已注册IP地址池，在需要的时候分配给私有IP地址，通常用于客户内部网PC</li><li>单地址：NAT/Overloading/Masquerading/Network Address  Port Translation (NAPT）</li></ul><p>图解NAT：</p><p><img src="/picture/NAT.png"></p><p><img src="/picture/overload.png"></p><p><img src="/picture/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="网络地址转换"></p><p>NAT是很有争议的，地址不时会发生变化，必须被P2P应用纳入考虑</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><code>Internet Control Message Protocol</code></p><p>用来在主机和路由器间传播错误和控制消息</p><ul><li>Echo请求和Echo回复被用来诊断网络</li><li>还会传达关于问题的反馈，比如超时，不可达主机……</li></ul><p>被封装在IP数据报里面</p><ul><li><code>Protocol type=1</code></li><li>不可靠</li></ul><p><img src="/picture/ICMP.png" alt="ICMP信息格式"></p><p><img src="/picture/ICMP1.png" alt="ICMP类型"></p><p><img src="/picture/ICMP2.png" alt="ICMP不同类型格式"></p><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>测试目的地址是否可达，源发送一个<code>echo request</code>给遥远的主机或者路由器。如果远程系统收到了<code>ICMP</code>包，他会给源回复一个<code>echo reply</code>。</p><p>ping的实用程序可以做得更好，比如计算从发送到接收时间，计算到目的有多少跳</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>用来测量到目的地址需要多少跳</p><ol><li>源发送TTL等于1的第一个IP（UDP）包，第一个路由器把TTL减为0，然后发送TTL超时错误给源。源计算RTT，然后重复三次</li><li>源发送第二个IP包（TTL设置为2），第二个路由器发回TTL超时错误，源计算RTT，然后重复三次</li><li>源继续增加TTL知道到达目的</li></ol><p>Path MTU</p><p>用来找到路径上的最小MTU</p><ol><li>源发送不带有切片位的大IP包</li><li>如果包太大，相关路由器会发送错误包</li><li>源相应减小包的大小，再次尝试</li><li>重复直到包到达目的（没有收到错误包）</li></ol><h2 id="八-移动IP"><a href="#八-移动IP" class="headerlink" title="八.移动IP"></a>八.移动IP</h2><p>移动IP标准在1996年被IESG批准，同年被IETF作为一种被提议的标准发布。它被发明出来是为了应对日益增长的PDA和Laptop的使用需求。</p><p>数据报从一个网络移动到另一个网络需要用到目的的IP地址，IP地址被划分为两部分<code>&lt;netID,hostID&gt;</code>，大多数网络应用支持<code>TCP</code>连接，<code>TCP</code>使用IP地址和端口号来路由和交付。当移动设备从一个网络移动到另一个的时候，它的IP地址动态改变，因此TCP连接在每次移动的时候需要重启正在进行的会话。移动IP正在解决动态变化的IP地址的问题，就不必重启TCP，就好像移动设备的IP地址假装没改变</p><p><img src="/picture/mip.png"></p><h3 id="不同的实体"><a href="#不同的实体" class="headerlink" title="不同的实体"></a>不同的实体</h3><p>移动节点：一个或许会改变它的接入点或者从一个网络到另一个网络连接的主机</p><p>通信节点：一个要给移动节点发包的主机</p><p>归属代理：一个在归属网络上维护一个已注册移动节点列表的节点</p><p>外部代理：一个在外部网络上帮助移动节点发送数据报的路由器</p><h3 id="三角路由"><a href="#三角路由" class="headerlink" title="三角路由"></a>三角路由</h3><p><img src="/picture/%E4%B8%89%E8%A7%92%E8%B7%AF%E7%94%B1.png"></p><h3 id="协议的细节"><a href="#协议的细节" class="headerlink" title="协议的细节"></a>协议的细节</h3><p>移动路由有三种能力：发现，注册，隧道技术</p><h4 id="1-发现"><a href="#1-发现" class="headerlink" title="1.发现"></a>1.发现</h4><p>移动（外部）代理：周期性发送带有移动代理广告扩展的ICMP路由广告来表明它的存在</p><p>移动节点：可以向代理请求广告或者简单地等待下一个广告</p><h4 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h4><p>移动节点：需要来自外部代理的转交地址。请求它的归属代理来转发数据包到外部代理。</p><p>四步：</p><ol><li>移动节点发送<code>registration request</code>给外部代理</li><li>外部代理转发这个请求给归属代理</li><li>归属代理发送<code>registration reply</code>给外部代理</li><li>外部代理转发这个<code>reply</code>给移动节点</li></ol><p><img src="/picture/registration.png"></p><p>下面是一个注册的例子</p><p><img src="/picture/%E4%BE%8B%E5%AD%90.png"></p><h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h4><p>在注册之后，一个IP隧道建立起来了，在归属代理和移动节点的COA之间建立。归属节点广播把移动节点IP地址绑定到归属代理MAC地址的ARP请求。因此，归属代理收到了发送给移动节点的包，会通过IP隧道转发给外部代理</p><p><img src="/picture/111.png"></p><h2 id="九-路由算法"><a href="#九-路由算法" class="headerlink" title="九.路由算法"></a>九.路由算法</h2><p>路由分为中心化的路由和分布式路由</p><p>中心化：固定的并且需要配置</p><p>分布式：通过洪泛，随机的，自适应的</p><p><img src="/picture/cvd.png"></p><h3 id="插播：洪泛（分布式）"><a href="#插播：洪泛（分布式）" class="headerlink" title="插播：洪泛（分布式）"></a>插播：洪泛（分布式）</h3><p>洪泛不需要全局网络信息，分组被交换机发送给所有邻居，分组在除了入链路的每个链路都会转发，最后很多拷贝会到达目的。</p><p>洪泛的性质：所有可能的路由都会被尝试，至少一个包会通过最小cost路由，所有的交换机都被访问过（分布式，可能用于路由）</p><h3 id="随机路由（分布式）"><a href="#随机路由（分布式）" class="headerlink" title="随机路由（分布式）"></a>随机路由（分布式）</h3><p>节点选择一个出链路来转发到来的包，选择是随机或者轮流的，基于概率。不需要什么网络信息，适合强连通网络，路由不是最佳的。</p><p>以下说明如何分配概率：</p><p><img src="/picture/p.png"></p><h3 id="自适应路由"><a href="#自适应路由" class="headerlink" title="自适应路由"></a>自适应路由</h3><p>被用作几乎所有分组交换网络，当网络状况改变时候路由决策也会改变。需要网络的信息，需要在网络质量和开销之间权衡。有助于拥塞控制</p><h3 id="两种最小花费算法"><a href="#两种最小花费算法" class="headerlink" title="两种最小花费算法"></a>两种最小花费算法</h3><p><code>Dijkstra</code>算法和<code>Bellman-Ford</code>算法</p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>找到从给定源到其他所有节点的最短路径</p><ul><li>N是网络中的节点集合</li><li>s是源节点</li><li>T是到目前为止已经被算法合并的节点</li><li><code>w(i,j)</code>是从i到j的链路消耗<ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li></ul><h5 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h5><p><code>L(n)</code>是从源s到当前已知的节点n的最小路径花费</p><ol><li>初始化<ul><li><code>T={s}</code>是只包含源点s被合并其中的节点的集合</li><li><code>L(n)=w(s,n) for n≠s</code></li><li>初始化到邻居节点的路径花费</li></ul></li><li>得到下一个节点<ul><li>找到不在T中的到源点s的最短路径的x，<code>min L(x)</code></li><li>把x合并在T中</li></ul></li><li>更新路径<ul><li><code>L(n)=min{L(n),L(x)+w(x,n)} for all n∉T</code></li><li>如果后者更小的话，那么从s到n的路径就变成了从s到x再从x到n的路径</li></ul></li></ol><p>算法在所有节点被添加到T中时结束</p><p>步骤2和3的一次迭代会添加一个新节点到T中</p><p><img src="/picture/dijkstra.png"></p><p>但是可能会出现震荡，解决办法就是非同步运行路由算法，链路代价更新随机化（让每台路由器发送链路通告的时间随机化）</p><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>找到一条从给定节点包含最多一条链路的最短路径，</p><p>找到一条从给定节点包含最多两条链路的最多路径（基于前面的步骤）</p><p>找到一条…不断进行迭代</p><ul><li><p>s是源点</p></li><li><p><code>w(i,j)</code>是从i到j的链路消耗</p><ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li><li><p>h是在当前阶段路径上链路的最大数量</p></li><li><p><code>L_h(n)</code>是在当前不超过h条链路的限制下从s到n的最短链路消耗</p></li></ul><h5 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>初始化<ul><li><code>L_0(n) = ∞, for all n ≠ s</code> </li><li><code>L_1(n) = w(s, n) </code></li><li><code>L_h(s) = 0, for all h</code></li></ul></li><li>更新<ul><li>对于每个连续的<code>h&gt;0</code></li><li>对于每个<code>n≠s</code>，计算<code>L_(h+1)(n) = min_j [Lh(j)+w(j,n)]</code></li><li>用已经找到最小的预处理节点j连接n</li><li>消除在早期迭代过程中形成的n的任何连接</li></ul></li><li>重复一直到没有改变</li></ol><p><img src="/picture/Bellman.png"></p><h5 id="链路花费改变"><a href="#链路花费改变" class="headerlink" title="链路花费改变"></a>链路花费改变</h5><p>当链路代价改变时候：</p><ul><li>节点检测到本地链路代价改变了</li><li>更新路由信息，重新计算距离向量</li><li>如果<code>DV</code>，改变了，就通知周围邻居<ul><li><img src="/picture/dv.png"></li><li>t0:y检测到链路代价改变，更新dv，通知邻居</li><li>t1:z收到来自y的更新，更新自己的表，计算到x的最小距离，发送给邻居</li><li>t2:y收到z的更新，更新自己的表，没有改变，所以不用给z发送消息</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DP-有向无环图的最长路径</title>
      <link href="/2021/06/07/DP-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/06/07/DP-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图中的最长路径"><a href="#有向无环图中的最长路径" class="headerlink" title="有向无环图中的最长路径"></a>有向无环图中的最长路径</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为一个数字<code>n</code>，表示总点数。之后点的标号为从<code>0</code>到<code>n-1</code>。</p><p>之后的每一行，格式为<code>3</code>个数字，以空格隔开，分别为相连的两个点的编号，它们的边的权值。</p><p>注：输入为有向图。如果出现了<code>“0 1 50”</code>表示点<code>0</code>到点<code>1</code>之间有一条边，权值为<code>50</code>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>点0到其他所有点的最长路径，以空格隔开。注：点0到其他所有点都是可达的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度要求在<strong>O(m+n)</strong></p><p>样例输入输出</p><pre class="line-numbers language-none"><code class="language-none">输入：60 1 10 3 21 2 62 4 12 5 23 4 33 1 44 5 1输出：6 12 2 13 14 </code></pre><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先，看到复杂度是线性时间复杂度，我们想到不太可能用类似<code>Dijkstra</code>，<code>Prime</code>之类的算法，大概是用一个<code>DFS</code>或者<code>BFS</code>框架来完成。</p><p>对于有向无环图，我们会敏锐地发觉它的一些特性：从0经过某些顶点之前，路径上必然会经过另一些顶点！！！如果我们在处理顶点A之前，对它之前的所有顶点的路径进行处理的话，我们就可以依托之前的路径来对顶点A进行处理。这句话怎么听起来这么耳熟？没错，这似乎就是动态规划的具体做法！</p><p>众所周知，动态规划的思路就是<strong>利用前面已经求出的子问题来解决其他的子问题</strong>。我们通过前面经过的顶点来求后面的顶点，与这个思想相符。那么我们怎么判断谁在前谁在后呢？联系算法需要的线性复杂度，我们联想到<code>Topo</code>排序，对顶点进行拓扑序小的在前面，拓扑序大的在后面。那么基本的思路逐渐清晰了。</p><p>先利用拓扑排序对顶点进行排序，这样我在遍历某一个顶点A的时候，从0到A的路径上的所有顶点必然已经被遍历过！那么我们如何找到他前面的顶点呢？做法有两种，第一种是建立一个逆邻接表，这样就可以找到哪一个路径通向点A；第二种做法是在遍历A前面节点X的时候，直接对X的邻居进行处理，这样在遍历到A的时候，A已经被处理完了，A的任务就只变成了对A的邻居进行处理。这两种做法本质上是一样的，但是鉴于省下更多的时间和空间，我采用了第二种方法！</p><p>复杂度分析：<code>topo</code>排序是线性复杂度，后面的<code>DP</code>也是线性复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面我们就可以进行Coding了！代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std; //邻接表节点，存储邻居节点和路径长度struct node {    int v, weight;    node(int _v, int _w) { v = _v; weight = _w; }};//邻接表，二维矩阵vector&lt;vector&lt;node&gt;&gt; table;//topo的本质是DFS，需要visit数组vector&lt;bool&gt; visit;//存储topo序，顶端的topo序更小stack&lt;int&gt; topo;//存储答案vector&lt;int&gt; res; void dfs(int v) {    visit[v] = true;    for (int i = 0; i &lt; table[v].size(); i++) {        if(!visit[table[v][i].v])dfs(table[v][i].v);    }    topo.push(v);//在处理过v后面所有的节点之后，v的节点topo序要小于它后面的所有节点} int main() {    int n;    scanf("%d", &amp;n);//初始化         res = vector&lt;int&gt;(n, 0);    visit = vector&lt;bool&gt;(n, false);    table = vector&lt;vector&lt;node&gt;&gt;(n);    int v1, v2, w;    while (scanf("%d %d %d",&amp;v1,&amp;v2,&amp;w)!=-1) {        table[v1].push_back(node(v2, w));    }     dfs(0);//topo排序     while (!topo.empty()) {        int cur = topo.top();        topo.pop();        for (int i = 0; i &lt; table[cur].size(); i++) {//处理cur的邻居            res[table[cur][i].v] = max(res[table[cur][i].v], res[cur] + table[cur][i].weight);        }    }    for (int i = 1; i &lt; n; i++) {        printf("%d ", res[i]);    }     return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记链路层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-直接链路"><a href="#一-直接链路" class="headerlink" title="一.直接链路"></a>一.直接链路</h2><p>主机和路由器都是节点。连接相邻结点的信道叫做链路。</p><p>链路的不同类型：</p><ul><li>有线点对点链路</li><li>有线多址链路（LANs）</li><li>无线链路（WIFI）</li></ul><h2 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二.数据链路层"></a>二.数据链路层</h2><p>二层分组（链路层分组）：帧，封装了网络层数据报</p><p>在相邻节点之间或者同一个局域网中的节点之间传送数据</p><p><img src="/picture/image-20210607210230081.png"></p><h3 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h3><p>在主机，路由器，交换机中实现。</p><p>链路层被实现在适配器中<code>"adaptor"</code>，比如网络接口卡（<code>NIC</code>）。以太网卡，802.11卡。</p><p>实现链路层和物理层，和主机的系统总线相连</p><p>硬件软件和固件的结合体</p><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p>提供了4种初级服务</p><h4 id="1-成帧"><a href="#1-成帧" class="headerlink" title="1.成帧"></a>1.成帧</h4><p>添加头尾封装上层数据报成帧</p><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>把数据报封装在帧中，添加错误检测比特，流控信息等等</p><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>寻找错误，进行流控等等。然后提取数据报交付给上层</p><h4 id="2-链路接入"><a href="#2-链路接入" class="headerlink" title="2.链路接入"></a>2.链路接入</h4><p>协调多路媒体访问，MAC地址被用在帧的头部来确定源和目的主机</p><p>全双工和半双工：接收和发送是否同时进行</p><p>有两种链路：</p><ul><li>点对点链路：专用的成对通信<ul><li>长距离光纤链路</li><li>在以太网交换机和主机之间的点对点链路</li></ul></li><li>广播链路：共享线路和媒介<ul><li>传统的以太网</li><li>802.11无线局域网</li></ul></li></ul><p><img src="/picture/image-20210607212004381.png"></p><h5 id="多路访问控制（MAC）"><a href="#多路访问控制（MAC）" class="headerlink" title="多路访问控制（MAC）"></a>多路访问控制（MAC）</h5><p>环境是一个共享的广播信道，它必须避免多个节点同时传送信息，否则碰撞导致数据错误！所以需要一个分布式的算法来决定哪一个节点可以传输数据，这样多路访问协议就诞生了。</p><p>多路访问协议是一个决定节点如何共享信道的分布式的算法，比如决定节点什么时候可以传输数据。关于信道共享的交流必须用到信道本身来交流（没有带外通道进行协作）</p><h5 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h5><p>这里有三种方式</p><h6 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h6><p>把信道分成不同的片，把这些片分配给节点，让节点单独占用</p><h6 id="轮流"><a href="#轮流" class="headerlink" title="轮流"></a>轮流</h6><p>节点轮流传送数据，但是需要发送更多数据的节点可能会等待较长时间</p><h6 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h6><p>信道不被分割，并且允许碰撞。碰撞之后要进行恢复。</p><h4 id="3-可靠交付"><a href="#3-可靠交付" class="headerlink" title="3.可靠交付"></a>3.可靠交付</h4><p>这种服务很少被用在像光纤这样的低比特错误率的链路，用在无线链路是高比特错误率。</p><p>进行流控：控制收发速率，确保发送者不会发送太快导致接收者的buffer溢出，有两种方法：</p><ul><li>停等协议</li><li>滑动窗口协议</li></ul><h5 id="3-1停等协议"><a href="#3-1停等协议" class="headerlink" title="3-1停等协议"></a>3-1停等协议</h5><h6 id="源主机传输帧，目的主机接收帧并且回复ACK"><a href="#源主机传输帧，目的主机接收帧并且回复ACK" class="headerlink" title="源主机传输帧，目的主机接收帧并且回复ACK"></a>源主机传输帧，目的主机接收帧并且回复ACK</h6><p>源主机在收到ACK之前不发送下一个包，目的主机可以通过不发送ACK来停止流</p><p>这种对于大型帧工作得很好</p><p><img src="/picture/image-20210607224657108.png"></p><h5 id="3-2滑动窗口协议"><a href="#3-2滑动窗口协议" class="headerlink" title="3-2滑动窗口协议"></a>3-2滑动窗口协议</h5><p>允许多个帧同时传送。接收者有一个大小为WIn得buffer（窗口），发送者可以发送最多Win个没有收到ACK的帧。每一个帧都被标号，ACK包含了下一个期待的帧的编号。序号被size域的大小k限制，帧的大小以2的k次方取模。</p><p>有一个问题：如果给定WIn，那么如何设置k？Win&lt;=2^k</p><p><img src="/picture/image-20210607224627065.png"></p><p>下面的图帮助理解滑动窗口</p><p><img src="/picture/image-20210607224804564.png"></p><h6 id="3-2-1后退n帧"><a href="#3-2-1后退n帧" class="headerlink" title="3-2-1后退n帧"></a>3-2-1后退n帧</h6><p>如果出现错误就恢复NAK，错误的帧和后面的所有帧都需要重传</p><h6 id="3-2-2选择性拒绝（选择重传）"><a href="#3-2-2选择性拒绝（选择重传）" class="headerlink" title="3-2-2选择性拒绝（选择重传）"></a>3-2-2选择性拒绝（选择重传）</h6><p>只有被拒绝的错误帧需要重传，接收者需要维护一个足够大的buffer</p><h4 id="4-错误检测和纠正"><a href="#4-错误检测和纠正" class="headerlink" title="4.错误检测和纠正"></a>4.错误检测和纠正</h4><p>处理由信号衰减和噪声导致的错误。接收者检测错误的出现，让信号发送者重传或者直接丢弃帧</p><p><img src="/picture/image-20210607225210550.png"></p><p>EDC是错误检测纠正码（冗余码），D是被错误检查保护的数据（包括头）</p><p>注意错误检测不是百分百可靠！比较大的EDC能更好的检测和纠正错误</p><h5 id="4-1奇偶校验法"><a href="#4-1奇偶校验法" class="headerlink" title="4-1奇偶校验法"></a>4-1奇偶校验法</h5><p>单比特奇偶校验：只能检测一位错误</p><p><img src="/picture/image-20210607225453805.png"></p><p>二维奇偶校验：能够检测和纠正单比特错</p><p><img src="/picture/image-20210607225658684.png"></p><h5 id="4-2CRC循环冗余码"><a href="#4-2CRC循环冗余码" class="headerlink" title="4-2CRC循环冗余码"></a>4-2CRC循环冗余码</h5><p>CRC被广泛运用硬件实现。数据部分D是二进制数字，有d位。选择一个<code>r+1</code>位的模式串G（生成多项式）<br>$$<br>𝐷∗2^𝑟=𝑎∗𝐺⊕𝑅, so 𝐷∗2^𝑟⊕R=a*G<br>$$<br>发送方发送左侧的<code>𝐷∗2^𝑟⊕R</code>代表<code>&lt;D,R&gt;</code></p><p>接收方当收到<code>&lt;D,R&gt;</code>的时候，如果被G整除就没错，否则就有错</p><p>限制：只可以检测出少于r+1位的突发错误</p><p><img src="/picture/image-20210607230618063.png"></p><h2 id="三-不同类型的局域网"><a href="#三-不同类型的局域网" class="headerlink" title="三.不同类型的局域网"></a>三.不同类型的局域网</h2><p>局域网有不同的拓扑</p><p><img src="/picture/image-20210607205650526.png"></p><h3 id="1-令牌环Token-Ring"><a href="#1-令牌环Token-Ring" class="headerlink" title="1.令牌环Token Ring"></a>1.令牌环Token Ring</h3><p>令牌环是一种局域网协议（IEEE802.5）</p><p>从IBM的商业的令牌环开始发展。因为IBM，令牌环获得了广泛的接受，但是从来没有达到以太网的流行程度</p><h4 id="环的操作"><a href="#环的操作" class="headerlink" title="环的操作"></a>环的操作</h4><p>每一个转发器（repeater）通过单向的传输链路连接另外两个，转发器扮演连接点的角色。</p><p><img src="/picture/image-20210607202641735.png"></p><p>数据一个比特一个比特地从一个转发器到另一个转发器传输。</p><ul><li>转发器重新生成和重传每一个比特</li><li>转发器执行数据插入，数据接收，数据删除的功能</li></ul><p>帧再进行一个循环的传递之后被发送器移除</p><h5 id="不同的状态"><a href="#不同的状态" class="headerlink" title="不同的状态"></a>不同的状态</h5><p><img src="/picture/image-20210607203827632.png"></p><h6 id="侦听状态"><a href="#侦听状态" class="headerlink" title="侦听状态"></a>侦听状态</h6><ul><li>扫描通过的比特流的模式：<ul><li>相连的站点的地址和目的站点的地址</li><li>令牌的传输权限</li></ul></li><li>复制输入位，发送给相连的站点<ul><li>如果目的地址匹配</li><li>再传发每一个比特</li></ul></li><li>当经过的的时候修改比特<ul><li>比如，表示数据包已经被复制（ACK）</li><li>或者做一个保留</li></ul></li></ul><h6 id="传输状态"><a href="#传输状态" class="headerlink" title="传输状态"></a>传输状态</h6><ul><li>回收帧，然后传回站点（为了ACK）</li><li>缓存别人的帧等候重传</li></ul><h6 id="路过的状态"><a href="#路过的状态" class="headerlink" title="路过的状态"></a>路过的状态</h6><ul><li>什么也不做</li></ul><h4 id="802-5MAC协议"><a href="#802-5MAC协议" class="headerlink" title="802.5MAC协议"></a>802.5MAC协议</h4><p>一个小的帧（令牌）在等候的时候循环，站点等待令牌</p><p>改变令牌的一个bit让它变成SOF（Start of Frame），然后再后面添加剩下的数据帧的内容</p><p>帧进行一个环形的旅行，然后被某一个传输站点吸收。然后站台当传输结束的时候插入新令牌</p><p>轻负载的时候有点效率底下，高度负载的时候，进行轮询</p><p><img src="/picture/image-20210607204827237.png"></p><h5 id="802-5的物理层"><a href="#802-5的物理层" class="headerlink" title="802.5的物理层"></a>802.5的物理层</h5><p><img src="/picture/image-20210607205538538.png"></p><h3 id="2-以太网Ethernet"><a href="#2-以太网Ethernet" class="headerlink" title="2.以太网Ethernet"></a>2.以太网Ethernet</h3><p>以太网是一种主导有线局域网的技术，有如下的好处：</p><ul><li>NIC网卡比较便宜</li><li>首先被广泛运用于局域网技术</li><li>比令牌局域网和ATM简单廉价</li><li>速度比较不错</li></ul><h4 id="以太网的物理拓扑"><a href="#以太网的物理拓扑" class="headerlink" title="以太网的物理拓扑"></a>以太网的物理拓扑</h4><h5 id="总线：在90年代中期很流行"><a href="#总线：在90年代中期很流行" class="headerlink" title="总线：在90年代中期很流行"></a>总线：在90年代中期很流行</h5><p>所有节点在同一个碰撞域中，可以互相碰撞</p><h5 id="星型拓扑：现在比较盛行"><a href="#星型拓扑：现在比较盛行" class="headerlink" title="星型拓扑：现在比较盛行"></a>星型拓扑：现在比较盛行</h5><p>每一个节点运行一个分离的以太网协议，不会相互碰撞（一般用交换机作为星型中心）</p><p><img src="/picture/image-20210607141806849.png"></p><p>下面说说他们的比较；广播vs交换以太网</p><p>总线拓扑是一种广播技术</p><ul><li>主机之间共享信道</li><li>每个包被所有相连的主机收到</li><li>通过CSMA/CD来进行媒体访问控制</li></ul><p>现代的以太网是交换以太网</p><ul><li>链路是交换机之间或者交换机和主机之间的</li><li>不需要共享信道-&gt;不用CSMA/CD</li><li>依靠自学习和生成树算法来路由！！</li></ul><h4 id="以太网的发展演变"><a href="#以太网的发展演变" class="headerlink" title="以太网的发展演变"></a>以太网的发展演变</h4><p>几乎除了帧的格式以外的所有东西都变了</p><ul><li>从共享媒介的线缆变成专用链路！</li></ul><ul><li>速度从3Mbps变成100Gbps！</li></ul><ul><li>从电子信号变成光信号！</li></ul><p>我们从中学到什么？正确的方法（比如以太网）可以经受得住很多改变，并且在保持方法的时候要更新技术！（后向兼容）</p><h4 id="以太网：不可靠，无连接"><a href="#以太网：不可靠，无连接" class="headerlink" title="以太网：不可靠，无连接"></a>以太网：不可靠，无连接</h4><p>无连接是说在收发的NIC之间没有握手的过程</p><p>不可靠是说接收者的NIC不给发送者的NIC发送确认消息，这样只有更上层的协议有可靠传输协议（TCP）才可以让丢掉的包得到恢复，否则抛弃的包就丢了！</p><h4 id="以太网帧的格式"><a href="#以太网帧的格式" class="headerlink" title="以太网帧的格式"></a>以太网帧的格式</h4><p>前导码Preamble：有七个字节，为了时钟同步，有一个字节指出帧的开始！</p><p>MAC地址Addresses：6字节，一共48bit</p><p>类型Type：2字节，填入上层协议，比如IP</p><p>数据负载Data payload：最大1500字节，最小46字节</p><p>CRC循环冗余码：4字节，一共32bit，进行错误检测</p><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>MAC地址是一个和网络适配器有关的数值地址</p><p>有48bit的名空间，比如16进制的00-15-C5-49-04-A9</p><p>当适配器生产时候就有一个独一无二的硬编码MAC地址</p><h6 id="MAC地址的分配"><a href="#MAC地址的分配" class="headerlink" title="MAC地址的分配"></a>MAC地址的分配</h6><p>分为不同的块，在MAC地址的前3个字节，被分配给不同的厂家，下面的3个字节由厂家来分配给每一个适配器</p><h5 id="成帧Framing-frames"><a href="#成帧Framing-frames" class="headerlink" title="成帧Framing frames"></a>成帧Framing frames</h5><p>物理层把bit放入链路，但是两个联通在相同物理媒介的主机需要交换帧，这个服务由链路层提供，由网络适配器来实现！</p><p>那么有一个问题：链路层如何判断每个帧的起止位置呢？</p><ol><li><p>简单的方法：比特计数，在帧的开始填入后面所跟的数据的大小，然后接受者根据这个值来解析！有一个缺点就是，如果这个计数的数值错了，将导致后面的帧全部错误！</p></li><li><p>哨兵位：用哨兵来标记帧的起止位置，<code>01111110</code>表示开始，<code>01111111</code>表示结束。但是有一个问题，如果在数据里面有哨兵怎么办？问题的解决办法是比特填充，如果在内容里面遇到5个1就在后面插入一个0，然后接收方每遇到5个1就拿掉后面的1个0！</p><p><img src="/picture/image-20210607145115984.png"></p></li></ol><p>举个例子，如果接收者看见了5个1：后面如果是0，那么就移走它继续解析；如果后面是1的话再看下一位，下一位是0，说明是帧的开始，否则是帧的结束！</p><h4 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h4><p><img src="/picture/image-20210607145201877.png"></p><h5 id="802-3的物理层"><a href="#802-3的物理层" class="headerlink" title="802.3的物理层"></a>802.3的物理层</h5><p>有许多不同的标准：</p><ul><li><p>类似的MAC协议和帧格式</p></li><li><p>不同的速率：2Mbps，10Mbps，100Mbps，1Gbps，10Gbps</p></li><li><p>不同的物理媒介：线缆，光纤</p><p><img src="/picture/image-20210607145639218.png"></p></li></ul><h2 id="四-媒体访问控制（MAC）"><a href="#四-媒体访问控制（MAC）" class="headerlink" title="四.媒体访问控制（MAC）"></a>四.媒体访问控制（MAC）</h2><p> 多路访问链路的性质：</p><ul><li>单一的共享广播信道</li><li>两个或以上的节点同时发送数据就会相互干扰</li><li>碰撞：节点同时接收两个或者更多信号</li></ul><h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><ul><li>决定节点如何共享信道的分布式算法，比如决定节点什么时候可以传输</li><li>关于信道共享的规划需要用到信道本身</li></ul><p>一个理想的多路访问协议是下面这样，给定一个广播信道的速率<code>R bps</code>，我们想要</p><ol><li>一个节点发送时，速率可以达到R</li><li>M个节点发送时，每个节点速率可达到R/ M</li><li>纯粹的分布式（去中心化）<ol><li>不需要特殊节点来协调传输</li><li>不需要同步时钟</li></ol></li><li>尽可能简单！</li></ol><h4 id="1-信道划分"><a href="#1-信道划分" class="headerlink" title="1.信道划分"></a>1.信道划分</h4><h5 id="1-1时分多路复用time-division-multiple-access"><a href="#1-1时分多路复用time-division-multiple-access" class="headerlink" title="1-1时分多路复用time division multiple access"></a>1-1时分多路复用time division multiple access</h5><p>把时间切分成等大的时间片，分为不同的轮次。每个站点得到固定大小的时间片（slot），如果轮到某个节点的时间片了，但是节点没有发送，那么这个时间片空闲！</p><p>可以达到的目标234</p><p>例如下面：6个站点，134要发包，256空闲</p><p><img src="/picture/TDMA.png"></p><h5 id="1-2频分多路复用frequence-division-muliple-access"><a href="#1-2频分多路复用frequence-division-muliple-access" class="headerlink" title="1-2频分多路复用frequence division muliple access"></a>1-2频分多路复用frequence division muliple access</h5><p>把信道划分为不同的频段，每个站点分配固定的频段，没有用到的频段空闲！FDMA和TDMA类似</p><h5 id="1-3码分多址复用（CDMA）"><a href="#1-3码分多址复用（CDMA）" class="headerlink" title="1-3码分多址复用（CDMA）"></a>1-3码分多址复用（CDMA）</h5><p>多用于无线广播网络，例如蜂窝网，卫星等等。</p><p>所有的节点共享相同的频率，但是每个节点有自己的chipping序号来编码数据</p><p>编码求原始数据 X chipping序号；解码求原始数据和chipping序号的内积</p><p>S1(D1XS1+D2XS2+D2XS3)/(|S1|^2)</p><p>需要code是正交的，多个节点可以以最小的干扰同时传输</p><p>CDMA计算比较复杂</p><p><img src="/picture/CDMA.png"></p><h4 id="2-轮流"><a href="#2-轮流" class="headerlink" title="2.轮流"></a>2.轮流</h4><h5 id="2-1轮询Polling"><a href="#2-1轮询Polling" class="headerlink" title="2-1轮询Polling"></a>2-1轮询Polling</h5><p>主节点邀请从节点轮流传输，傻瓜式从节点设备，比如蓝牙</p><p>问题：产生轮询开销，时延，master出问题所有都出问题，不是完全的分布式</p><p><img src="/picture/%E8%BD%AE%E8%AF%A2.png"></p><h5 id="2-2令牌传递"><a href="#2-2令牌传递" class="headerlink" title="2-2令牌传递"></a>2-2令牌传递</h5><p>控制令牌按照顺序从一个节点发送到下一个节点</p><p>问题：令牌的额外开销，时延，单个节点出错导致令牌丢失</p><h4 id="3-随机访问"><a href="#3-随机访问" class="headerlink" title="3.随机访问"></a>3.随机访问</h4><p>当节点有分组要发送的时候，以全速R进行发送，节点之间没有提前协调！如果多个节点同时传输就造成<strong>碰撞</strong></p><p>随机访问MAC协议指定如何检测和避免碰撞，如何从碰撞中恢复</p><p>随机访问多路媒体访问控制协议有：</p><ul><li>ALOHA，slotted ALOHA</li><li>CSMA，CSMA/CD，CSMA/CA</li></ul><h5 id="3-1ALOHA"><a href="#3-1ALOHA" class="headerlink" title="3-1ALOHA"></a>3-1ALOHA</h5><p>Additive Link On-line HAwaii system，被夏威夷大学设计</p><p>对于发送方：</p><ol><li>如果有帧要发就发</li><li>如果得到ACK就继续，否则以概率p重传，或者以1-p的概率等待</li><li>如果重复重传还没有ACK就放弃</li></ol><p>对于接收方：</p><ol><li>检查帧是否有问题</li><li>如果帧没问题，并且地址正确就发送ACK</li></ol><p>帧有可能被噪声和碰撞毁坏，有可能是另一个站点同时在发送，帧的任何一种重叠都会造成碰撞</p><p><img src="/picture/ALOHA.png"></p><h5 id="3-2时隙ALOHA"><a href="#3-2时隙ALOHA" class="headerlink" title="3-2时隙ALOHA"></a>3-2时隙ALOHA</h5><p>所有的帧大小相同，每一个时隙等于帧的传输时间。节点是同步的，需要一个中心时钟来同步时间。从一个时隙起点开始传输。帧要么不冲突，要么就完全冲突。</p><p>具体做法：节点如果有帧要传输，要在下一个时隙开始传输，如果没有碰撞节点下一个时隙就继续传输；如果有碰撞就每个时隙以p的概率重传</p><p><img src="/picture/slotALOHA.png"></p><h5 id="3-3CSMA载波侦听多路访问"><a href="#3-3CSMA载波侦听多路访问" class="headerlink" title="3-3CSMA载波侦听多路访问"></a>3-3CSMA载波侦听多路访问</h5><p>在传输之前先侦听，如果信道空闲就发送，否则停下来等待再发送。类比到人类就是在别人讲话时候不要打断别人。但是不可以消除所有碰撞，因为有传播时延！！！</p><p><img src="/picture/csma%E7%A2%B0%E6%92%9E.png"></p><h6 id="3-3-1-非持续CSMA"><a href="#3-3-1-非持续CSMA" class="headerlink" title="3-3-1 非持续CSMA"></a>3-3-1 非持续CSMA</h6><ol><li>站点要传输的时候就监听，如果空闲就传输，否则转到2</li><li>如果繁忙，等待一个随机的时间，转到1</li></ol><p>随机时间减小了碰撞的可能性，但是信道空间会被浪费，因为在传输完当前的包之后可能会等待</p><h6 id="3-3-2-1-坚持CSMA"><a href="#3-3-2-1-坚持CSMA" class="headerlink" title="3-3-2 1-坚持CSMA"></a>3-3-2 1-坚持CSMA</h6><p>为了避免等待信道时间造成的浪费，采用1坚持</p><ol><li>站点希望传输的时候监听，如果空闲就传输，否则转到2</li><li>如果繁忙就一直监听到空闲，空闲时立刻重传</li></ol><p>这是一种比较自私的做法，如果多个站点同时监听等待，肯定会造成碰撞</p><h6 id="3-3-3-p-坚持CSMA"><a href="#3-3-3-p-坚持CSMA" class="headerlink" title="3-3-3 p-坚持CSMA"></a>3-3-3 p-坚持CSMA</h6><p>一个折中的办法是p坚持CSMA，像非持续CSMA一样尽量减少碰撞，像1持续CSMA那样尽量减少等待时间</p><ol><li>如果监听信道空闲，以概率p的概率发送，以1-p的概率延迟一个时间单元（时间单元等于传播时延的最大值）</li><li>如果信道繁忙，监听知道空闲，然后转到1</li><li>延迟了一个时间单元之后，转到1</li></ol><p>那么p的值最好取多少呢？</p><p>我们p值的目标是避免在高负载的情况下的不稳定性</p><p>如果N个站点等候发送，理论上最好的值是1/N；如果是高负载的话，p是很小的，从而站点等候时间变长，造成很长时间的延迟！</p><h6 id="3-3-4比较！"><a href="#3-3-4比较！" class="headerlink" title="3-3-4比较！"></a>3-3-4比较！</h6><p>下面是不同类型CSMA的比较</p><p><img src="/picture/dCSMA.png"></p><h5 id="3-4-CSMA-CD-collision-detection"><a href="#3-4-CSMA-CD-collision-detection" class="headerlink" title="3-4 CSMA/CD(collision detection)"></a>3-4 CSMA/CD(collision detection)</h5><p>在使用CSMA的话，碰撞在传输期间仍然会发生，所以CSMA/CD碰撞传输一旦被检测到就会中断。具体做法如下：</p><ol><li>站点在传输的时候侦听，如果空闲就传输，否则转2</li><li>如果繁忙，持续侦听直到空闲。然后立刻传输</li><li>如果检测到碰撞，发送拥塞信号然后终止传输</li><li>在拥塞之后，等待一个随机的时间然后转到1</li></ol><p>下面是碰撞的发生</p><p><img src="/picture/CSMAcd.png"></p><h6 id="帧的最小长度"><a href="#帧的最小长度" class="headerlink" title="帧的最小长度"></a>帧的最小长度</h6><p>为了能够检测出碰撞，我们需要限制最小的帧的长度，否则有可能检测不到碰撞。</p><p>如下图，我们假设信道长度是L，传播的速度是V，带宽是B，帧的大小是size，那么从一端到另一端传播时延是<code>L/V</code>，如果在主机2即将传播到4的时候（t=L/V），4发送了帧，这样从主机4发送的帧到达主机2的时间t=2L/V，这样只有当传输时间大于2L/V时才可以检测到碰撞，也就是<code>size/B&gt;2L/V</code>！</p><p><img src="/picture/%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E.png"></p><h5 id="总结-随机访问的三个重要思想"><a href="#总结-随机访问的三个重要思想" class="headerlink" title="总结.随机访问的三个重要思想"></a>总结.随机访问的三个重要思想</h5><h6 id="载波侦听"><a href="#载波侦听" class="headerlink" title="载波侦听"></a>载波侦听</h6><ul><li>在讲话之前先侦听，不要打扰其他人讲话</li><li>检测是否已经有人在说话了</li><li>等到别人说完</li></ul><h6 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h6><ul><li>有别人同时说话就停下来，但是要确保所有人都知道碰撞了（最小帧长度的限制）</li><li>了解什么时候两个节点立刻传输</li><li>通过检测数据是否混乱来检测碰撞</li></ul><h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><ul><li>不要立刻重传</li><li>等一个随机时间再重传</li></ul><p>应该等待多久时间？</p><p>IEEE802.3使用1持续的CSMA，采用二进制指数退避的方式</p><ol><li>在前十次尝试发送中，每一次随机延迟的时间加倍，比如第一次重传从1 2里面选，第二次重传从1 2 3 4里面选….</li><li>超过十次重传的话，就保持第十次的最大时间不变，从中选择一个时间重传</li><li>超过16次重传说明信道过于繁忙，就会放弃，并且报告错误！</li></ol><p>1持续的二进制指数退避算法在很大范围的负载内表现得不错：低负载的时候保证了效率，高负载的时候保证了稳定性</p><h5 id="以太网CSMA-CD算法"><a href="#以太网CSMA-CD算法" class="headerlink" title="以太网CSMA/CD算法"></a>以太网CSMA/CD算法</h5><p>下面是以太网CSMA/CD算法的描述：</p><p><img src="/picture/ethernetcsmacd.png"></p><p>流程图</p><p><img src="/picture/cdmacdliuchengtu.png"></p><h3 id="多路访问协议的性能分析"><a href="#多路访问协议的性能分析" class="headerlink" title="多路访问协议的性能分析"></a>多路访问协议的性能分析</h3><h4 id="1-没有ACK的点到点链路"><a href="#1-没有ACK的点到点链路" class="headerlink" title="1.没有ACK的点到点链路"></a>1.没有ACK的点到点链路</h4><p>不管对于大型帧还是小型帧来说，利用率等于传输时间占总时间的比值。（<strong>总时间是指这个帧发出的时间到下一个帧发出的间隔时间</strong>）</p><p>假设传输时间为1，传播时间为a，那么总时间为<br>$$<br>U=1/(1+a)<br>$$</p><h4 id="2-令牌环"><a href="#2-令牌环" class="headerlink" title="2.令牌环"></a>2.令牌环</h4><p>对于大的令牌环来说，令牌从<code>t0</code>开始传输，然后在<code>t0+1</code>时候，帧的最后一个bit发送出去并且第一个比特回来，令牌开始传送，在<code>t=t0+1+a/n</code>到达下一个站点，这个时候下一个站点开始传输。</p><p>对于小的令牌环来说，令牌从<code>t0</code>开始传输，然后在<code>t0+a</code>从站点完全释放并且第一个比特回来，这时候令牌开始传给下一个站点，在<code>t=t0+a+a/N</code>时候令牌到达下一个站点</p><p>两种情况：</p><ol><li>case1：a&lt;1（当帧比环长）<br>$$<br>U=1/(1+a/N)<br>$$</li><li>case2：a&gt;1（帧比环短）<br>$$<br>U=1/(a+a/N)<br>$$</li><li></li></ol><h4 id="3-时隙ALOHA"><a href="#3-时隙ALOHA" class="headerlink" title="3.时隙ALOHA"></a>3.时隙ALOHA</h4><p>所有的帧有相同的大小，时间被同一分割，各个节点是同步的，传输在时隙的开始部分开始，帧要么全部碰撞要么就不碰撞。</p><p>假定N个节点有帧要发送，每一个在以p的概率在时隙发送，那么一个节点成功发送的概率是<code>p * (1-p)^(N-1)</code>，那么N个节点成功的概率是<code>A = N * p * (1-p)^(N-1)</code>。</p><p>如何找到成功概率，那么就是让<code>p=1/N</code>，<code>A=(1-1/N)^(N-1)</code>（利用函数求导）</p><p>如果能够被成功利用，信道的利用率<code>Us=1/(1+2α)</code></p><p>因为A是成功的概率，所以成功传送的利用率是<code>U=UsXA=(1-1/N)^(N-1)</code>，让N等于正无穷，U约等于<code>1/e</code></p><h4 id="4-纯ALOHA"><a href="#4-纯ALOHA" class="headerlink" title="4.纯ALOHA"></a>4.纯ALOHA</h4><p>更简单但是碰撞概率更高。当我t0发送一个帧的时候，我在<code>[t0-1,t0+1]</code></p><p><code>A=N*P(一个人在时隙传输)*P(没人在t0-1~t0传输)*P(没人在t0~t0+1传输)</code><br>$$<br>U=A=N<em>p</em>(1-p)^{2N-1}<br>$$<br>当<code>p=1/2N</code>并且N趋于无穷时，<code>U=1/(2e)</code></p><h4 id="5-CSMA-CD"><a href="#5-CSMA-CD" class="headerlink" title="5.CSMA/CD"></a>5.CSMA/CD</h4><p>暂时略</p><h3 id="MAC地址和它的发现"><a href="#MAC地址和它的发现" class="headerlink" title="MAC地址和它的发现"></a>MAC地址和它的发现</h3><p><img src="/picture/123.png"></p><p>一个主机A被制造时只有他自己的mac地址，那么我要联系主机B却不知道它的MAC地址，怎么办呢？</p><h4 id="1-链路层发现协议"><a href="#1-链路层发现协议" class="headerlink" title="1.链路层发现协议"></a>1.链路层发现协议</h4><p>ARP：Address Resolution Protocols</p><p>DHCP：Dynamic Host Configuration Protocol</p><p>被限制在单一局域网里，依靠广播能力</p><p>它们有两个功能：</p><ol><li>发现局域终端设备</li><li>辅助远程主机的交流</li></ol><h4 id="2-DHCP"><a href="#2-DHCP" class="headerlink" title="2.DHCP"></a>2.DHCP</h4><p>主机用DHCP来找到它自己的IP地址，网络掩码，DNS服务器的IP地址，默认的第一跳路由器的IP地址（默认网关）</p><h5 id="DHCP的标准过程"><a href="#DHCP的标准过程" class="headerlink" title="DHCP的标准过程"></a>DHCP的标准过程</h5><p><img src="/picture/dhcp.png"></p><h6 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h6><ol><li>客户在它所在的子网广播一个DHCP-Discover消息</li><li>每一个服务器都可能用一个DHCP-Offer消息回复</li><li>客户机选择一个服务器广播一个包含服务器IP地址的DHCP-Request消息</li><li>被选择的服务器确认绑定，用一个DHCP-ACK消息回复！</li><li>客户机根据DHCP-ACK设置它的配置参数</li></ol><h6 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h6><ol><li>客户机通过发送DHCP-RELEASE消息废除绑定</li><li>如果客户机不更新之前绑定的关系，绑定会过期</li></ol><p><img src="/picture/guocheng.png"></p><h5 id="当DHCP出现问题怎么办"><a href="#当DHCP出现问题怎么办" class="headerlink" title="当DHCP出现问题怎么办"></a>当DHCP出现问题怎么办</h5><p><img src="/picture/dhcphd.png"></p><h4 id="3-ARP"><a href="#3-ARP" class="headerlink" title="3.ARP"></a>3.ARP</h4><p>用户137.196.7.23想要ping 137.196.7.88</p><ul><li>源IP：137.196.7.23</li><li>目的IP：137.196.7.88</li><li>源MAC：71-65-F7-2B-08-53</li><li>目的MAC是多少呢？？？？？？？</li></ul><p>我们需要目的主机的MAC地址才可以传输数据，在局域网中，我们用ARP来获得MAC地址，需要给定目的主机IP地址！</p><p>ARP是一种IP到MAC地址的映射，只在局域网中起作用。对比DNS服务，DNS服务是域名到IP地址的映射！</p><h5 id="ARP的运行过程"><a href="#ARP的运行过程" class="headerlink" title="ARP的运行过程"></a>ARP的运行过程</h5><p>每一个主机都维护一个ARP表（IP地址到MAC地址的映射表），其中表项在一段时间之后会过期被删除</p><h6 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h6><ol><li>先查看本地的cache（ARP表）</li><li>如果没有发现目的IP对应的MAC地址的话，就构建一个ARP请求插入&lt;发送方IP，发送方MAC，目的IP&gt;</li><li>用MAC帧进行广播</li><li>收到ARP回复，进行缓存（加上时间戳）！</li></ol><h6 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h6><ol><li>检查ARP包的目的IP</li><li>如果目的IP是我的某个接口，构建一个ARP回复，插入&lt;目的IP，目的MAC&gt;</li><li>用MAC帧发送给发送</li><li>把发送方的&lt;IP,MAC&gt;存入cache</li></ol><p>但如果目的地址很远不在局域网之内怎么办？</p><p>我们要先用ARP查找第一跳路由器的MAC地址</p><p>那么主机如何知道我和目的没有在同一个局域网里？</p><p>通过子网掩码！</p><p>那么主机咋知道第一跳路由器在哪？</p><p>通过DHCP协议！！！（默认网关）</p><p>下面是ARP的一个具体例子</p><p><img src="/picture/arpex.png"></p><h4 id="4-ARP和DHCP的关键"><a href="#4-ARP和DHCP的关键" class="headerlink" title="4.ARP和DHCP的关键"></a>4.ARP和DHCP的关键</h4><p>广播：通过广播来交流</p><p>缓存：在一定时间内记住过去的记录，存储信息来减少一定查询开销</p><p>软状态：记录最终会被删除</p><table><thead><tr><th>层</th><th>例子</th><th>结构</th><th>配置</th><th>解决服务</th></tr></thead><tbody><tr><td>应用层</td><td>p.nju.edu.cn</td><td>组织层级</td><td>根据手册</td><td>DNS（应用层-网络层）</td></tr><tr><td>网络层</td><td>123.23.88.66</td><td>拓扑层级</td><td>DHCP</td><td></td></tr><tr><td>链路层</td><td>45-CD-AC-38</td><td>供应商</td><td>硬编码</td><td>ARP（网络层-链路层）</td></tr></tbody></table><h4 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h4><h5 id="发现机制"><a href="#发现机制" class="headerlink" title="发现机制"></a>发现机制</h5><p>广播（ARP，DHCP）</p><p>洪泛，没有非常关键的中心化节点，不需要手动配置</p><p>目录服务（DNS）</p><p>不洪泛，可扩充，根目录是容易受到攻击的，需要辅助程序配置</p><h2 id="五-桥和二层交换机"><a href="#五-桥和二层交换机" class="headerlink" title="五.桥和二层交换机"></a>五.桥和二层交换机</h2><h3 id="局域网的互联"><a href="#局域网的互联" class="headerlink" title="局域网的互联"></a>局域网的互联</h3><p>要具备拓展到单一局域网之外的能力，提供到其他局域网或者广域网的互联服务，所以用到了桥</p><p>桥<code>bridge</code>的作用：</p><ul><li>连接不同的局域网，通常超过两个</li><li>同样使用链路层和物理层协议</li><li>存储转发局域网的帧</li><li>精准的位复制帧</li><li>需要交换路由的功能</li></ul><p><img src="/picture/bridge.png"></p><p>桥需要的特性：</p><ul><li>存储和转发<ul><li>读取在局域网中传播的帧，检查帧的MAC地址，选择性地存储这些地址</li><li>利用第二局域网的MAC协议，重传每一个帧</li></ul></li><li>透明度<ul><li>站点不应该感受到桥的存在</li></ul></li><li>即插即用，自学习<ul><li>桥不需要配置</li></ul></li></ul><h3 id="桥协议体系架构"><a href="#桥协议体系架构" class="headerlink" title="桥协议体系架构"></a>桥协议体系架构</h3><p>IEEE802.1D</p><p><img src="/picture/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png"></p><p>桥的机制：帧广播，环的破除，地址学习</p><h3 id="广播以太网"><a href="#广播以太网" class="headerlink" title="广播以太网"></a>广播以太网</h3><p>发送方通过一个广播链路来广播帧。如果目的MAC地址和接受者的MAC地址匹配或者是广播MAC地址<code>FF:FF:FF:FF:FF:FF</code>的话，每一个接受者的链路层把帧递交给网络层</p><p>广播以太网即插即用，不需要人工配置，广播作为一种辅助交流的方式</p><h4 id="广播风暴问题"><a href="#广播风暴问题" class="headerlink" title="广播风暴问题"></a>广播风暴问题</h4><p>在有环的扩充局域网里面广播会造成不断广播，造成帧不断重复并且永生，那么究竟是什么造成这个问题呢？答案是：环</p><p><img src="/picture/huan.png"></p><p>Perlman提出了她的解决办法：在拓扑中破除环，最简单的方法就是构建一个最小生成树！</p><h4 id="生成树协议（Perlman’85）"><a href="#生成树协议（Perlman’85）" class="headerlink" title="生成树协议（Perlman’85）"></a>生成树协议（Perlman’85）</h4><p>这个协议判断这个扩充局域网里面如何构建一个生成树。它有很好的性质：不需要人工配置，一旦出现错误会自恢复。因为它很方便好用，至今仍被使用！</p><h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><p>以任意的网络拓扑作为输入，找到一个形成生成树的链路的子集</p><p>它有两个方面：</p><ul><li>先找到一个根，其他节点都到根有一个最短路径，找到一个id最小的节点作为根</li><li>计算到根的最短路径。最短路径不可能有环，节点之间只要保持到最短路径的链路即可。如果有多个最短路径我们就选择相邻接点ID最小的那一条路径</li></ul><p>那么具体如何构建一个生成树呢？</p><p>我们需要一个特殊的消息来辅助，这个消息包含一个三元组（Y,d,X），表明包是来自X，以Y为根，和Y的距离为d。</p><p>当收到包的时候，交换机选择最小ID的节点作为root</p><p>每一个节点决定它的链路是否在到根的最短路径上，如果不是就排除它</p><h5 id="具体算法执行过程"><a href="#具体算法执行过程" class="headerlink" title="具体算法执行过程"></a>具体算法执行过程</h5><ol><li><p>最开始，每一个节点声称它自己是节点</p><p>交换机X把（X,0,X）发送给邻居</p></li><li><p>节点更新他们的信息：根是谁，举例根多远</p><p>当收到（Y，d，Z）的时候，检查Y的id是否小于当前root的id，如果是的话就让root=Y</p></li><li><p>节点计算他们的到根的距离</p><p>一般来说+1</p></li><li><p>如果根或者根到节点的最短路径改变了，就把新的三元组消息发送给邻居</p></li></ol><p><img src="/picture/%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95.png"></p><h5 id="鲁棒的生成树算法"><a href="#鲁棒的生成树算法" class="headerlink" title="鲁棒的生成树算法"></a>鲁棒的生成树算法</h5><p>算法必须对于错误作出应对：根节点错误，桥和链路错误</p><p>根节点需要周期性地发送root announcement消息，其他的桥继续转发消息</p><p>这样我们就可以通过超时来检测错误！如果没有定期收到来自跟的消息，那么就超市，所以我就声称自己是根然后进行更新生成树！</p><h4 id="在生成树里面洪泛"><a href="#在生成树里面洪泛" class="headerlink" title="在生成树里面洪泛"></a>在生成树里面洪泛</h4><p>洪泛需要使用下面的规则：</p><ol><li>忽略所有不在生成树里面的接口</li><li>起源的桥发包给所有可以的端口</li><li>当数据包到达一个接收端口时，将它发送到除接收端口以外的所有端口</li></ol><p>洪泛是不是一种对资源的浪费呢？</p><p>是这样的，但我们可以让它辅助很多有效的转发！</p><p>我们收到“没有用“的包的时候，它不一定没有用，因为我们可以从它里面”学习“到一些东西。如果节点A看见了B的分组从某个端口进来了，A就知道可以通过这个端口到达B！！！因为在生成树中只有一条到达B的路径，所以这个很有效</p><h5 id="节点可以学习路由"><a href="#节点可以学习路由" class="headerlink" title="节点可以学习路由"></a>节点可以学习路由</h5><p>每一个桥维护了一个转发表数据库。转发表是可以不断更新的：当一个帧到达端口X，它一定来自和X端口相连的局域网。我们使用源地址来更新转发表，因为端口X所能到达的区域包含这个地址！！！</p><p>转发表的每个表项都有一个定时器，到时之后会自动删除对应表项！</p><p>每次当帧到达的时候，源地址都会在数据库里面检查一下是否有更新</p><h3 id="桥的转发功能总结"><a href="#桥的转发功能总结" class="headerlink" title="桥的转发功能总结"></a>桥的转发功能总结</h3><p>桥维护一个转发表，表项是一个三元组&lt;MAC地址，端口，时间戳&gt;</p><p>对于到达端口X的每一个帧，首先查找转发表，看看是否有目的MAC地址在转发表里的：</p><ul><li>如果没有，转发到除了X的所有端口</li><li>如果目的MAC地址对应端口就是X，就丢弃</li><li>如果目的MAC对应的端口是Y，检查Y是在阻塞态还是转发态，如果是转发态就转发到Y（不在生成树里的就是阻塞态）</li></ul><h3 id="互联不同局域网的设备类型"><a href="#互联不同局域网的设备类型" class="headerlink" title="互联不同局域网的设备类型"></a>互联不同局域网的设备类型</h3><ol><li>集线器（Hubs）：物理层的转发器</li><li>桥：连接局域网（转发和自学习）</li><li>二层交换机：连接主机和局域网（桥的功能加上无碰撞）</li><li>三层交换机（路由器）：还包含了路由功能</li></ol><h4 id="1-集线器"><a href="#1-集线器" class="headerlink" title="1.集线器"></a>1.集线器</h4><p>星型布局活跃的中心元素。</p><p>每一个站点通过两根线连接集线器，用来发送和接收</p><p>集线器是一种转发器，当站点传输的时候，集线器在输出的线路上面单纯重复转发给其它站点</p><p>物理拓扑是星型，但在逻辑上相当于总线。从一个站点接收的包会被其他所有站点接收，如果两个站点同时传输就会导致碰撞！</p><h5 id="共享媒体总线和集线器的区别"><a href="#共享媒体总线和集线器的区别" class="headerlink" title="共享媒体总线和集线器的区别"></a>共享媒体总线和集线器的区别</h5><p><img src="/picture/busvshub.png"></p><h4 id="2-二层交换机"><a href="#2-二层交换机" class="headerlink" title="2.二层交换机"></a>2.二层交换机</h4><p>需要什么样的性质？</p><ul><li>链路层设备：<ul><li>存储转发以太网帧</li><li>检查收到的帧的MAC地址，有选择性的转发到一个或者多个出链路，用CSMA/CD</li></ul></li><li>透明性，主机不知道交换机的存在</li><li>即插即用，自学习</li></ul><p>交换机vs桥</p><ul><li>桥连接不同局域网，有2-4个端口</li><li>交换机连接各种不同的主机和局域网，有很多端口，可以实现无碰撞传输</li></ul><p>为什么要用交换以太网呢？</p><p>站点是专用直接地连到交换机上</p><p>交换机缓存和转发帧</p><p>以太网协议在每个入链路上被使用，但没有碰撞，全双工</p><p>A-A’和B-B‘可以同时发送，但是没有碰撞！</p><p><img src="/picture/switch.png"></p><p>局域网容量加倍：每一个端口/链路形成一个局域网段（无碰撞），有多个站点同时传输</p><h5 id="集线器和二层交换机的区别"><a href="#集线器和二层交换机的区别" class="headerlink" title="集线器和二层交换机的区别"></a>集线器和二层交换机的区别</h5><p><img src="/picture/difhs.png"></p><p>二层交换机的好处：</p><ul><li>从总线或集线器局域网转变成交换机局域网很方便</li><li>站点相对于原始的局域网有相同的能力（假定交换机有足够的能力来跟得上所有站点）</li><li>二层交换机扩充规模很容易</li></ul><h4 id="3-三层交换机"><a href="#3-三层交换机" class="headerlink" title="3.三层交换机"></a>3.三层交换机</h4><p>当站点数目变多的时候，二层交换机显示出了缺点：</p><ul><li>广播有额外开销，比如要往100万个节点的局域网里广播就很麻烦</li><li>缺乏多条路径选择，因为生成树只有唯一路径，如果一条路断了可能影响很多节点</li></ul><p>三层交换机在硬件实现了路由器IP转发的逻辑，互联类似的局域网，就像二层交换机一样</p><h2 id="六-无线网络和移动网络"><a href="#六-无线网络和移动网络" class="headerlink" title="六.无线网络和移动网络"></a>六.无线网络和移动网络</h2><p>无线网络和移动网络在当今非常盛行，用户数量大大超过有线网络！但是面临着两种挑战：</p><ul><li>无线：在无线链路上面交流</li><li>移动：移动用户可能在不同的网络接入点接入，非无线网络也可能要处理移动的问题。基站也要提供接入有线网络的连接</li></ul><p><img src="/picture/wireless.png" alt="无线网络的基础设施"></p><ul><li>基站：用来接入有线网络；用来中继，负责在优先网络和无线主机中传包，例如蜂窝塔，802.11接入点</li><li>无线链路：用来讲移动设备连接到基站，也被用作主干链路，多路访问协议来协调链路访问，不同链路有不同的传播速率和传输距离</li></ul><p><img src="/picture/%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF.png" alt="各种无线链路标准"></p><h3 id="两种操作模式"><a href="#两种操作模式" class="headerlink" title="两种操作模式"></a>两种操作模式</h3><ul><li>基础设施模式：依靠基站把无线网络接入有线网络</li><li>自组织模式（Ad-hoc mode）：无线主机们自动组织成网络</li></ul><h4 id="基础设施模式"><a href="#基础设施模式" class="headerlink" title="基础设施模式"></a>基础设施模式</h4><p>基站把移动设备连接到有线网络，移动设备在不同的区域可能会改变基站</p><h4 id="自组织模式"><a href="#自组织模式" class="headerlink" title="自组织模式"></a>自组织模式</h4><p>不需要基站，节点只可以和链路范围覆盖的其他节点进行传输，节点把它们自己组织成网络</p><h3 id="无线网络分类"><a href="#无线网络分类" class="headerlink" title="无线网络分类"></a>无线网络分类</h3><p><img src="/picture/taxonomy.png" alt="无线网络分类"></p><h3 id="无线链路的特点"><a href="#无线链路的特点" class="headerlink" title="无线链路的特点"></a>无线链路的特点</h3><h4 id="1-信号强度衰减"><a href="#1-信号强度衰减" class="headerlink" title="1.信号强度衰减"></a>1.信号强度衰减</h4><p>由于反射，衍射，吸收地形，湿度等原因，路径上会有信号衰减</p><p><code>Free Space Path Loss叫FSPL</code><br>$$<br>FSPL=(4Πdf/c)^2<br>$$<br><code>d</code>是距离，<code>λ=c/f</code>是波长，<code>f</code>是频率，<code>c</code>是光速</p><h5 id="1-1-SNR和BER"><a href="#1-1-SNR和BER" class="headerlink" title="1-1 SNR和BER"></a>1-1 SNR和BER</h5><p>SNR是信噪比（signal-to-noise ratio），信噪比越大从中提出正确的信号越容易！</p><p>BER是误码率</p><p>给定一个物理链路，我们要提升链路的能力就要提升信噪比，减小误码率</p><p>在不同链路会有不同的信噪比和误码率，根据链路动态调整</p><p><img src="/picture/SNRBER.png"></p><h4 id="2-多路传播"><a href="#2-多路传播" class="headerlink" title="2.多路传播"></a>2.多路传播</h4><p>广播信号由于反射之类的干扰，在不同时间到达终点，导致主机无法判断是否是一个新的packet</p><p>多路效应：信号从一些表面进行反弹，干扰其他信号（自干扰）</p><h4 id="3-相互干扰"><a href="#3-相互干扰" class="headerlink" title="3.相互干扰"></a>3.相互干扰</h4><p>不同的设备共享频率，相互干扰</p><h3 id="IEEE-802-11无线局域网（WIFI）"><a href="#IEEE-802-11无线局域网（WIFI）" class="headerlink" title="IEEE 802.11无线局域网（WIFI）"></a>IEEE 802.11无线局域网（WIFI）</h3><p>single-cell配置和multi-cell配置</p><p><img src="/picture/single.png"></p><p><img src="/picture/multi.png"></p><h4 id="1-802-11架构"><a href="#1-802-11架构" class="headerlink" title="1.802.11架构"></a>1.802.11架构</h4><p>基站：符合MAC和物理层的设备</p><p>接入点（AP）：通过无线媒介提供分发式系统的接入服务</p><p>基础服务集（BSS）：被一个AP协调的cell</p><p>扩展服务集（ESS）：被分发式系统互联的多个BSS。分发式系统可能是一个交换机，一个有线网络，或者无线网络。一个ESS看起来就像一个单独的逻辑上的局域网，路由器提供到因特网的接入</p><p>分发式系统（DS）：一个被用来互联BSS集并且整合局域网以构成ESS的系统</p><p><img src="/picture/poss.png"></p><p>802.11b：2.4GHz-2.485GHz的频段被划分成不同频率的11个信道。AP的管理员选择AP的频段，但是如果邻居AP选择了和我相同的频段，我们可能出现相互干扰。</p><p>主机：必须和AP关联。扫描信道监听包含AP名字和MAC地址的信标帧，然后选择一个AP来关联或许还要身份验证（WIFI密码），连接之后通过DHCP来获得在AP子网下的IP地址</p><h5 id="1-关联的方式"><a href="#1-关联的方式" class="headerlink" title="1.关联的方式"></a>1.关联的方式</h5><p>有两种，分别是被动扫描和主动扫描</p><h6 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h6><ol><li>AP发送信标帧（Beacon frames）</li><li>主机发送关联请求帧（Associaion Request frame）给自己选择的AP</li><li>然后AP发送关联回复帧（Association Response frame）给刚才的主机</li></ol><h6 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h6><ol><li>主机广播探查请求帧（Probe Request frame）</li><li>AP收到后给予探查回复帧（Probe Response frame）</li><li>主机发送关联请求帧</li><li>AP发送关联回复帧</li></ol><p><img src="/picture/%E5%85%B3%E8%81%94.png"></p><h5 id="2-多路访问"><a href="#2-多路访问" class="headerlink" title="2.多路访问"></a>2.多路访问</h5><p>多个无线发送者和接受者可能会造成一些问题（不仅仅是多路访问控制的问题）</p><ul><li>隐藏终端问题</li></ul><p><img src="/picture/yczd.png"></p><ul><li>信号衰减问题</li></ul><p><img src="/picture/xhsj.png"></p><ul><li>暴露终端问题</li></ul><p><img src="/picture/blzd.png"></p><p>我们主要来讨论隐藏终端问题，解决方法：<strong>4帧交换</strong></p><ol><li>源（广播）发送一个发送请求帧（Request to Send,RTS）给目的</li><li>目的用CTS（Clear to Send）回复，发送给所有节点，告诉他们有人要发送帧了！</li><li>在收到CTS之后，源节点开始传送数据</li><li>目的节点用ACK回复，还是发送给所有节点，告诉他们上一个已经发送完了</li></ol><p><img src="/picture/rtscts.png"></p><h5 id="3-媒体访问控制"><a href="#3-媒体访问控制" class="headerlink" title="3.媒体访问控制"></a>3.媒体访问控制</h5><p><img src="/picture/mac.png"></p><h6 id="3种优先级"><a href="#3种优先级" class="headerlink" title="3种优先级"></a>3种优先级</h6><p>帧间距inter frame space</p><ul><li>SIFS(short inter frame space)最短帧间距</li><li>PIFS(point coordination function IFS)点协调控制</li><li>DIFS(distributed coordination function IFS)分布式协调控</li></ul><p>SIFS的使用</p><ul><li>站点在一个SIFS时间间隔后回复ACK</li><li>LLC</li><li>轮询回复</li><li>CTS</li></ul><p>PIFS和DIFS</p><p>PIFS被集中控制器使用，DIFS被使用于异步网络</p><p><img src="/picture/80211.png"></p><h6 id="PCF点协调控制"><a href="#PCF点协调控制" class="headerlink" title="PCF点协调控制"></a>PCF点协调控制</h6><p>通过中心化的轮询控制器来轮询</p><ul><li>使用分配轮询的时候用PIFS</li><li>当它发出轮询和接收响应时，它可以捕获媒介并锁定所有异步通信量</li></ul><p>无线网络由多个具有时效性的站点组成，由点协调器控制</p><ul><li>点协调器轮流轮询站点</li><li>当轮询发出时候，轮询的站点用SIFS回复轮询</li><li>如果点协调器收到回复，那么用PIFS发出另一个轮询</li><li>如果点协调器没有收到回复，它就发出另一个轮询</li><li>重复，直到当前一轮截止</li></ul><p>超级帧：一种时间间隔。在超级帧间隔的第一部分，点协调器对所有轮询站点进行轮询；在剩下的部分允许争夺异步访问。在超级帧的开头，点协调器创建一个避免争夺期，因为回复的站点发出对的帧的大小的变化来辩护这个时期持续的时间；在超级帧的后面，点协调控制器用PIFS来争夺访问，最后通过信标帧来标志下一个循环！</p><p>超级帧： 点协调器不断发布轮询，会封锁所有异步通信量。为了避免这种情况，在超帧时间的前一部分，由点协调器轮询，在超帧时间的后一部分，允许异步通 信量争用接入。</p><p><img src="/picture/%E8%B6%85%E7%BA%A7%E5%B8%A7.png"></p><h6 id="DCF分布式协调控制"><a href="#DCF分布式协调控制" class="headerlink" title="DCF分布式协调控制"></a>DCF分布式协调控制</h6><p>DCF使用CSMA/CA（拥塞避免），站点在传送前感知媒介，不会和正在传输的站点碰撞</p><p>DCF包含了时延，在传输之前等待一个帧间距</p><p><strong>为什么不需要碰撞检测？</strong></p><ol><li>当传输时候因为信号衰减很难收到别人发的信号！</li><li>传输站点不能区分噪声和弱信号！</li><li>不能感觉到所有碰撞，比如发生隐藏终端问题，信号衰减等待</li><li>ACK用起来很好！</li></ol><h6 id="802-11的MAC协议：CSMA-CA"><a href="#802-11的MAC协议：CSMA-CA" class="headerlink" title="802.11的MAC协议：CSMA/CA"></a>802.11的MAC协议：CSMA/CA</h6><p>发送方：</p><ol><li>如果感知到DIFS信道空闲就传输整个帧</li><li>如果信道繁忙，就开始随机时间回退，当信道空闲时候计时器倒计时，当时间到了就传输，如果没有ACK，就增加随机的回退间隔，重复2</li></ol><p>接收方：</p><ol><li>如果帧接收没问题，在SIFS之后返回一个ACK</li></ol><p><strong>碰撞避免</strong></p><p>允许发送方预约信道而不是信号针的随机接入，避免长数据帧的碰撞</p><p>发送方先用CSMA传送很小的RTS给基站</p><p>基站广播CTS来回应RTS</p><p>CTS被所有站点收到，发送方传输数据，其他站点推迟传输</p><p>这样就通过用一个预约分组来预约信道，完全避免了碰撞！</p><p><img src="/picture/%E9%A2%84%E7%BA%A6.png"></p><h5 id="4-802-11帧"><a href="#4-802-11帧" class="headerlink" title="4.802.11帧"></a>4.802.11帧</h5><p><img src="/picture/frame.png"></p><p>为什么要用地址3？</p><p><img src="/picture/why.png"></p><p>需要实现803.11帧到802.3帧的转换，首先传到AP之后，AP要传给路由器R1</p><h5 id="5-移动性：在同一个子网下移动"><a href="#5-移动性：在同一个子网下移动" class="headerlink" title="5.移动性：在同一个子网下移动"></a>5.移动性：在同一个子网下移动</h5><p>H1保持在同样的IP子网，IP地址可能保持不变</p><p>但如果H1从BBS1移动到BBS2的话怎么办？</p><p>依靠自学习，先看H1来自第一个端口，然后又来自第二个端口，就更新了转发表</p><h5 id="6-先进的能力"><a href="#6-先进的能力" class="headerlink" title="6.先进的能力"></a>6.先进的能力</h5><p>速率控制：基站，移动设备根据信噪比来动态调节比特率！</p><p>功率控制：节点会告诉AP，你给我下一个信标帧之前，我先睡一会！你给我信标帧我会被叫醒。</p><h3 id="蜂窝网络"><a href="#蜂窝网络" class="headerlink" title="蜂窝网络"></a>蜂窝网络</h3><p><img src="/picture/cell.png"></p><p>两种技术用来共享移动广播频谱：</p><ul><li>FDMA和TDMA的结合：用频率划分频谱，然后把每个信道划分为时间槽</li><li>利用CDMA</li></ul><h4 id="2G网络架构"><a href="#2G网络架构" class="headerlink" title="2G网络架构"></a>2G网络架构</h4><p><img src="/picture/2G.png"></p><h4 id="3G网络架构"><a href="#3G网络架构" class="headerlink" title="3G网络架构"></a>3G网络架构</h4><p><img src="/picture/3G.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
