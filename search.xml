<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2021/05/29/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/29/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图中的最长路径"><a href="#有向无环图中的最长路径" class="headerlink" title="有向无环图中的最长路径"></a>有向无环图中的最长路径</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为一个数字<code>n</code>，表示总点数。之后点的标号为从<code>0</code>到<code>n-1</code>。</p><p>之后的每一行，格式为<code>3</code>个数字，以空格隔开，分别为相连的两个点的编号，它们的边的权值。</p><p>注：输入为有向图。如果出现了<code>“0 1 50”</code>表示点<code>0</code>到点<code>1</code>之间有一条边，权值为<code>50</code>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>点0到其他所有点的最长路径，以空格隔开。注：点0到其他所有点都是可达的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度要求在<strong>O(m+n)</strong></p><p>样例输入输出</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：<br>6<br>0<span class="hljs-number"> 1 </span>1<br>0<span class="hljs-number"> 3 </span>2<br>1<span class="hljs-number"> 2 </span>6<br>2<span class="hljs-number"> 4 </span>1<br>2<span class="hljs-number"> 5 </span>2<br>3<span class="hljs-number"> 4 </span>3<br>3<span class="hljs-number"> 1 </span>4<br>4<span class="hljs-number"> 5 </span>1<br>输出：<br>6<span class="hljs-number"> 12 </span>2<span class="hljs-number"> 13 </span>14 <br></code></pre></td></tr></tbody></table></figure><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先，看到复杂度是线性时间复杂度，我们想到不太可能用类似<code>Dijkstra</code>，<code>Prime</code>之类的算法，大概是用一个<code>DFS</code>或者<code>BFS</code>框架来完成。</p><p>对于有向无环图，我们会敏锐地发觉它的一些特性：从0经过某些顶点之前，路径上必然会经过另一些顶点！！！如果我们在处理顶点A之前，对它之前的所有顶点的路径进行处理的话，我们就可以依托之前的路径来对顶点A进行处理。这句话怎么听起来这么耳熟？没错，这似乎就是动态规划的具体做法！</p><p>众所周知，动态规划的思路就是<strong>利用前面已经求出的子问题来解决其他的子问题</strong>。我们通过前面经过的顶点来求后面的顶点，与这个思想相符。那么我们怎么判断谁在前谁在后呢？联系算法需要的线性复杂度，我们联想到<code>Topo</code>排序，对顶点进行拓扑序小的在前面，拓扑序大的在后面。那么基本的思路逐渐清晰了。</p><p>先利用拓扑排序对顶点进行排序，这样我在遍历某一个顶点A的时候，从0到A的路径上的所有顶点必然已经被遍历过！那么我们如何找到他前面的顶点呢？做法有两种，第一种是建立一个逆邻接表，这样就可以找到哪一个路径通向点A；第二种做法是在遍历A前面节点X的时候，直接对X的邻居进行处理，这样在遍历到A的时候，A已经被处理完了，A的任务就只变成了对A的邻居进行处理。这两种做法本质上是一样的，但是鉴于省下更多的时间和空间，我采用了第二种方法！</p><p>复杂度分析：<code>topo</code>排序是线性复杂度，后面的<code>DP</code>也是线性复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面我们就可以进行Coding了！代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-comment">//邻接表节点，存储邻居节点和路径长度</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> {</span><br>    <span class="hljs-keyword">int</span> v, weight;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _w) { v = _v; weight = _w; }<br>};<br><span class="hljs-comment">//邻接表，二维矩阵</span><br>vector&lt;vector&lt;node&gt;&gt; table;<br><span class="hljs-comment">//topo的本质是DFS，需要visit数组</span><br>vector&lt;<span class="hljs-keyword">bool</span>&gt; visit;<br><span class="hljs-comment">//存储topo序，顶端的topo序更小</span><br>stack&lt;<span class="hljs-keyword">int</span>&gt; topo;<br><span class="hljs-comment">//存储答案</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{<br>    visit[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; table[v].<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-keyword">if</span>(!visit[table[v][i].v])<span class="hljs-built_in">dfs</span>(table[v][i].v);<br>    }<br>    topo.<span class="hljs-built_in">push</span>(v);<span class="hljs-comment">//在处理过v后面所有的节点之后，v的节点topo序要小于它后面的所有节点</span><br>}<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br><span class="hljs-comment">//初始化     </span><br>    res = vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>);<br>    visit = vector&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>    table = vector&lt;vector&lt;node&gt;&gt;(n);<br>    <span class="hljs-keyword">int</span> v1, v2, w;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;w)!=<span class="hljs-number">-1</span>) {<br>        table[v1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node</span>(v2, w));<br>    }<br> <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//topo排序</span><br> <br>    <span class="hljs-keyword">while</span> (!topo.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-keyword">int</span> cur = topo.<span class="hljs-built_in">top</span>();<br>        topo.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; table[cur].<span class="hljs-built_in">size</span>(); i++) {<span class="hljs-comment">//处理cur的邻居</span><br>            res[table[cur][i].v] = <span class="hljs-built_in">max</span>(res[table[cur][i].v], res[cur] + table[cur][i].weight);<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, res[i]);<br>    }<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
