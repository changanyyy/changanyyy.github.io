<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT6-828-note-lab4</title>
      <link href="/2021/08/15/MIT6-828-note-lab4/"/>
      <url>/2021/08/15/MIT6-828-note-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab4-note"><a href="#Lab4-note" class="headerlink" title="Lab4 note"></a>Lab4 note</h1><h2 id="1-introduction"><a href="#1-introduction" class="headerlink" title="1 introduction"></a>1 introduction</h2><p>In this lab, we should implement the preemptive multitasking mechanism among multiple simultaneously active user-mode environment. The lab is divided into 3 parts, which in each part we have disparate tasks to complete. In part A, we will add multiprocessor support to our system, while we will implement a Unix-like <code>fork</code> in part B. Ultimately, we will add support for inter-process communication (<code>IPC</code>), allowing different user-mode environments to communicate and synchronize with each other explicitly.</p><h2 id="2-preparation"><a href="#2-preparation" class="headerlink" title="2 preparation"></a>2 preparation</h2><p>Before starting, we are supposed to acquire some propaedeutics about multitask and multiprocessor. There are some word abbreviations about this aspect: BSP, AP, MP. Below is the explanation of them.</p><h3 id="2-1-operating-system-boot-up"><a href="#2-1-operating-system-boot-up" class="headerlink" title="2-1  operating system boot-up"></a>2-1  operating system boot-up</h3><p>While all processors in an MP-compliant system are functionally identical, one of the processors will be designated as the boot processor (BSP) at system initialization by system hardware or by application processors (APs). <strong>The BSP is responsible for booting the operating system.</strong> Once the MP operating system is up and running, the BSP functions as an AP. Usually a processor is designed as the BSP because it is capable of controlling all system hardware, including AP start up and shut down. The operating system must determine and remember the APIC ID of the designated BSP, so it can keep the BSP operating as the last running processor during system shut down. The BSP is not necessarily the first processor, especially in fault-tolerant MP systems in which any available processor can be designated as the BSP. There are some AP states at the time that the first instruction of the operating system is executed, while our process are in halted condition with interrupts disabled. This means that the AP’s local APICs (<code>lapic</code>) are passively monitor the APIC bus and will react only to INIT or STARTUP inter-processor interrupts (IPIs).</p><h2 id="3-try-coding"><a href="#3-try-coding" class="headerlink" title="3 try coding"></a>3 try coding</h2><p>There are some new include files and source files at this stage. Let’s have a look at the crucial ones.</p><h3 id="2-2-labpic"><a href="#2-2-labpic" class="headerlink" title="2-2 labpic"></a>2-2 <code>labpic</code></h3><p>In <code>kern/init.c</code>, we see a function called <code>lapic_init</code> and trace into it. It brings me to a source file named <code>lapic.c</code>. A variable called <code>lapicaddr</code> is initialized in <code>mpconfig.c</code>. There are three structures: <code>mp</code>, <code>mpconf</code>, <code>mpproc</code>. There are some functions related to multiprocessor:</p><ul><li><code>sum(addr, len)</code>: It’s used to check whether all the bytes memory located at the address the <code>mp</code> variable that we want to examine contains can be add up to 0.</li><li><code>mpsearch1(a, len)</code>: It looks for an <code>MP</code> structure in the <code>len</code> bytes at physical address <code>addr</code>.</li><li><code>mpsearch(void)</code>: It searches for the <code>MP</code> Floating Pointer Structure, which according to <code>[MP 4]</code> is in one of the following three locations:<ol><li>in the first <code>KB</code> of <code>EBDA</code></li><li>if there is no <code>EBDA</code>, in the first <code>KB</code> of system base memory</li><li>in the BIOS ROM between <code>0xE0000</code> and <code>0xFFFFF</code></li></ol></li><li><code>mpconfig(struct mp **pmp)</code>: It searches for an <code>MP</code> configuration table and return a pointer pointing at a <code>mpconf</code>.</li></ul><p>Above is some basic auxiliary functions. And the most significant procedure is <code>mp_init</code>. It looks for the <code>mpconfig</code> and assign the address of local APIC to <code>lapicaddr</code>. And then it initializes <code>cpus[]</code> with the aid of the configuration we read.</p><p>so,we get the physical address of <code>LAPIC</code>. We can map the physical address in the virtual memory so that we can access it.</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span><span class="token comment" spellcheck="true">// location.  Return the base of the reserved region.  size does *not*</span><span class="token comment" spellcheck="true">// have to be multiple of PGSIZE.</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmio_map_region</span><span class="token punctuation">(</span>physaddr_t pa<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Your code here:</span>    size <span class="token operator">=</span> <span class="token function">ROUNDUP</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>base <span class="token operator">+</span> size <span class="token operator">>=</span> MMIOLIM<span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"mmio_map_region: out of memory\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">boot_map_region</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> pa<span class="token punctuation">,</span> PTE_PCD<span class="token operator">|</span>PTE_PWT<span class="token operator">|</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>    base <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf">MultiProcessor Specification (mit.edu)</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Reliable Method ch3</title>
      <link href="/2021/08/07/Software-Reliable-Method-ch3/"/>
      <url>/2021/08/07/Software-Reliable-Method-ch3/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-逻辑和定理证明"><a href="#第三章-逻辑和定理证明" class="headerlink" title="第三章 逻辑和定理证明"></a>第三章 逻辑和定理证明</h1><h2 id="3-1-一阶逻辑"><a href="#3-1-一阶逻辑" class="headerlink" title="3.1 一阶逻辑"></a>3.1 一阶逻辑</h2><p><strong>一阶逻辑的组成：简单变元（variable），关系，函数。</strong>变元的值域是某个指定的论域，比如实数或者整数。一阶逻辑可以用于推导该域中的所有对象，或者断言存在一个对象满足一个属性。</p><p><strong>为什么叫做一阶？因为公式里面所有变元的值域都是预先指定的论域（例如整数）。</strong>二阶逻辑里面，既可以使用简单变元，也可以使用集合变元，后者取值可以是对象的集合（类似于二次方）。例子，比如<code>x</code>是一个简单边缘而<code>Y</code>是一个集合变元，那么在二阶逻辑中表达一个公式<code>x ∈ Y</code>。三阶逻辑的变元可以是集合的集合，以此类推。</p><h2 id="3-2-项（term）"><a href="#3-2-项（term）" class="headerlink" title="3.2 项（term）"></a>3.2 项（term）</h2><p>一阶项是<strong>根据一阶逻辑的精确语法</strong>来表示的表达式。</p><p>下面是<strong>项的语法</strong>：</p><p>一个签名（signature）<code>_G = (V, F, R)</code>包括三个不相交的集合：变元符号集合V，函数符号集合F，关系符号集合R（正好对应了上面的组成）。其中函数和关系有自己的元数（参数的个数）。 项就是用函数符号和变元构造的表达式，我们常用<code>BNF</code>记法来定义项的语法：</p><p><code>term ::= var | const | func(term, term, ..., term)</code></p><p>这里面<code>var</code>是变元符号， <code>func</code>是函数符号，<code>const</code>是常量符号。可以看出来上述是一个递归定义。</p><p>我们现在仅仅是对项给予一个语法上的定义，但是并没有什么明确的语义。例如，我们对于<code>add(v1, 2)</code>用来表示<code>v1</code>加<code>2</code>似乎非常直观，很符合我们的习惯，但是这个仅仅是我们的臆想，我们需要形式化地说明这之间的联系，也就是我们对于项的一种解释。我们为了解释一个项，有下面的步骤：</p><ol><li>我们需要给定一个<strong>论域D</strong>，它可以是任何一个集合，比如整数，自然数，有理数……</li><li>那么我们定义一阶结构， <code>S = (ς, D, _F, _R, f)</code>，这个结构的成员有：<ul><li>签名<code>_G = (V, F, R)</code>，也就是语法结构</li><li>论域<code>D</code>（一个集合）</li><li>函数集合<code>_F</code></li><li>关系集合<code>_R</code></li><li>映射<code>f</code>：<code>F∪R -&gt; _F∪_R</code>。这个映射把签名中的函数与关系映射到论域<code>D</code>的实际函数和关系</li></ul></li><li><strong>赋值（assignment）a</strong>把变元集合<code>V</code>中的变元映射到论域<code>D</code>中的值，用<code>a: V-&gt;D</code>来表示。</li><li>我们用<code>terms(_G)</code>来表示签名<code>_G</code>上的所有的项。下面我们可以定义<strong>语义解释（semantic interpretation）T_a : terms(G)-&gt;D</strong>。它把每一个项映射为论域中的值。这个定义是递归的：<ul><li><code>T_a(v) = a(v)</code>，对于<code>v∈V</code></li><li><code>T_a(func(e1, e2, ..., en)) = f(func)(T_a(e1), T_a(e2), ..., T_a(en))</code></li><li>来解释一下，第一行定义了<strong>变元的语义解释是在赋值a下的值</strong>，第二行是<strong>项的递归定义</strong>。上面的含义是：<code>func(e1, e2, ..., en)</code>是在一阶结构<code>_S</code>上<code>func</code>关联的实际函数，那么<code>f(func)</code>就是<code>func</code>函数实际关联的函数，而<code>T_a(ei)</code>是<code>ei</code>的解释，所以我们递归地进行解释。</li></ul></li></ol><p>我们为什么要费尽心机把语义和语法分开呢？<strong>通过指明记法（语法）和含义（语义）之间的关系，一阶逻辑允许我们证明论域上的属性。这种做法基于语法，它通过对公式进行字符串操作完成证明，再利用语义解释把操作的结果投射到我们讨论的数学对象。</strong>就我的理解来说，是为了方便我们的证明！</p><h2 id="3-3-一阶公式"><a href="#3-3-一阶公式" class="headerlink" title="3.3 一阶公式"></a>3.3 一阶公式</h2><p>先介绍语法。<strong>在项上面应用关系符号可以构造得到简单公式</strong>，语法是：</p><p><code>simp_form ::= rel(term, term, ..., term) | term ≡ term</code></p><p>这是一个简单公式，同样是用<code>BNF</code>形式来表示的，<strong>一阶公式不仅包含上面这样的简单公式，还可以递归地应用布尔运算符与，或，非，蕴含，或者再公式前面加上一个量词（quantifier）‘“对于所有”，“存在”</strong>。下面是<strong>一阶公式的定义</strong>：</p><p><code>form ::= simp_form | (form ∧ form) | (form ∨ form) | (form -&gt; form) | (¬form) | ∀var(form) | ∃var(form) | true | false</code></p><p>我们可以看出这个还是一个递归定义。其中布尔运算符的优先级可以帮助我们省略一些括号。在合取式中的每一项叫做合取项；在析取式中的每一项叫做析取项。</p><p>下面是关于一阶公式的语义解释：</p><ol><li>关系符号<code>“≡”</code>是标准的等于关系，<code>v1≡v2</code>成立当且仅当<code>v1</code>和<code>v2</code>被赋予相同的值，也就是当<code>a(v1) = a(v2)</code>时成立。需要注意的是：逻辑内用<code>“≡”</code>表示相等，而逻辑外使用<code>“=”</code>表示对象之间的相等。</li><li><code>forms(_G)</code>是在签名<code>_G</code>上的一阶公式的集合。解释<code>M_a: forms(_G) -&gt; {TRUE, FALSE}</code>把布尔值赋值给每一个公式。语义解释仍然依赖于赋值a。对于不包含量词的公式的解释如下：<ul><li><code>M_a(pred(e1, e2, ..., en)) = f(pred)(M_a(e1), M_a(e2), ..., M_a(en))</code></li><li><code>M_a(e1 ≡ e2) = (T_a(e1) = T_a(e2))</code></li><li></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件形式化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件形式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6-828-note-lab3</title>
      <link href="/2021/07/31/MIT6-828-note-lab3/"/>
      <url>/2021/07/31/MIT6-828-note-lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab3-note"><a href="#Lab3-note" class="headerlink" title="Lab3 note"></a>Lab3 note</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>I learned a lot in the two experiments conducted couple of days ago. Let’s look back at the previous labs. In the first lab, we were acquainted with the process of booting a computer. And in the next one, we learnt and completed a system supporting paging. On this occasion, we are supposed to complete a portion of system called processes switching. (Maybe it’s more accurate to call it environments switching?)</p><blockquote><p>Note: in this lab, the terms environment and process are interchangeable - both refer to an abstraction that allows you to run a program. We introduce the term “environment” instead of the traditional term “process” in order to stress the point that JOS environments and UNIX processes provide different interfaces, and do not provide the semantics.</p></blockquote><h2 id="2-Start-coding"><a href="#2-Start-coding" class="headerlink" title="2 Start coding"></a>2 Start coding</h2><h3 id="2-1-read-code"><a href="#2-1-read-code" class="headerlink" title="2-1 read code"></a>2-1 read code</h3><p>In this lab directory, there are much more additional source and header files. After having a quick view on these files, I have a rough idea about environments.</p><p>In <code>inc/env.h</code>, we can see some basic structures sustaining the abstraction of environments switching:</p><ol><li><p>we define a new variable type <code>envid_t</code>.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> int32_t envid_t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// An environment ID 'envid_t' has three parts:</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// +1+---------------21-----------------+--------10--------+</span><span class="token comment" spellcheck="true">// |0|          Uniqueifier             |   Environment    |</span><span class="token comment" spellcheck="true">// | |                                  |      Index       |</span><span class="token comment" spellcheck="true">// +------------------------------------+------------------+</span><span class="token comment" spellcheck="true">//                                       \--- ENVX(eid) --/</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// The environment index ENVX(eid) equals the environment's index in the</span><span class="token comment" spellcheck="true">// 'envs[]' array.  The uniqueifier distinguishes environments that were</span><span class="token comment" spellcheck="true">// created at different times, but share the same environment index.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// All real environments are greater than 0 (so the sign bit is zero).</span><span class="token comment" spellcheck="true">// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and</span><span class="token comment" spellcheck="true">// stands for the current environment.</span></code></pre></li><li><p>And we define the maximal number of environments that concurrently run.</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> LOG2NENV        10</span><span class="token macro property">#<span class="token directive keyword">define</span> NENV            (1 &lt;&lt; LOG2NENV)</span></code></pre><p>As seen above, <code>NENV</code> is <code>1024 (2^10)</code>.</p><p>Additionally, we define a macro <code>#define ENVX(envid)        ((envid) &amp; (NENV - 1))</code>, the macro extract the <strong>INDEX</strong> portion of environment ID.</p></li><li><p>the following is a enumeration structure representing values of environment status <code>env_status</code>.</p><ul><li><code>ENV_FREE</code>: It indicates that the environment structure variable is not in use. we can feel free to allocate it to a new environment.</li><li><code>ENV_DYING</code>: The environment is dying, so we should free the structure variable in next dis-allocation.</li><li><code>ENV_RUNNABLE</code>: The environment is queuing in the scheduling queue and ready to run.</li><li><code>ENV_RUNNING</code>: It is the current environment.</li><li><code>ENV_NOT_RUNNABLE</code>: It is in blocked status, so it can’t be scheduled.</li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Values of env_status in struct Env</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>    ENV_FREE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    ENV_DYING<span class="token punctuation">,</span>    ENV_RUNNABLE<span class="token punctuation">,</span>    ENV_RUNNING<span class="token punctuation">,</span>    ENV_NOT_RUNNABLE<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li><p>The enumeration <code>EnvType</code> represents the <code>env_type</code> member. This is used to distinguish special environments. For most environments,it is <code>ENV_TYPE_USER</code>. But more types in later labs.</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Special environment types</span><span class="token keyword">enum</span> EnvType <span class="token punctuation">{</span>    ENV_TYPE_USER <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li><p>The most important structure is coming! <code>Env</code> plays a role as <strong>Process Control Block</strong>. </p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Env <span class="token punctuation">{</span>    <span class="token keyword">struct</span> Trapframe env_tf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Saved registers</span>    <span class="token keyword">struct</span> Env <span class="token operator">*</span>env_link<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Next free Env</span>    envid_t env_id<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Unique environment identifier</span>    envid_t env_parent_id<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// env_id of this env's parent</span>    <span class="token keyword">enum</span> EnvType env_type<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Indicates special system environments</span>    <span class="token keyword">unsigned</span> env_status<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Status of the environment</span>    uint32_t env_runs<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Number of times environment has run</span>    <span class="token comment" spellcheck="true">// Address space</span>    pde_t <span class="token operator">*</span>env_pgdir<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Kernel virtual address of page dir</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>The structure has a couple of fields as above:</p><ol><li><p>The first member is a structure named <code>Trapframe</code>. It holds the saved register values for the environment while it is not running.</p><p><img src="/picture/trapframe.png"></p></li><li><p>The second is a pointer pointing to next free environment in the free environment list that we are going to use to allocate a new environment structure variable.</p></li><li><p><code>env_id</code>: I have explained it above. and <code>env_parent_id</code> is it’s parent’s <code>env_id</code>,for we will introduce the concept of <strong>father and son processes</strong>. All the relationships form a <strong>family tree</strong>. The kernel stores a value that uniquely identifiers the environment currently using <code>Env</code>. After a user environment terminates, the Kernel may re-allocate the same <code>Env</code> structure to a new environment that need a different <code>env_id</code> from the old one even though the new environment is re-using the same slot in the <code>env</code> array.</p></li><li><p><code>env_type</code> and <code>env_status</code>: I’ve introduced it above.</p></li><li><p><code>env_runs</code>: Numbers of times the environment has run.</p></li><li><p>The last member is <code>env_pgdir</code> which supports the virtual address memory space layout, just like <code>kern_pgdir</code>.</p></li></ol></li></ol><p>Above, I introduced some basic structure. But how to transform them into entities? Let’s look at the source file <code>kern/env.c</code>. There are three entities that are reflected in the eyes.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Env <span class="token operator">*</span>envs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// All environments</span><span class="token keyword">struct</span> Env <span class="token operator">*</span>curenv <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// The current env</span><span class="token keyword">static</span> <span class="token keyword">struct</span> Env <span class="token operator">*</span>env_free_list<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Free environment list</span></code></pre><ul><li><p><code>envs</code>: The <code>envs</code> pointer points to an array of <code>Env</code> structures representing all the environments in the system. The JOS Kernel will support a maximum of <code>NENV</code> simultaneously active environments.</p></li><li><p><code>curenv</code>: This is a pointer pointing to the running environment. It is initially set to <code>NULL</code>. We use the <code>curenv</code> symbol to keep track of the currently executing environment at any given time. During boot up, before the first environment is run, <code>curenv</code> is initially set to <code>NULL</code>.</p></li><li><p><code>env_free_list</code>: This is the head pointer of free environment list , which point to the first environment structure variable that is ready to be assigned out.</p><ul><li><p>for example, if we wanna allocate a <code>env</code> for a new environment, we could do it like this: (basic for chain list)</p><pre class=" language-c"><code class="language-c">e <span class="token operator">=</span> env_free_list<span class="token punctuation">;</span>env_free_list <span class="token operator">=</span> env_free_list<span class="token operator">-></span>env_link<span class="token punctuation">;</span></code></pre></li><li><p>Additionally, if we want to recycle a <code>env</code>:</p><pre class=" language-c"><code class="language-c">e<span class="token operator">-></span>env_free_list <span class="token operator">=</span> env_free_list<span class="token punctuation">;</span>env_free_list <span class="token operator">=</span> e<span class="token punctuation">;</span></code></pre></li></ul></li></ul><p>As I said above, the include file <code>inc/env.h</code> contains basic definitions for user environments in JOS. Kernel uses the <code>Env</code> array to keep track of each user environment. In the followings, We will initially create just one environment, but later we should make the Kernel support multiple environments.</p><p>We couples the concepts of thread and address space. The thread is defined primarily by the saved registers, and the address space is defined by the page directory and page tables pointed to by <code>env_pgdir</code>. In order to run an environment, Kernel should set up the CPU with both the saved registers and the appropriate address space.</p><h3 id="2-2-Allocating-the-Environment-Array"><a href="#2-2-Allocating-the-Environment-Array" class="headerlink" title="2-2  Allocating the Environment Array"></a>2-2  Allocating the Environment Array</h3><p>Before using environment array, we should allocate space for it.</p><p>The work will be done in <code>mem_init</code>, which is intended for initializing memory space, opening paging mechanism, and layout for the virtual address space.</p><p>Just like the <code>pages</code> array, we allocate space for <code>envs</code>:</p><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////</span>    <span class="token comment" spellcheck="true">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    envs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> Env <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">boot_alloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Env<span class="token punctuation">)</span> <span class="token operator">*</span> NENV<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>And as usual, next step is of course map the array at linear address <code>UENVS</code>. </p><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    <span class="token function">boot_map_region</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>UENVS<span class="token punctuation">,</span> PTSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>physaddr_t<span class="token punctuation">)</span><span class="token function">PADDR</span><span class="token punctuation">(</span>envs<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To test whether my code is correct, <code>make qemu</code> and find that <code>check_kern_pgdir()</code> succeeds.</p><h3 id="2-3-Make-the-Environment-Run"><a href="#2-3-Make-the-Environment-Run" class="headerlink" title="2-3 Make the Environment Run"></a>2-3 Make the Environment Run</h3><p>After allocating the space, we can use the <code>env</code> array to do anything. But we should get familiar with something, such as how we can load the binary image in the correct position. The guide says as below:</p><blockquote><p>The Lab 3 <code>GNUmakefile</code> generates a number of binary images in the <code>obj/user/</code> directory. If you look at <code>kern/Makefrag</code>, you will notice some magic that “links” these binaries directly into the kernel executable as if they were <code>.o</code> files. The <code>-b binary</code> option on the linker command line causes these files to be linked in as “raw” uninterpreted binary files rather than as regular <code>.o</code> files produced by the compiler. (As far as the linker is concerned, these files do not have to be ELF images at all - they could be anything, such as text files or pictures!) If you look at <code>obj/kern/kernel.sym</code> after building the kernel, you will notice that the linker has “magically” produced a number of funny symbols with obscure names like <code>_binary_obj_user_hello_start</code>, <code>_binary_obj_user_hello_end</code>, and <code>_binary_obj_user_hello_size</code>. The linker generates these symbol names by mangling the file names of the binary files; the symbols provide the regular kernel code with a way to reference the embedded binary files.</p></blockquote><p>Let’s have a look at <code>obj/kern/kernel.sym</code>, which lists all the symbols in the Kernel ELF file. So the user binary ELF files are integrated into the Kernel! So surprising! It indicates that we should read ELF files from Memory instead of disk hardware. We can operate it by <code>memcpy</code> or <code>memset</code>.</p><p><img src="/picture/kernsym.png"></p><p>First, we fill the function <code>env_init</code>. It links up all the (free) nodes in <code>envs</code>.</p><p>It’s usually done with the method of head interpolation. And according to the guide, the pointer <code>env_free_list</code> should point to <code>env[0]</code>. And don’t forget clear the <code>env_id</code>. </p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Mark all environments in 'envs' as free, set their env_ids to 0,</span><span class="token comment" spellcheck="true">// and insert them into the env_free_list.</span><span class="token comment" spellcheck="true">// Make sure the environments are in the free list in the same order</span><span class="token comment" spellcheck="true">// they are in the envs array (i.e., so that the first call to</span><span class="token comment" spellcheck="true">// env_alloc() returns envs[0]).</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">void</span><span class="token function">env_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Set up envs array</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    env_free_list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> NENV <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        envs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>env_status <span class="token operator">=</span> ENV_FREE<span class="token punctuation">;</span>        envs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>env_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        envs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>env_link <span class="token operator">=</span> env_free_list<span class="token punctuation">;</span>        env_free_list <span class="token operator">=</span> <span class="token operator">&amp;</span>envs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Per-CPU part of the initialization</span>    <span class="token function">env_init_percpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>The function <code>env_setup_vm</code> is the second function we should fill in. It’s duty is to initialize the Kernel virtual memory layout for an environment pointed to by <code>e</code>.  The things it does is allocate a page directory, set <code>e-&gt;env_pgdir</code> accordingly, and initialize the Kernel portion of the new environment’s address space. In this stage, don’t map anything into the user portion.</p><p>I utilise an auxiliary function called <code>map_region</code> that has the same function as <code>boot_map_region</code>. There are four regions that we should deal with:</p><ol><li><code>UPAGES</code>: the array keeping track of physical pages</li><li><code>UENVS</code>: the array keeping track of active environments</li><li><code>KSTACK</code>: kernel stack of JOS</li><li><code>KERNBASE</code>: kernel data and code</li></ol><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span><span class="token function">env_setup_vm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Env <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">struct</span> PageInfo <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Allocate a page for the page directory</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token function">page_alloc</span><span class="token punctuation">(</span>ALLOC_ZERO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>E_NO_MEM<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    p<span class="token operator">-></span>pp_ref<span class="token operator">++</span><span class="token punctuation">;</span>    e<span class="token operator">-></span>env_pgdir <span class="token operator">=</span> <span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">page2pa</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">map_region</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>UPAGES<span class="token punctuation">,</span> PTSIZE<span class="token punctuation">,</span>         <span class="token punctuation">(</span>physaddr_t<span class="token punctuation">)</span><span class="token function">PADDR</span><span class="token punctuation">(</span>pages<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">map_region</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>UENVS<span class="token punctuation">,</span> PTSIZE<span class="token punctuation">,</span>         <span class="token punctuation">(</span>physaddr_t<span class="token punctuation">)</span><span class="token function">PADDR</span><span class="token punctuation">(</span>envs<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">map_region</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>KSTACKTOP <span class="token operator">-</span> KSTKSIZE<span class="token punctuation">,</span> KSTKSIZE<span class="token punctuation">,</span>         <span class="token punctuation">(</span>physaddr_t<span class="token punctuation">)</span><span class="token function">PADDR</span><span class="token punctuation">(</span>bootstack<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_W <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">map_region</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>KERNBASE<span class="token punctuation">,</span> <span class="token number">0xffffffff</span> <span class="token operator">-</span> KERNBASE<span class="token punctuation">,</span>        <span class="token punctuation">(</span>physaddr_t<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> PTE_W <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// UVPT maps the env's own page table read-only.</span>    <span class="token comment" spellcheck="true">// Permissions: kernel R, user R</span>    e<span class="token operator">-></span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_P <span class="token operator">|</span> PTE_U<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>The next function is <code>region_alloc</code>.  When the parameter <code>len</code> is 0 or a negative number, it’s the illegal state. Physical pages are supposed to simultaneously be mapped for <code>kern_pgdir</code> and <code>env_pgdir</code>. Another solution is <code>lcr3(e-&gt;pgdir[PDX(UVPT)])</code>, which reaches the same goal as my method.</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Allocate len bytes of physical memory for environment env,</span><span class="token comment" spellcheck="true">// and map it at virtual address va in the environment's address space.</span><span class="token comment" spellcheck="true">// Does not zero or otherwise initialize the mapped pages in any way.</span><span class="token comment" spellcheck="true">// Pages should be writable by user and kernel.</span><span class="token comment" spellcheck="true">// Panic if any allocation attempt fails.</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">region_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Env <span class="token operator">*</span>e<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>va<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"region_alloc: len is a negtive num\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>st <span class="token operator">=</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>end <span class="token operator">=</span> <span class="token function">ROUNDUP</span><span class="token punctuation">(</span>va <span class="token operator">+</span> len<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pgn <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> st<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">;</span>    <span class="token keyword">struct</span> PageInfo <span class="token operator">*</span>pg<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pgn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pg <span class="token operator">=</span> <span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token operator">~</span>ALLOC_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pg<span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"region_alloc: alloc failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pg<span class="token operator">-></span>pp_ref<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">page_insert</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">,</span> pg<span class="token punctuation">,</span> va<span class="token punctuation">,</span> PTE_W <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">page_insert</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> pg<span class="token punctuation">,</span> va<span class="token punctuation">,</span> PTE_W <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span>        va <span class="token operator">+</span><span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Having finished the previous functions, we come up with the function <code>load_icode</code>. It will load the code and data of user environment into the correct position. First, we define a variable named <code>elfhdr</code> whose type is <code>struct Elf</code> and another two variables named <code>ph</code> and <code>eph</code> pointing to the start and the end of the program header.</p><p>The following code assigned ELF header to <code>elfhdr</code>, and testify that it is correct:</p><pre class=" language-c"><code class="language-c">    <span class="token keyword">struct</span> Elf <span class="token operator">*</span>elfhdr<span class="token punctuation">;</span>    elfhdr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> Elf <span class="token operator">*</span><span class="token punctuation">)</span> binary<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>elfhdr <span class="token operator">-></span> e_magic <span class="token operator">!=</span> ELF_MAGIC<span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"load_icode: elf header error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>For further environment switching, we have to assign <code>e_entry</code> to <code>e-&gt;env_tf.tf_eip</code> so that once we switch to this environment, the register <code>eip</code> will point to the first instruction.</p><p>Then, we load sections through loops:</p><blockquote><p>Attention!!!</p><p>We should map corresponding regions before moving memory! And don’t forget to clear the memory between <code>filesz</code> and <code>memsz</code>.</p></blockquote><pre class=" language-c"><code class="language-c">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//cprintf("%d",ph->p_type);</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ph<span class="token operator">-></span>p_type <span class="token operator">==</span> ELF_PROG_LOAD<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">region_alloc</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> ph<span class="token operator">-></span>p_va<span class="token punctuation">,</span> ph<span class="token operator">-></span>p_memsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> ph<span class="token operator">-></span>p_va<span class="token punctuation">,</span> binary <span class="token operator">+</span> ph<span class="token operator">-></span>p_offset<span class="token punctuation">,</span> ph<span class="token operator">-></span>p_memsz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> ph<span class="token operator">-></span>p_va <span class="token operator">+</span> ph<span class="token operator">-></span>p_filesz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ph<span class="token operator">-></span>p_memsz <span class="token operator">-</span> ph<span class="token operator">-></span>p_filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span></code></pre><p>In the end, we map one page for the program’s initial stack at virtual address <code>USTACKTOP-PGSIZE</code>:</p><pre class=" language-c"><code class="language-c">    <span class="token function">region_alloc</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> USTACKTOP <span class="token operator">-</span> PGSIZE<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The remaining two functions will integrate above all functions. But they are not difficult.</p><p>The first one is <code>env_create</code>:</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Allocates a new env with env_alloc, loads the named elf</span><span class="token comment" spellcheck="true">// binary into it with load_icode, and sets its env_type.</span><span class="token comment" spellcheck="true">// This function is ONLY called during kernel initialization,</span><span class="token comment" spellcheck="true">// before running the first user-mode environment.</span><span class="token comment" spellcheck="true">// The new env's parent ID is set to 0.</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">void</span><span class="token function">env_create</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token keyword">enum</span> EnvType type<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    <span class="token keyword">struct</span> Env <span class="token operator">*</span>env_store <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//******a bug had confused me for a long time, it's because curenv is null!</span>    <span class="token comment" spellcheck="true">//int r = env_alloc( env_store, curenv->env_id);</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_store<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"env_create: env alloc failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    env_store<span class="token operator">-></span>env_type <span class="token operator">=</span> type<span class="token punctuation">;</span>        <span class="token function">load_icode</span><span class="token punctuation">(</span>env_store<span class="token punctuation">,</span> binary<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>The second is <code>env_run</code>. There are two steps:</p><p>Step1:</p><ol><li>Set the current environment (if any) back to <code>ENV_RUNNABLE</code> if it is <code>ENV_RUNNING</code>.</li><li>Set <code>curenv</code> to the new environment.</li><li>Set its status to <code>ENV_RUNNING</code>.</li><li>Update its <code>env_runs</code> counter.</li><li>Use <code>lcr3()</code> to switch to its address space.</li></ol><p>Step2:</p><ol><li>Use <code>env_pop_tf()</code> to restore the environment’s registers and drop into user mode in the environment.</li></ol><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">env_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Env <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>curenv <span class="token operator">&amp;&amp;</span> curenv<span class="token operator">-></span>env_status <span class="token operator">==</span> ENV_RUNNING<span class="token punctuation">)</span>curenv<span class="token operator">-></span>env_status <span class="token operator">=</span> ENV_RUNNABLE<span class="token punctuation">;</span>    curenv <span class="token operator">=</span> e<span class="token punctuation">;</span>    curenv<span class="token operator">-></span>env_status <span class="token operator">=</span> ENV_RUNNING<span class="token punctuation">;</span>    curenv<span class="token operator">-></span>env_runs<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">lcr3</span><span class="token punctuation">(</span>curenv<span class="token operator">-></span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">env_pop_tf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>curenv<span class="token operator">-></span>env_tf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"env_run not yet implemented"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-Test-it"><a href="#3-Test-it" class="headerlink" title="3 Test it"></a>3 Test it</h2><p>After struggle with bugs for a while, I succeed so far. Below is the screenshot when I debug with <code>GDB</code>. It crashed at the instruction <code>int $0x30</code>, which we will complete corresponding codes.</p><p><img src="/picture/sigtrap.png"></p><h2 id="4-Set-IDT"><a href="#4-Set-IDT" class="headerlink" title="4  Set IDT"></a>4  Set IDT</h2><p>From now on, we should set interrupt descriptor table correct values. But before starting, we need review some assembly instructions such as <code>int</code> and <code>iret</code>.</p><h3 id="4-1-INT-and-tss"><a href="#4-1-INT-and-tss" class="headerlink" title="4-1 INT and tss"></a>4-1 <code>INT</code> and <code>tss</code></h3><p>The <code>INT</code> instruction generates a call to the interrupt or exception handler specified with the destination operand. The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vector are reserved by intel for system use. Some of these vectors are used for internally generated exceptions.</p><p>The <code>INT n</code> instruction is the general mnemonic for executing a software generated call to an interrupt handler. The <code>INTO</code> instruction is a special mnemonic for calling overflow exception, exception 4. The overflow interrupt checks the <code>OF</code> flag in the <code>EFLAGS</code> register and calls the overflow interrupt handler if the <code>OF</code> flag is set to 1.</p><p>The <code>int 3</code>instruction uses a one-byte opcode(CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP).</p><p>From i386 Documents, we find what <code>INT</code> instruction exactly does in the mode that JOS is now in:</p><pre class=" language-pseudocode"><code class="language-pseudocode">INTER-PRIVILEGE-LEVEL-INTERRUPT:    (* PE = 1, interrupt or trap gate, non-conforming code segment, DPL < CPL *)    IF (IA32_EFER.LMA = 0) (* Not IA-32e mode *)        THEN        (* Identify stack-segment selector for new privilege level in current TSS *)            IF current TSS is 32-bit                THEN                        TSSstackAddress ← (new code-segment DPL « 3) + 4;                        IF (TSSstackAddress + 5) > current TSS limit                            THEN #TS(error_code(current TSS selector,0,EXT)); FI;                            (* idt operand to error_code is 0 because selector is used *)                        NewSS ← 2 bytes loaded from (TSS base + TSSstackAddress + 4);                        NewESP ← 4 bytes loaded from (TSS base + TSSstackAddress);                ELSE (* current TSS is 16-bit *)                        TSSstackAddress ← (new code-segment DPL « 2) + 2                        IF (TSSstackAddress + 3) > current TSS limit                            THEN #TS(error_code(current TSS selector,0,EXT)); FI;                            (* idt operand to error_code is 0 because selector is used *)                        NewSS ← 2 bytes loaded from (TSS base + TSSstackAddress + 2);                        NewESP ← 2 bytes loaded from (TSS base + TSSstackAddress);            FI;            IF NewSS is NULL                THEN #TS(EXT); FI;            IF NewSS index is not within its descriptor-table limits            or NewSS RPL ≠ new code-segment DPL                THEN #TS(error_code(NewSS,0,EXT)); FI;                (* idt operand to error_code is 0 because selector is used *)            Read new stack-segment descriptor for NewSS in GDT or LDT;            IF new stack-segment DPL ≠ new code-segment DPL            or new stack-segment Type does not indicate writable data segment                THEN #TS(error_code(NewSS,0,EXT)); FI;                (* idt operand to error_code is 0 because selector is used *)            IF NewSS is not present                THEN #SS(error_code(NewSS,0,EXT)); FI;                (* idt operand to error_code is 0 because selector is used *)</code></pre><p> First, the CPU will judge how many bits the TSS is, and we goes into this branch. Now, we come across a symbol called <code>TSSstackAddress</code> that represents the offset of <code>esp</code> in the TSS descriptor in this new privilege. And then the <code>ss</code> register is loaded from <code>(TSS base + TSSstackAddress + 4)</code>. The <code>esp</code> register is loaded from <code>(TSS base + TSSstackAddress)</code>. </p><p>Now, we are get the idea What <code>TSS</code> is. The function <code>trap_init_percpu</code> in <code>kern/trap.c</code> is helpful for us. Firstly, JOS loads assigns <code>KSTACKTOP</code> and <code>ts_ss0</code> to <code>ts.ts_esp0</code> and <code>ts.ts_ss0</code>(privilege 0). And then load the <code>TSS</code> portion of <code>gdt</code> and load the TSS selector. That’s the initializing process.</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Initialize and load the per-CPU TSS and IDT</span><span class="token keyword">void</span><span class="token function">trap_init_percpu</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Setup a TSS so that we get the right stack</span>    <span class="token comment" spellcheck="true">// when we trap to the kernel.</span>    ts<span class="token punctuation">.</span>ts_esp0 <span class="token operator">=</span> KSTACKTOP<span class="token punctuation">;</span>    ts<span class="token punctuation">.</span>ts_ss0 <span class="token operator">=</span> GD_KD<span class="token punctuation">;</span>    ts<span class="token punctuation">.</span>ts_iomb <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Taskstate<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Initialize the TSS slot of the gdt.</span>    gdt<span class="token punctuation">[</span>GD_TSS0 <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SEG16</span><span class="token punctuation">(</span>STS_T32A<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>ts<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Taskstate<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gdt<span class="token punctuation">[</span>GD_TSS0 <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sd_s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Load the TSS selector (like other segment selectors, the</span>    <span class="token comment" spellcheck="true">// bottom three bits are special; we leave them 0)</span>    <span class="token function">ltr</span><span class="token punctuation">(</span>GD_TSS0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Load the IDT</span>    <span class="token function">lidt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idt_pd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>And then it’s about <code>CS:EIP</code>:</p><pre class=" language-pseudocode"><code class="language-pseudocode"> IF IDT gate is 32-bit        THEN            CS:EIP ← Gate(CS:EIP); (* Segment descriptor information also loaded *)        ELSE            IF IDT gate 16-bit                THEN                        CS:IP ← Gate(CS:IP);                        (* Segment descriptor information also loaded *)                ELSE (* 64-bit IDT gate *)                        CS:RIP ← Gate(CS:RIP);                        (* Segment descriptor information also loaded *)            FI;</code></pre><p>Lastly, hardware pushes <code>EFLAGS</code> and <code>errorcode</code>…</p><pre class=" language-pseudocode"><code class="language-pseudocode">    IF IDT gate is 32-bit            THEN                Push(far pointer to old stack);                (* Old SS and ESP, 3 words padded to 4 *)                Push(EFLAGS);                Push(far pointer to return instruction);                (* Old CS and EIP, 3 words padded to 4 *)                Push(ErrorCode); (* If needed, 4 bytes *)</code></pre><p>As a summary, when the <code>INT n</code> instruction is executing, the below steps is followed.</p><ol><li>look up the <code>tr</code> register (<code>tr</code> is similar to <code>cs</code>, <code>ds</code>……) and find the correct entry in <code>gdt</code> according to the immediate number and the base address(looking up table by index!).</li><li><code>gdt[GD_TSS0 &gt;&gt; 3]</code> has the base address of task statement segment through which we can access <code>TSS</code>.</li><li>Load <code>esp0</code> and <code>ss0</code> into register <code>esp</code> and <code>ss</code>.</li><li>push <code>EFLAGS</code>, <code>cs</code>, <code>eip</code>, <code>errorcode</code></li><li>get new <code>cs</code>, <code>eip</code> from <code>IDT entry</code>.</li></ol><p>In contrast, conduct <code>iret</code> is the reverse process!</p><h3 id="4-2-Coding"><a href="#4-2-Coding" class="headerlink" title="4-2 Coding"></a>4-2 Coding</h3><p>We should fill the assembly file <code>trapentry.S</code>. There are two macros named <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code>. The former is used to declare a code block connected with <code>IDT</code> entries with the <code>INT</code> instruction pushing <code>errorcode</code>, and the later will explicitly push <code>0</code> as <code>errorcode</code>!</p><p>By looking up <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm">80386 Programmer’s Reference Manual – Section 9.10 (mit.edu)</a>, we produce code below:</p><pre class=" language-c"><code class="language-c"><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>divide_entry<span class="token punctuation">,</span> T_DIVIDE<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>debug_entry<span class="token punctuation">,</span> T_DEBUG<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>nmi_entry<span class="token punctuation">,</span> T_NMI<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>brkpt_entry<span class="token punctuation">,</span> T_BRKPT<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>oflow_entry<span class="token punctuation">,</span> T_OFLOW<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>bound_entry<span class="token punctuation">,</span> T_BOUND<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>illop_entry<span class="token punctuation">,</span> T_ILLOP<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>device_entry<span class="token punctuation">,</span> T_DEVICE<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>dblflt_entry<span class="token punctuation">,</span> T_DBLFLT<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>tss_entry<span class="token punctuation">,</span> T_TSS<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>segnp_entry<span class="token punctuation">,</span> T_SEGNP<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>stack_entry<span class="token punctuation">,</span> T_STACK<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>gpflt_entry<span class="token punctuation">,</span> T_GPFLT<span class="token punctuation">)</span><span class="token function">TRAPHANDLER</span><span class="token punctuation">(</span>pgflt_entry<span class="token punctuation">,</span> T_PGFLT<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>fperr_entry<span class="token punctuation">,</span> T_FPERR<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>align_entry<span class="token punctuation">,</span> T_ALIGN<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>mchk_entry<span class="token punctuation">,</span> T_MCHK<span class="token punctuation">)</span><span class="token function">TRAPHANDLER_NOEC</span><span class="token punctuation">(</span>simderr_entry<span class="token punctuation">,</span> T_SIMDERR<span class="token punctuation">)</span></code></pre><p> All the code blocks will jump to procedure <code>_alltraps</code>, which should:</p><ol><li>push values to make the stack look like a struct <code>Trapframe</code></li><li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li><li><code>pushl %esp</code> to pass a pointer to the <code>Trapframe</code> as an argument to trap()</li><li><code>call trap</code></li></ol><pre class=" language-assembly"><code class="language-assembly"> .global _alltraps_alltraps:    pushl %ds    pushl %es    pushal    movl $GD_KD, %eax    movw %ax, %ds    movw %ax, %es    pushl %esp    call trap    popal    popl %es    popl %ds    addl $8, %esp    iret</code></pre><p>Don’t forget initialize trap.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">trap_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">struct</span> Segdesc gdt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// LAB 3: Your code here.</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_DIVIDE<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> divide_entry<span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_DEBUG<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> debug_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_NMI<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> nmi_entry<span class="token punctuation">,</span>         <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_BRKPT<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> brkpt_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_OFLOW<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> oflow_entry<span class="token punctuation">,</span>       <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_BOUND<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> bound_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_ILLOP<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> illop_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_DEVICE<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> device_entry<span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_DBLFLT<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> dblflt_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_TSS<span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> tss_entry<span class="token punctuation">,</span>        <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_SEGNP<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> segnp_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_STACK<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> stack_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_GPFLT<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> gpflt_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_PGFLT<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> pgflt_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_FPERR<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">1</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> fperr_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_ALIGN<span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token number">1</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> align_entry<span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_MCHK<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">1</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> mchk_entry<span class="token punctuation">,</span>       <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_SIMDERR<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GD_KT<span class="token punctuation">,</span> simderr_entry<span class="token punctuation">,</span>    <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Per-CPU setup </span>    <span class="token function">trap_init_percpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>That’s all in part One.</p><h3 id="4-3Test-part-One"><a href="#4-3Test-part-One" class="headerlink" title="4-3Test part One"></a>4-3Test part One</h3><p>Let’s <code>make grade</code>.</p><p><img src="/picture/makegrade.png"></p><h2 id="4-Episode"><a href="#4-Episode" class="headerlink" title="4 Episode"></a>4 Episode</h2><p>Let’s play an episode to take a relaxation (x) by recall the whole process how the JOS  running in. After <code>BIOS</code> initially boots up the machine, the control power is given to boot loader. </p><h3 id="4-1-bootloader"><a href="#4-1-bootloader" class="headerlink" title="4-1 bootloader"></a>4-1 bootloader</h3><h4 id="4-1-1-boot-S"><a href="#4-1-1-boot-S" class="headerlink" title="4-1-1 boot.S"></a>4-1-1 <code>boot.S</code></h4><h5 id="4-1-1-1-disable-interrupt-and-set-segment-register"><a href="#4-1-1-1-disable-interrupt-and-set-segment-register" class="headerlink" title="4-1-1-1 disable interrupt and set segment register"></a>4-1-1-1 disable interrupt and set segment register</h5><p>The first instruction is <code>cli</code> in physical address <code>0x7c00</code>. (Because the bios boot the bootloader at <code>0x7c00</code>.) <code>cli</code> is used to disable interrupts and the subsequent <code>cld</code> is used for string operations increment. And then the <code>start</code> clear some important data segment registers, such as <code>ds</code>, <code>es</code>, <code>ss</code>.</p><h5 id="4-1-1-2-enable-A20"><a href="#4-1-1-2-enable-A20" class="headerlink" title="4-1-1-2 enable A20"></a>4-1-1-2 enable A20</h5><p>Next, it enables <code>A20</code>. For backwards compatibility with the earliest PCs, physical address line 20 is tied low, so that addresses higher than <code>1MB</code> wrap around to zero by default. The code undoes this.</p><h5 id="4-1-1-3-switch-to-protected-mode"><a href="#4-1-1-3-switch-to-protected-mode" class="headerlink" title="4-1-1-3 switch to protected mode"></a>4-1-1-3 switch to protected mode</h5><p>The code load <code>gdtr</code> using <code>lgtr</code>. We can see that there are two segments. One is the code segment whose base address is <code>0x0</code> and limit is <code>0xffffffff</code> with permission <code>Executable</code> and <code>readable</code>. Another is the data segment whose base address is also <code>0x0</code> and limit is <code>0xffffffff</code> as well ,but with permission <code>writable</code>.</p><pre class=" language-assembly"><code class="language-assembly"># Bootstrap GDT.p2align 2                                # force 4 byte alignmentgdt:  SEG_NULL                # null seg  SEG(STA_X|STA_R, 0x0, 0xffffffff)    # code seg  SEG(STA_W, 0x0, 0xffffffff)            # data seggdtdesc:  .word   0x17                            # sizeof(gdt) - 1  .long   gdt                             # address gdt</code></pre><p>The following is to set <code>PE</code> bit of <code>CR0</code>. It means that the system switched from real to protected mode, using a bootstrap <code>GDT</code> and segment translation that makes virtual addresses identical to their physical addresses, so that the effective memory map does not change during the switch. And instruction’s address is the same as the one before switching. The <code>ljmp</code> loads <code>PROT_MODE_DSEG</code> to <code>cs</code> and jumps to the <code>protcseg</code> procedure.</p><h5 id="4-1-1-4-Protcseg"><a href="#4-1-1-4-Protcseg" class="headerlink" title="4-1-1-4 Protcseg"></a>4-1-1-4 Protcseg</h5><p>It set <code>ds</code>, <code>es</code>, <code>fs</code>, <code>gs</code>, <code>ss</code> to <code>PROT_MODE_DSEG</code>. And then it makes <code>esp</code> point at <code>start</code>, which makes the space in front of <code>start</code> the temporary stack. And then call <code>bootmain</code> edited in <code>Clang</code>.</p><h4 id="4-1-2-bootmain"><a href="#4-1-2-bootmain" class="headerlink" title="4-1-2 bootmain"></a>4-1-2 <code>bootmain</code></h4><p><code>bootmain</code> is used to load the <code>ELF</code> into the memory. And jump to the entry by a function pointer:</p><pre><code>    ((void (*)(void)) (ELFHDR-&gt;e_entry))();</code></pre><h3 id="4-2-Kernel"><a href="#4-2-Kernel" class="headerlink" title="4-2 Kernel"></a>4-2 Kernel</h3><h4 id="4-2-1-entry-S"><a href="#4-2-1-entry-S" class="headerlink" title="4-2-1 entry.S"></a>4-2-1 <code>entry.S</code></h4><h5 id="4-2-1-1-entry"><a href="#4-2-1-1-entry" class="headerlink" title="4-2-1-1 entry"></a>4-2-1-1 entry</h5><p>By now, we haven’t set up virtual memory yet, so we’re running from the physical address the boot loader loaded the kernel at: <code>1MB</code>. However, the C code is linked to run at <code>KERNBASE + 1MB</code>. Hence, we set up a trivial page directory that translates virtual address <code>[KERNBASE, KERNBASE + 4MB)</code> to physical addresses <code>[0, 4MB)</code>. This 4MB region will be sufficient until we set up our read page table in <code>mem_init</code>.</p><p>First, we load the physical address of <code>entry_pgdir</code> into <code>cr3</code>. <code>entry_pgdir</code> is defined in <code>entrypgdir.c</code>. And then turn on paging by set <code>PG</code> bit in <code>cr0</code>. Note that the subsequent two instructions’ virtual address is both in <code>[KERNBASE, KERNBASE + 4MB)</code> and <code>[0, 4MB)</code>, and we can look through <code>entrypgdir.c</code> for details. These two instructions make the low <code>eip</code> ( in<code>[0, 4MB)</code>) become in high address ( in <code>[KERNBASE, KERNBASE + 4MB)</code>), But they are both map into the same physical addresses.</p><h5 id="4-2-1-2-relocated"><a href="#4-2-1-2-relocated" class="headerlink" title="4-2-1-2 relocated"></a>4-2-1-2 relocated</h5><p>The procedure clear the frame pointer register <code>ebp</code> first so that the monitor’s <code>backtrace</code> can work correctly. And then it set the stack pointer <code>esp</code>. The code below is the stack region.</p><pre class=" language-assembly"><code class="language-assembly">.data#################################################################### boot stack###################################################################    .p2align    PGSHIFT        # force page alignment    .globl        bootstackbootstack:    .space        KSTKSIZE    .globl        bootstacktop   bootstacktop:</code></pre><p>Then, it jumps to <code>i386_init</code> in C code.</p><h4 id="4-2-2-i386-init"><a href="#4-2-2-i386-init" class="headerlink" title="4-2-2 i386_init"></a>4-2-2 <code>i386_init</code></h4><p>The function is intended for do some initialization. First, clear the uninitialized global data (BSS) section of our program. This ensures that all static/global variables start out zero.</p><h5 id="4-2-2-1"><a href="#4-2-2-1" class="headerlink" title="4-2-2-1"></a>4-2-2-1</h5><p>And then initialize the console by <code>cons_init</code>. All the functions are located in <code>console.c</code></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// initialize the console devices</span><span class="token keyword">void</span><span class="token function">cons_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">cga_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kbd_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">serial_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>serial_exists<span class="token punctuation">)</span>        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"Serial port does not exist!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4-2-3-pmap-c"><a href="#4-2-3-pmap-c" class="headerlink" title="4-2-3 pmap.c"></a>4-2-3 <code>pmap.c</code></h4><p>After initialization of the console, <code>mem_init</code> should enter on the stage. Firstly, it use <code>i386_detect_memory</code> to get some basic information. And then allocate space for Kernel’s page directory, and map the virtual address space. Below is the memory layout:</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * Virtual memory map:                                Permissions *                                                    kernel/user * *    4 Gig -------->  +------------------------------+ *                     |                              | RW/-- *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *                     :              .               : *                     :              .               : *                     :              .               : *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/-- *                     |                              | RW/-- *                     |   Remapped Physical Memory   | RW/-- *                     |                              | RW/-- *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+ *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   | *                     | - - - - - - - - - - - - - - -|                   | *                     |      Invalid Memory (*)      | --/--  KSTKGAP    | *                     +------------------------------+                   | *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   | *                     | - - - - - - - - - - - - - - -|                 PTSIZE *                     |      Invalid Memory (*)      | --/--  KSTKGAP    | *                     +------------------------------+                   | *                     :              .               :                   | *                     :              .               :                   | *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+ *                     |       Memory-mapped I/O      | RW/--  PTSIZE * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE *    UVPT      ---->  +------------------------------+ 0xef400000 *                     |          RO PAGES            | R-/R-  PTSIZE *    UPAGES    ---->  +------------------------------+ 0xef000000 *                     |           RO ENVS            | R-/R-  PTSIZE * UTOP,UENVS ------>  +------------------------------+ 0xeec00000 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE *                     +------------------------------+ 0xeebff000 *                     |       Empty Memory (*)       | --/--  PGSIZE *    USTACKTOP  --->  +------------------------------+ 0xeebfe000 *                     |      Normal User Stack       | RW/RW  PGSIZE *                     +------------------------------+ 0xeebfd000 *                     |                              | *                     |                              | *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *                     .                              . *                     .                              . *                     .                              . *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| *                     |     Program Data &amp; Heap      | *    UTEXT -------->  +------------------------------+ 0x00800000 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE *                     |                              | *    UTEMP -------->  +------------------------------+ 0x00400000      --+ *                     |       Empty Memory (*)       |                   | *                     | - - - - - - - - - - - - - - -|                   | *                     |  User STAB Data (optional)   |                 PTSIZE *    USTABDATA ---->  +------------------------------+ 0x00200000        | *                     |       Empty Memory (*)       |                   | *    0 ------------>  +------------------------------+                 --+ * * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped. *     "Empty Memory" is normally unmapped, but user programs may map pages *     there if desired.  JOS user programs map pages temporarily at UTEMP. */</span></code></pre><p>We allocate space for the page array and the environment array. After allocating space for all the basic structures, we initialize the page array. the first page and pages between <code>IOPHYSMEM(0x000A0000)</code> and <code>EXTPHYSMEM(0x00100000)</code> are occupied and shouldn’t be replaced or allocated anymore.</p><p><img src="/picture/layout.png"></p><p>After the initialization of physical pages, we should set up virtual memory：</p><ol><li>Map <code>pages</code> read-only by the user at linear address <code>UPAGES</code></li><li>Map the <code>envs</code> array read-only by the user at linear address <code>UENVS</code></li><li>Use the physical memory that <code>bootstack</code> refers to as the kernel stack.  The kernel stack grows down from virtual address <code>KSTACKTOP</code>. We consider the entire range from <code>[KSTACKTOP-PTSIZE, KSTACKTOP)</code> to be the kernel stack.</li><li>Map all of physical memory at KERNBASE. The VA range <code>[KERNBASE, 2^32)</code> should map to the PA range <code>[0, 2^32 - KERNBASE)</code>. We might not have <code>2^32 - KERNBASE</code> bytes of physical memory, but we just set up the mapping anyway.</li></ol><p>Having mapped virtual memory, we switch from the minimal entry page directory to the full <code>kern_pgdir</code> page table we just created. Our instruction pointer should be somewhere between <code>KERNBASE</code> and <code>KERNBASE + 4MB</code> right now, which is mapped the same way by both page tables.</p><pre class=" language-c"><code class="language-c"><span class="token function">lcr3</span><span class="token punctuation">(</span><span class="token function">PADDR</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>And then turn on all the flags of <code>cr0</code> we need.</p><p>Now,we finished the initialization of virtual memory layout.</p><h4 id="4-2-4-env-init"><a href="#4-2-4-env-init" class="headerlink" title="4-2-4 env_init"></a>4-2-4 <code>env_init</code></h4><p>We set up the environment free list by a chain. And Load new <code>GDT</code> and segment descriptors using <code>env_init_percpu</code>. Read the comments if you want more details.</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Global descriptor table.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Set up global descriptor table (GDT) with separate segments for</span><span class="token comment" spellcheck="true">// kernel mode and user mode.  Segments serve many purposes on the x86.</span><span class="token comment" spellcheck="true">// We don't use any of their memory-mapping capabilities, but we need</span><span class="token comment" spellcheck="true">// them to switch privilege levels. </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// The kernel and user segments are identical except for the DPL.</span><span class="token comment" spellcheck="true">// To load the SS register, the CPL must equal the DPL.  Thus,</span><span class="token comment" spellcheck="true">// we must duplicate the segments for the user and the kernel.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// In particular, the last argument to the SEG macro used in the</span><span class="token comment" spellcheck="true">// definition of gdt specifies the Descriptor Privilege Level (DPL)</span><span class="token comment" spellcheck="true">// of that descriptor: 0 for kernel and 3 for user.</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">struct</span> Segdesc gdt<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 0x0 - unused (always faults -- for trapping NULL far pointers)</span>    SEG_NULL<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 0x8 - kernel code segment</span>    <span class="token punctuation">[</span>GD_KT <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SEG</span><span class="token punctuation">(</span>STA_X <span class="token operator">|</span> STA_R<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xffffffff</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 0x10 - kernel data segment</span>    <span class="token punctuation">[</span>GD_KD <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SEG</span><span class="token punctuation">(</span>STA_W<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xffffffff</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 0x18 - user code segment</span>    <span class="token punctuation">[</span>GD_UT <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SEG</span><span class="token punctuation">(</span>STA_X <span class="token operator">|</span> STA_R<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xffffffff</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 0x20 - user data segment</span>    <span class="token punctuation">[</span>GD_UD <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SEG</span><span class="token punctuation">(</span>STA_W<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xffffffff</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 0x28 - tss, initialized in trap_init_percpu()</span>    <span class="token punctuation">[</span>GD_TSS0 <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> SEG_NULL<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Pseudodesc gdt_pd <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>gdt<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> gdt<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="4-2-5-trap-init"><a href="#4-2-5-trap-init" class="headerlink" title="4-2-5 trap_init"></a>4-2-5 <code>trap_init</code></h4><p>we should now have the basic information we need in order to set up the IDT and handle exceptions in JOS. For now, we will set up the IDT to handle interrupt vectors <code>0-31</code> (the processor exceptions).</p><p>Exceptions and interrupts are both “protected control transfers,” which cause the processor to switch from user to kernel mode (CPL=0) without giving the user-mode code any opportunity to interfere with the functioning of the kernel or other environments. In Intel’s terminology, an <em>interrupt</em> is a protected control transfer that is caused by an asynchronous event usually external to the processor, such as notification of external device I/O activity. An <em>exception</em>, in contrast, is a protected control transfer caused synchronously by the currently running code, for example due to a divide by zero or an invalid memory access.</p><p>In order to ensure that these protected control transfers are actually <em>protected</em>, the processor’s interrupt/exception mechanism is designed so that the code currently running when the interrupt or exception occurs <em>does not get to choose arbitrarily where the kernel is entered or how</em>. Instead, the processor ensures that the kernel can be entered only under carefully controlled conditions. On the x86, two mechanisms work together to provide this protection:</p><ol><li><p><strong>The Interrupt Descriptor Table.</strong> The processor ensures that interrupts and exceptions can only cause the kernel to be entered at a few specific, well-defined entry-points <em>determined by the kernel itself</em>, and not by the code running when the interrupt or exception is taken.</p><p>The x86 allows up to 256 different interrupt or exception entry points into the kernel, each with a different <em>interrupt vector</em>. A vector is a number between 0 and 255. An interrupt’s vector is determined by the source of the interrupt: different devices, error conditions, and application requests to the kernel generate interrupts with different vectors. The CPU uses the vector as an index into the processor’s <em>interrupt descriptor table</em> (IDT), which the kernel sets up in kernel-private memory, much like the GDT. From the appropriate entry in this table the processor loads:</p><ul><li>the value to load into the instruction pointer (<code>EIP</code>) register, pointing to the kernel code designated to handle that type of exception.</li><li>the value to load into the code segment (<code>CS</code>) register, which includes in bits 0-1 the privilege level at which the exception handler is to run. (In JOS, all exceptions are handled in kernel mode, privilege level 0.)</li></ul></li><li><p><strong>The Task State Segment.</strong> The processor needs a place to save the <em>old</em> processor state before the interrupt or exception occurred, such as the original values of <code>EIP</code> and <code>CS</code> before the processor invoked the exception handler, so that the exception handler can later restore that old state and resume the interrupted code from where it left off. But this save area for the old processor state must in turn be protected from unprivileged user-mode code; otherwise buggy or malicious user code could compromise the kernel.</p><p>For this reason, when an x86 processor takes an interrupt or trap that causes a privilege level change from user to kernel mode, it also switches to a stack in the kernel’s memory. A structure called the <em>task state segment</em> (TSS) specifies the segment selector and address where this stack lives. The processor pushes (on this new stack) <code>SS</code>, <code>ESP</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>, and an optional error code. Then it loads the <code>CS</code> and <code>EIP</code> from the interrupt descriptor, and sets the <code>ESP</code> and <code>SS</code> to refer to the new stack.</p><p>Although the TSS is large and can potentially serve a variety of purposes, JOS only uses it to define the kernel stack that the processor should switch to when it transfers from user to kernel mode. Since “kernel mode” in JOS is privilege level 0 on the x86, the processor uses the <code>ESP0</code> and <code>SS0</code> fields of the TSS to define the kernel stack when entering kernel mode. JOS doesn’t use any other TSS fields.</p></li></ol><p>There is an example in the <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab3/#An-Example">lab guide</a>. And for more details, please refer to the <strong>reference 7</strong>. </p><h4 id="4-2-6-Create-a-user-environment"><a href="#4-2-6-Create-a-user-environment" class="headerlink" title="4-2-6 Create a user environment"></a>4-2-6 <code>Create a user environment</code></h4><p>All preparatory work is done, so we can create a user environment. </p><h5 id="4-2-6-1-a-macro"><a href="#4-2-6-1-a-macro" class="headerlink" title="4-2-6-1 a macro"></a>4-2-6-1 <code>a macro</code></h5><p>macro <code>ENV_CREATE(x, type)</code> is used for sticking the string together and call <code>env_create</code>. </p><h5 id="4-2-6-2-env-create"><a href="#4-2-6-2-env-create" class="headerlink" title="4-2-6-2 env_create"></a>4-2-6-2 <code>env_create</code></h5><p>it allocates a <code>env</code> structure for the user environment first. And load its ELF file into the memory. (In fact, it move it from kernel text to another position.) </p><h5 id="4-2-6-3-load-icode"><a href="#4-2-6-3-load-icode" class="headerlink" title="4-2-6-3 load_icode"></a>4-2-6-3 <code>load_icode</code></h5><p>Its duty is to move the loadable section to the correct location. The detail is in the code!</p><h5 id="4-2-6-4-env-run"><a href="#4-2-6-4-env-run" class="headerlink" title="4-2-6-4 env_run"></a>4-2-6-4 <code>env_run</code></h5><p>It loads the page directory’s base address into <code>cr3</code>. And change the state of the environment. Then pop the registers and conduct <code>iret</code>.</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm">80386 Programmer’s Reference Manual – Section 9.10 (mit.edu)</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_09.htm">80386 Programmer’s Reference Manual – Section 9.9 (mit.edu)</a></li><li><a href="https://blog.csdn.net/elv/article/details/4140532">实模式、保护模式、虚拟8086模式和IA-32e模式_elv的专栏-CSDN博客</a></li><li><a href="https://www.felixcloutier.com/x86/intn:into:int3:int1">INT n/INTO/INT3/INT1 — Call to Interrupt Procedure (felixcloutier.com)</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_06.htm">80386 Programmer’s Reference Manual – Section 9.6 (mit.edu)</a></li><li><a href="https://stackoverflow.com/questions/3425085/the-difference-between-call-gate-interrupt-gate-trap-gate">x86 - The difference between Call Gate, Interrupt Gate, Trap Gate? - Stack Overflow</a></li><li>《计算机系统基础》（第二版）（袁春风）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6-828-note-lab2</title>
      <link href="/2021/07/19/MIT6-828-note-lab2/"/>
      <url>/2021/07/19/MIT6-828-note-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="一-开篇"><a href="#一-开篇" class="headerlink" title="一.开篇"></a>一.开篇</h2><p><code>Lab2</code>的代码量要明显多于<code>Lab1</code>，可以说是难度层层递进，这个实验主要是开启分页机制，打开虚拟地址机制。这个正是我在操作系统课上没有锻炼到的地方！话不多说，我的思考过程在下面。</p><h2 id="二-Lab2"><a href="#二-Lab2" class="headerlink" title="二.Lab2"></a>二.Lab2</h2><h3 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h3><h4 id="1-1怎么开的保护模式？"><a href="#1-1怎么开的保护模式？" class="headerlink" title="1-1怎么开的保护模式？"></a>1-1怎么开的保护模式？</h4><p>我们在合并了<code>Lab1</code>之后，先来回顾一下操作系统启动的过程。</p><p>我们从<code>Kernel</code>开始，首先进入<code>entry.S</code>，然后把一个简易的页表加载上<code>cr3</code>去，这个页表的作用是把内存的<code>[KERNBASE, KERNBASE+4MB)</code>和<code>[0, 4MB)</code>都映射到物理地址<code>[0, 4MB)</code>上去！为什么要把虚拟地址<code>[0, 4MB)</code>也映射上去呢？原因是在我开启分页之后，就从实地址模式变成了保护模式，<code>CPU</code>解析地址的方式就变化了。而我们下面还有两行汇编指令的地址位于低地址，而此时的<code>EIP</code>仍然位于低地址部分！这样开启分页之后，才可以获取到正确的指令！然后通过<code>jmp</code>指令跳转到虚拟地址<code>0xf0000000</code>地址的位置！</p><pre class=" language-assembly"><code class="language-assembly">mov    $relocated, %eax    jmp    *%eax</code></pre><h4 id="1-2设置简易的栈"><a href="#1-2设置简易的栈" class="headerlink" title="1-2设置简易的栈"></a>1-2设置简易的栈</h4><p>下面<code>relocated</code>的作用是初始化一下栈区，从下面的代码可以看出，栈区的大小是<code>KSTKSIZE</code>，栈区的栈顶位于高地址，即<code>bootstacktop</code></p><pre class=" language-assembly"><code class="language-assembly">    .p2align    PGSHIFT        # force page alignment    .globl        bootstackbootstack:    .space        KSTKSIZE    .globl        bootstacktop   bootstacktop:</code></pre><p>随即把栈顶指针赋值给<code>esp</code>，调用<code>i386_init</code>函数进行进一步初始化！</p><h4 id="1-3初始化函数"><a href="#1-3初始化函数" class="headerlink" title="1-3初始化函数"></a>1-3初始化函数</h4><p>进入初始化函数，我们看见第一件事情就是初始化<code>.bss</code>段，初始化为0，因为在<code>ELF</code>文件里面，这个段只标出了大小，并不分配空间。</p><p>然后进行一些显示，输入，输出等初始化活动，最后进入<code>mem_init</code>，这个就是本次实验的核心函数！</p><h3 id="2-开始coding"><a href="#2-开始coding" class="headerlink" title="2.开始coding"></a>2.开始coding</h3><h4 id="2-1进入内存初始化！"><a href="#2-1进入内存初始化！" class="headerlink" title="2-1进入内存初始化！"></a>2-1进入内存初始化！</h4><p>进入内存初始化函数之后，我们先检测以下硬件提供的内存，这个工作由<code>i386_detect_memory</code>函数来完成。</p><h4 id="2-2为必要的DS分配内存"><a href="#2-2为必要的DS分配内存" class="headerlink" title="2-2为必要的DS分配内存"></a>2-2为必要的DS分配内存</h4><p>继续往下看，看见是给<code>kern_pgdir</code>变量赋值，我们可以看见它的定义是一个全局变量，表示的是页目录的首地址！我们可以知道，页目录所对应逻辑地址中的10比特，那么一共有页目录<code>2^10=1024</code>个！而一个页目录项的大小是4字节，所以一个页目录占用的大小刚好是一个页面的大小！所以我们用<code>boot_alloc</code>函数来对页目录进行分配空间（后面会提到这个函数具体干啥的）。分配完之后，还要清零。</p><p>下面一步是分配一个<code>pages</code>数组，每一项对应一个物理页框，我们可以得知一共有<code>npages</code>个物理页框，所以代码如下：</p><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////</span>    <span class="token comment" spellcheck="true">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span>    <span class="token comment" spellcheck="true">// The kernel uses this array to keep track of physical pages: for</span>    <span class="token comment" spellcheck="true">// each physical page, there is a corresponding struct PageInfo in this</span>    <span class="token comment" spellcheck="true">// array.  'npages' is the number of physical pages in memory.  Use memset</span>    <span class="token comment" spellcheck="true">// to initialize all fields of each struct PageInfo to 0.</span>    <span class="token comment" spellcheck="true">// Your code goes here:</span>    pages<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> PageInfo <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">boot_alloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> PageInfo<span class="token punctuation">)</span> <span class="token operator">*</span> npages<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pages<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> PageInfo<span class="token punctuation">)</span> <span class="token operator">*</span> npages<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>现在既然关于页面和页目录的数据结构分配完了，我们就对这些内存进行初始化！</p><h4 id="2-3初始化分页"><a href="#2-3初始化分页" class="headerlink" title="2-3初始化分页"></a>2-3初始化分页</h4><p>对于<code>page_init</code>函数，我们要做的是把已经分配出去的页框和空闲页框分类，空闲页框用一个链表串起来！</p><p>在注释里已经提示我们哪里是可以分配，哪里是不可以分配的</p><ol><li> Mark physical page 0 as in use. This way we preserve the real-mode IDT and BIOS structures in case we ever need them.  (Currently we don’t, but…)</li><li>The rest of base memory, <code>[PGSIZE, npages_basemem * PGSIZE)</code> is free.</li><li>Then comes the IO hole <code>[IOPHYSMEM, EXTPHYSMEM)</code>, which must never be allocated.</li><li>Then extended memory <code>[EXTPHYSMEM, ...)</code>.Some of it is in use, some is free. Where is the kernel in physical memory?  Which pages are already in use for page tables and other data structures?</li></ol><p>我们如何理解呢？首先，0号物理页已经被<code>BIOS</code>和引导程序之类的代码占领了（以后我们还要用的），所以0号页面必然不可能是空闲的。从1号物理页面到<code>base_memory</code>的末尾，都是空闲的（也就是图片对应的<code>Low Memory</code>），可以从检测函数的输出看出一共有<code>640KB</code>，然后剩下的就是<code>ext_memory</code>，就很多了。</p><p><code>IOPHYSMEM=0x000A0000，EXTPHYSMEM=0x00100000</code>，这两者中间的是关于<code>BIOS</code>和一些显示有关的区域，不可以被分配！从<code>0x100000</code>开始的部分，就是我们自由分配的部分，有的是空闲有的却不是，但是根据我们刚开始用<code>boot_alloc</code>函数分配的规则来看，我们是按照顺序分配的，所以在<code>boot_alloc(0)</code>之前（<code>boot_alloc(0)</code>返回值是第一个以页为对齐标准的空闲的物理内存的地址！）所以在<code>EXTPHYSMEM</code>和<code>boot_alloc(0)</code>之间的内存区域也不是空闲的，而且是系统必要的数据，比如页面结构<code>PageInfo</code>，页目录，内核代码！</p><p><img src="/picture/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png" alt="物理内存"></p><p>根据上面的提示，我们对物理内存进行了庖丁解牛。于是，我写出了如下优美的代码（x）：</p><p>需要注意的是空闲页面链表使用的是头插法！</p><pre class=" language-c"><code class="language-c">    page_free_list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    size_t i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> npages<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>            i<span class="token operator">==</span><span class="token number">0</span>         <span class="token operator">||</span>            <span class="token punctuation">(</span>                <span class="token function">page2pa</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">>=</span> IOPHYSMEM                 <span class="token operator">&amp;&amp;</span>                 <span class="token function">page2pa</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> EXTPHYSMEM            <span class="token punctuation">)</span>         <span class="token operator">||</span>            <span class="token punctuation">(</span>                <span class="token function">page2pa</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">>=</span> EXTPHYSMEM                 <span class="token operator">&amp;&amp;</span>                <span class="token function">page2kva</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">boot_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">{</span>            pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>        page_free_list <span class="token operator">=</span> <span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//cprintf("pagefree %d",i);</span>    <span class="token punctuation">}</span></code></pre><h4 id="2-4关于物理页的操作"><a href="#2-4关于物理页的操作" class="headerlink" title="2-4关于物理页的操作"></a>2-4关于物理页的操作</h4><h5 id="2-4-1-page-alloc"><a href="#2-4-1-page-alloc" class="headerlink" title="2-4-1 page_alloc"></a>2-4-1 page_alloc</h5><p>这个函数就是为了分配一个物理页，从今往后代替<code>boot_alloc</code>函数。</p><p>我们已经在<code>page_init</code>函数里面初始化了空闲物理页链表，这就说明我们如果要分配一个物理页面，就要在空闲页面链表里面找。当链表头是<code>NULL</code>的时候，就说明页面分配完了。还有如果置零标志位为1，那么要初始清零！</p><p>分配物理页的时候并不需要给<code>ref+1</code>，因为它还没有和一个虚拟页面进行关联！</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span><span class="token comment" spellcheck="true">// returned physical page with '\0' bytes.  Does NOT increment the reference</span><span class="token comment" spellcheck="true">// count of the page - the caller must do these if necessary (either explicitly</span><span class="token comment" spellcheck="true">// or via page_insert).</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Be sure to set the pp_link field of the allocated page to NULL so</span><span class="token comment" spellcheck="true">// page_free can check for double-free bugs.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Returns NULL if out of free memory.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Hint: use page2kva and memset</span><span class="token keyword">struct</span> PageInfo <span class="token operator">*</span><span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token keyword">int</span> alloc_flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//cprintf("Entry page alloc\n");</span>    <span class="token comment" spellcheck="true">//out of memory</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>page_free_list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> PageInfo<span class="token operator">*</span> ret <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>    page_free_list <span class="token operator">=</span> page_free_list <span class="token operator">-></span> pp_link<span class="token punctuation">;</span>    ret <span class="token operator">-></span> pp_link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>alloc_flags <span class="token operator">&amp;</span> ALLOC_ZERO<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token function">page2kva</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-4-2-page-free"><a href="#2-4-2-page-free" class="headerlink" title="2-4-2 page_free"></a>2-4-2 page_free</h5><p>这个函数用来把物理页框归还到空闲页框链表中。使用头插法！</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Return a page to the free list.</span><span class="token comment" spellcheck="true">// (This function should only be called when pp->pp_ref reaches 0.)</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">void</span><span class="token function">page_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> PageInfo <span class="token operator">*</span>pp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    <span class="token comment" spellcheck="true">// Hint: You may want to panic if pp->pp_ref is nonzero or</span>    <span class="token comment" spellcheck="true">// pp->pp_link is not NULL.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pp<span class="token operator">-></span>pp_ref <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> pp<span class="token operator">-></span>pp_link <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"page_free: pp is not a page in use\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pp<span class="token operator">-></span>pp_link <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>    page_free_list <span class="token operator">=</span> pp<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span></code></pre><h5 id="2-4-3-page-decref"><a href="#2-4-3-page-decref" class="headerlink" title="2-4-3 page_decref"></a>2-4-3 page_decref</h5><p>这个函数用来在删除映射过程中，衰减页框的引用位，当没有被引用时，就释放这个页框！</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Decrement the reference count on a page,</span><span class="token comment" spellcheck="true">// freeing it if there are no more refs.</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">void</span><span class="token function">page_decref</span><span class="token punctuation">(</span><span class="token keyword">struct</span> PageInfo<span class="token operator">*</span> pp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>pp<span class="token operator">-></span>pp_ref <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">page_free</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-5关于映射"><a href="#2-5关于映射" class="headerlink" title="2-5关于映射"></a>2-5关于映射</h4><h5 id="2-5-1-page-walk"><a href="#2-5-1-page-walk" class="headerlink" title="2-5-1 page_walk"></a>2-5-1 page_walk</h5><p>这个函数刚开始我没有理解，后来在一遍遍反复阅读中我知道了它的作用：返回值是虚拟地址<code>va</code>对应的页表项的地址！（虚拟地址）</p><p>因为这个虚拟地址对应的页表页可能还没有用到，所以就没有被映射，所以需要对它分配一个物理页框，同时让页目录表项填写这个物理页框的物理地址，然后把物理页框中对应页表项的地址作为返回值。</p><p>那么如何判断页表项对应的物理页框是否存在呢，那就是通过<code>present</code>位来进行判断！当对应页目录项的存在位为0，说明对应页目录表项还不存在。这时再根据<code>create</code>位来确认是否要创建新的表项。</p><p>如果存在的话，那就直接返回对应的页表项地址即可！</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Given 'pgdir', a pointer to a page directory, pgdir_walk returns</span><span class="token comment" spellcheck="true">// a pointer to the page table entry (PTE) for linear address 'va'.</span><span class="token comment" spellcheck="true">// This requires walking the two-level page table structure.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// The relevant page table page might not exist yet.</span><span class="token comment" spellcheck="true">// If this is true, and create == false, then pgdir_walk returns NULL.</span><span class="token comment" spellcheck="true">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span><span class="token comment" spellcheck="true">//    - If the allocation fails, pgdir_walk returns NULL.</span><span class="token comment" spellcheck="true">//    - Otherwise, the new page's reference count is incremented,</span><span class="token comment" spellcheck="true">//    the page is cleared,</span><span class="token comment" spellcheck="true">//    and pgdir_walk returns a pointer into the new page table page.</span>pte_t <span class="token operator">*</span><span class="token function">pgdir_walk</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>va<span class="token punctuation">,</span> <span class="token keyword">int</span> create<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    <span class="token keyword">int</span> pde_idx <span class="token operator">=</span> <span class="token function">PDX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pte_idx <span class="token operator">=</span> <span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    pte_t <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> present <span class="token operator">=</span> pgdir<span class="token punctuation">[</span>pde_idx<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_P<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>present <span class="token operator">&amp;&amp;</span> create <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//cprintf("ptep ");</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>present <span class="token operator">&amp;&amp;</span> create <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">struct</span> PageInfo<span class="token operator">*</span> pg <span class="token operator">=</span> <span class="token function">page_alloc</span><span class="token punctuation">(</span>ALLOC_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//cprintf("ptep ");</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pg <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            pg<span class="token operator">-></span>pp_ref<span class="token operator">++</span><span class="token punctuation">;</span>            ptep <span class="token operator">=</span> <span class="token punctuation">(</span>pte_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">page2pa</span><span class="token punctuation">(</span>pg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//cprintf("ptep = %x\n", ptep);</span>            pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">page2pa</span><span class="token punctuation">(</span>pg<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_W <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>ptep<span class="token punctuation">[</span><span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        ptep <span class="token operator">=</span> <span class="token punctuation">(</span>pte_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">[</span>pde_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//cprintf("ptep = %x\n", ptep);</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>ptep<span class="token punctuation">[</span><span class="token function">PTX</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-5-2-page-insert"><a href="#2-5-2-page-insert" class="headerlink" title="2-5-2 page_insert"></a>2-5-2 page_insert</h5><p>这个函数用来进行一个映射，给定页目录表项，给定物理页框（当然是<code>page_alloc</code>分配出来的），还有保护位的参数。我们需要做的是把虚拟地址对应的页面映射到物理页框上！</p><p>我们首先要做的就是先获取对应页表项的地址，然后看看是否已经映射了，如果这片虚拟地址已经映射在同一个物理页框上，那么就不可以<code>remove</code>掉，因为一旦<code>remove</code>掉就可能分配不到同一个页框！！！（因为如果有多个进程占用页框）但是可能需要更改标志位，所以先把标志位清零再更改标志位。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span><span class="token function">page_insert</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> <span class="token keyword">struct</span> PageInfo <span class="token operator">*</span>pp<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>va<span class="token punctuation">,</span> <span class="token keyword">int</span> perm<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    pte_t <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token function">pgdir_walk</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptep <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_MEM<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">page2pa</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token operator">*</span>ptep <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0xffe</span><span class="token punctuation">;</span>            <span class="token operator">*</span>ptep <span class="token operator">|</span><span class="token operator">=</span> perm <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>            <span class="token function">page_remove</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token function">page2pa</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span> <span class="token operator">|</span> perm <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span>    pp <span class="token operator">-></span> pp_ref<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-5-3-page-lookup"><a href="#2-5-3-page-lookup" class="headerlink" title="2-5-3 page_lookup"></a>2-5-3 page_lookup</h5><p>这个函数是用来查找对应虚拟地址是否已经映射到对应的物理页框中去，如果已经映射返回对应的<code>PageInfo</code>结构，否则返回<code>NULL</code>，并且把<code>pte</code>存入<code>pte_store</code>中去。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> PageInfo <span class="token operator">*</span><span class="token function">page_lookup</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>va<span class="token punctuation">,</span> pte_t <span class="token operator">*</span><span class="token operator">*</span>pte_store<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    pte_t<span class="token operator">*</span> ptep <span class="token operator">=</span> <span class="token function">pgdir_walk</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptep <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pte_store<span class="token punctuation">)</span><span class="token operator">*</span>pte_store <span class="token operator">=</span> ptep<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//cprintf("%x\n", PTE_ADDR(*ptep));</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         <span class="token keyword">return</span> <span class="token function">pa2page</span><span class="token punctuation">(</span><span class="token function">PTE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-5-4-page-remove"><a href="#2-5-4-page-remove" class="headerlink" title="2-5-4 page_remove"></a>2-5-4 page_remove</h5><p>这个函数是移去映射，先关闭<code>va</code>对应的<code>tlb</code>，再对对应的<code>PTE</code>清零！最后别忘了减小<code>ref</code>。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">page_remove</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>va<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    <span class="token function">tlb_invalidate</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    pte_t <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> PageInfo <span class="token operator">*</span>pg <span class="token operator">=</span> <span class="token function">page_lookup</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pg <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">page_decref</span><span class="token punctuation">(</span>pg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-5-5-boot-map-region"><a href="#2-5-5-boot-map-region" class="headerlink" title="2-5-5 boot_map_region"></a>2-5-5 boot_map_region</h5><p>映射函数，把<code>[va, va + size)</code>对应的虚拟内存映射到<code>[pa, pa + size)</code>物理内存上。我最开始采用的方法是对内存直接比较，但是会出bug，后来改成按照页面的个数进行映射，这样就不会出现问题（并且<code>va</code>，<code>pa</code>，<code>size</code>都是按照页面大小对齐的）。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span><span class="token comment" spellcheck="true">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span><span class="token comment" spellcheck="true">// va and pa are both page-aligned.</span><span class="token comment" spellcheck="true">// Use permission bits perm|PTE_P for the entries.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// This function is only intended to set up the ``static'' mappings</span><span class="token comment" spellcheck="true">// above UTOP. As such, it should *not* change the pp_ref field on the</span><span class="token comment" spellcheck="true">// mapped pages.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Hint: the TA solution uses pgdir_walk</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">boot_map_region</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> uintptr_t va<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> physaddr_t pa<span class="token punctuation">,</span> <span class="token keyword">int</span> perm<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fill this function in</span>    <span class="token keyword">int</span> pgn <span class="token operator">=</span> size <span class="token operator">/</span> PGSIZE<span class="token punctuation">;</span>    pte_t <span class="token operator">*</span>ptep<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pgn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ptep <span class="token operator">=</span> <span class="token function">pgdir_walk</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>va<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ptep<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//cprintf("success map\n");</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">*</span>ptep <span class="token operator">=</span> pa <span class="token operator">|</span> perm <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span>        va <span class="token operator">+</span><span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>         pa <span class="token operator">+</span><span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//cprintf("success map\n");</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-6虚拟空间映射"><a href="#2-6虚拟空间映射" class="headerlink" title="2-6虚拟空间映射"></a>2-6虚拟空间映射</h4><p>下面在<code>mem_init</code>里面，我们映射了三个不同的区域。</p><p>先映射页目录，对于应用程序的内核和用户空间，都是只读的权限，所以是<code>PTE_U</code>（这段代码是给出来的，并不是自己写的）</p><pre class=" language-c"><code class="language-c">kern_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span></code></pre><p>映射页框数据结构<code>PageInfo</code>，把虚拟地址空间<code>UPAGES</code>映射到<code>pages</code>所在数组的地址空间，这样<code>kernel</code>可以通过内核空间对它可以修改。但是用户却不可以通过用户进行修改，只能读！</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////</span>    <span class="token comment" spellcheck="true">// Now we set up virtual memory</span>    <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////</span>    <span class="token comment" spellcheck="true">// Map 'pages' read-only by the user at linear address UPAGES</span>    <span class="token comment" spellcheck="true">// Permissions:</span>    <span class="token comment" spellcheck="true">//    - the new image at UPAGES -- kernel R, user R</span>    <span class="token comment" spellcheck="true">//      (ie. perm = PTE_U | PTE_P)</span>    <span class="token comment" spellcheck="true">//    - pages itself -- kernel RW, user NONE</span>    <span class="token comment" spellcheck="true">// Your code goes here:</span>    <span class="token function">boot_map_region</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>UPAGES<span class="token punctuation">,</span> PTSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>physaddr_t<span class="token punctuation">)</span><span class="token function">PADDR</span><span class="token punctuation">(</span>pages<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是映射内核栈，让<code>KSTACKTOP-KSTKSIZE</code>以下的地区不被映射，这样如果栈区越界就会报错，所以如下面的代码。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////</span>    <span class="token comment" spellcheck="true">// Use the physical memory that 'bootstack' refers to as the kernel</span>    <span class="token comment" spellcheck="true">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span>    <span class="token comment" spellcheck="true">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span>    <span class="token comment" spellcheck="true">// to be the kernel stack, but break this into two pieces:</span>    <span class="token comment" spellcheck="true">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span>    <span class="token comment" spellcheck="true">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span>    <span class="token comment" spellcheck="true">//       the kernel overflows its stack, it will fault rather than</span>    <span class="token comment" spellcheck="true">//       overwrite memory.  Known as a "guard page".</span>    <span class="token comment" spellcheck="true">//     Permissions: kernel RW, user NONE</span>    <span class="token comment" spellcheck="true">// Your code goes here:</span>    <span class="token function">boot_map_region</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>KSTACKTOP <span class="token operator">-</span> KSTKSIZE<span class="token punctuation">,</span> KSTKSIZE<span class="token punctuation">,</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>bootstack<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_W <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后映射<code>KERNBASE</code>之后的所有虚拟空间！，映射到物理内存最低位</p><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////</span>    <span class="token comment" spellcheck="true">// Map all of physical memory at KERNBASE.</span>    <span class="token comment" spellcheck="true">// Ie.  the VA range [KERNBASE, 2^32) should map to</span>    <span class="token comment" spellcheck="true">//      the PA range [0, 2^32 - KERNBASE)</span>    <span class="token comment" spellcheck="true">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span>    <span class="token comment" spellcheck="true">// we just set up the mapping anyway.</span>    <span class="token comment" spellcheck="true">// Permissions: kernel RW, user NONE</span>    <span class="token comment" spellcheck="true">// Your code goes here:</span>    <span class="token function">boot_map_region</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>KERNBASE<span class="token punctuation">,</span> <span class="token number">0xffffffff</span> <span class="token operator">-</span> KERNBASE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PTE_W <span class="token operator">|</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="三-下面回答几个问题："><a href="#三-下面回答几个问题：" class="headerlink" title="三.下面回答几个问题："></a>三.下面回答几个问题：</h2><p>1.<strong>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code>?</strong></p><pre><code>    mystery_t x;    char* value = return_a_pointer();    *value = 10;    x = (mystery_t) value;</code></pre><p>答：</p><p>2.填下面的表：</p><table><thead><tr><th>Entry</th><th>Base Virtual Address</th><th>Points to (logically):</th></tr></thead><tbody><tr><td>1023</td><td>0xffc00000</td><td>Page Table for [252MB,256MB) of phys memory</td></tr><tr><td>1022</td><td>0xff800000</td><td>Page Table for [248MB,252MB) of phys memory</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>960</td><td>0xf0000000</td><td>Page Table for [0MB,4MB) of phys memory</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>2</td><td>0x00800000</td><td>Page Table for [8MB,12MB) of phys memory</td></tr><tr><td>1</td><td>0x00400000</td><td>Page Table for [4MB,8MB) of phys memory</td></tr><tr><td>0</td><td>0x00000000</td><td>Page Table for [0MB,4MB) of phys memory</td></tr></tbody></table><p>3.<strong>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</strong></p><p>答：由于页表可以设置权限（参见附录），如果<code>PTE_U</code>位为0的话，用户就无法读写内核代码</p><p>4.<strong>What is the maximum amount of physical memory that this operating system can support? Why?</strong></p><p>我们从<code>memorylayout.h</code>可以看见，<code>pages</code>数组最大有<code>PTSIZE byte</code>的大小，也就是<code>1024 * 4096 byte</code>，那么一个<code>struct PageInfo</code>结构占用了<code>(32+16)= 48bit</code>，一共<code>8byte</code>，那么可以有512K个<code>struct PageInfo</code>元素（一个元素对应页面），每个页面占用<code>4KB</code>，所以一共是<code>512K * 4KB = 2GB</code>的大小！</p><p>5.<strong>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</strong></p><p>我们的额外负载有<code>pages</code>数组，还有页目录，页表</p><p>当达到最大的物理内存的话，所有的页目录页表和<code>pages</code>数组都在工作。</p><p>页目录占用空间<code>4KB</code>，页表占用<code>1024*4KB=4096KB</code>，<code>pages</code>占用<code>4KB*1024=4MB</code>，加起来大约<code>8MB</code></p><p><img src="/picture/szo.png"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> PageInfo <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Next page on the free list.</span>    <span class="token keyword">struct</span> PageInfo <span class="token operator">*</span>pp_link<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pp_ref is the count of pointers (usually in page table entries)</span>    <span class="token comment" spellcheck="true">// to this page, for pages allocated using page_alloc.</span>    <span class="token comment" spellcheck="true">// Pages allocated at boot time using pmap.c's</span>    <span class="token comment" spellcheck="true">// boot_alloc do not have valid reference count fields.</span>    uint16_t pp_ref<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>6.<strong>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</strong></p><p>答：上面的回顾里面已经解释过了，<code>jmp</code>指令完成了到高地址的跳转。</p><h2 id="三-附录"><a href="#三-附录" class="headerlink" title="三.附录"></a>三.附录</h2><h3 id="1-页目录项和页表项"><a href="#1-页目录项和页表项" class="headerlink" title="1.页目录项和页表项"></a>1.页目录项和页表项</h3><p><img src="/picture/pdepte.png"></p><p>上图就是页目录项和页表项的格式。可以看出，由于页表或者页的物理地址都是4KB对齐的（低12位全是零），所以上图中只保留了物理基地址的高20位（bit[31:12]）。低12位可以安排其他用途。</p><p>【P】：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。<br>【R/W】：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。<br>【U/S】：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。<br>【PWT】：Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉），此标志被忽略。对于我们的实验，此位清零。<br>【PCD】：Page级的Cache Disable标志位。为1时，物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时，此标志被忽略。对于我们的实验，此位清零。<br>【A】：访问位。该位由处理器固件设置，用来指示此表项所指向的页是否已被访问（读或写），一旦置位，处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率。<br>【D】：脏位。该位由处理器固件设置，用来指示此表项所指向的页是否写过数据。<br>【PS】：Page Size位。为0时，页的大小是4KB；为1时，页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled).<br>【G】：全局位。如果页是全局的，那么它将在高速缓存中一直保存。当CR4.PGE=1时，可以设置此位为1，指示Page是全局Page，在CR3被更新时，TLB内的全局Page不会被刷新。<br>【AVL】：被处理器忽略，软件可以使用。</p><h2 id="四-reference"><a href="#四-reference" class="headerlink" title="四.reference"></a>四.reference</h2><p>1.<a href="https://www.jianshu.com/p/3be92c8228b6">6.828 操作系统 lab2 实验报告 - 简书 (jianshu.com)</a></p><p>2.<a href="https://www.cnblogs.com/nullecho/p/10266467.html">页目录项和页表项 - 山城炮灰 - 博客园 (cnblogs.com)</a></p><p>3.<a href="https://pdos.csail.mit.edu/6.828/2016/lec/x86_translation_and_registers.pdf">x86_translation_and_registers.pdf (mit.edu)</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6-828-note-lab1</title>
      <link href="/2021/07/12/MIT6-828-note-lab1/"/>
      <url>/2021/07/12/MIT6-828-note-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h2><p>本学期上完了操作系统课程，感觉OS真的是一门很高级的学问，涉及了计算机最底层的东西，私以为要盖好上层建筑，就必须把基本功打好，这是内功。在学长的推荐下，我决定做一下6.828的实验！在经过一学期的英文文档阅读之后，看见英文的东西已经不打怵了，说不上进步多大，但肯定是有进步的！</p><p>下面附上课程网站：<code>[6.828 / Fall 2018 (mit.edu)](https://pdos.csail.mit.edu/6.828/2018/schedule.html)</code></p><h2 id="二-Lab1"><a href="#二-Lab1" class="headerlink" title="二.Lab1"></a>二.Lab1</h2><pre><code>+------------------+  &lt;- 0xFFFFFFFF (4GB)|      32-bit      ||  memory mapped   ||     devices      ||                  |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\|                  ||      Unused      ||                  |+------------------+  &lt;- depends on amount of RAM|                  ||                  || Extended Memory  ||                  ||                  |+------------------+  &lt;- 0x00100000 (1MB)|     BIOS ROM     |+------------------+  &lt;- 0x000F0000 (960KB)|  16-bit devices, ||  expansion ROMs  |+------------------+  &lt;- 0x000C0000 (768KB)|   VGA Display    |+------------------+  &lt;- 0x000A0000 (640KB)|                  ||    Low Memory    ||                  |+------------------+  &lt;- 0x00000000</code></pre><h3 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1.BIOS"></a>1.BIOS</h3><h4 id="1-1-BIOS的基本功能"><a href="#1-1-BIOS的基本功能" class="headerlink" title="1-1 BIOS的基本功能"></a>1-1 BIOS的基本功能</h4><p>在我们给计算机加电之后，CPU第一个执行的指令就是BIOS的指令，从GDB里面我们可以看出，就是下面这一行，这时<code>CS=0xf000</code>并且<code>IP=0xfff0</code>，所以现在这个指令在地址<code>0xffff0</code>处。我们可以看出来，在实地址模式下，几乎已经达到了寻址空间的尽头，后面为数不多的空间不够存放几条指令了。实际上，真正的<code>BIOS</code>的真正代码在更低地址处。所以我们需要通过下面的指令跳转到相应位置。</p><pre class=" language-assembly"><code class="language-assembly">[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b</code></pre><p><code>ljmp</code>的意思是长跳转，，也就是说跳转到<code>0xfe05b</code>地址处，可以看出，确实是在第一条指令的前面！</p><p>后面<code>BIOS</code>完成自己后续任务，包括设置中断描述符表和初始化各种设备，比如<code>VGA</code>。在做完这些工作之后，<code>BIOS</code>寻找可引导的设备，当它发现可引导的磁盘时，<code>BIOS</code>从磁盘读出<code>bootloader</code>然后把控制权交给它！</p><p>我总结了一下：<code>BIOS</code>起到一个最原始的引导的作用，主要功能是检查硬件，加载bootloader，然后把控制权交给<code>bootloader</code>。而对于设置中断描述符表之类的事情，其实并不是<code>BIOS</code>必须要做的事情，算是拓展功能。而且因为跟硬件的初始化相关，所以BIOS是硬件厂商来制定比较好，也就是说，如果足够精简的BIOS甚至可以把所有的任务都交给bootloader。BIOS相对于用户来说是透明的，而bootloader才是真正操作系统的一部分。而BIOS的具体内容是什么，其实并不在操作系统的范围内。（其实<code>bootloader</code>也不算）。</p><h4 id="1-2-知识补充"><a href="#1-2-知识补充" class="headerlink" title="1-2 知识补充"></a>1-2 知识补充</h4><h5 id="1-2-1-地址卷绕"><a href="#1-2-1-地址卷绕" class="headerlink" title="1-2-1 地址卷绕"></a>1-2-1 地址卷绕</h5><p>用两个 16 位的寄存器左移相加来得到 20 位的内存地址这里还是有问题。那就是两个 16 位数相加所得的最大结果是超过 20 位的。例如段基址 0xffff 左移变成 0xffff0 和偏移量 0xffff 相加得到 0x10ffef 这个内存地址是“溢出”的，怎么办？这里 CPU 被设计出来一个“卷绕”机制，当内存地址超过 20 位则绕回来。举个例子你拿 0x100001 来寻址，我就拿你当作 0x00001 。你超出终点我就把你绕回起点。</p><h5 id="1-2-2-A20总线"><a href="#1-2-2-A20总线" class="headerlink" title="1-2-2 A20总线"></a>1-2-2 A20总线</h5><p>现代的 x86 计算机，无论你是 32 位的还是 64 位的，在开机的那一刻 CPU 都是以模拟 16 位模式运行的，地址卷绕机制也是有效的，所以无论你的电脑内存有多大，开机的时候 CPU 的寻址能力只有 1MB，就好像回到 8086 时代一样。那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。</p><h3 id="2-BootLoader"><a href="#2-BootLoader" class="headerlink" title="2.BootLoader"></a>2.BootLoader</h3><p><code>BootLoader</code>完成以下的几种任务：</p><ol><li><code>BootLoader</code>先把CPU从实地址模式转换成32位的保护模式，因为只有运行在保护模式的软件才可以访问超过<code>1MB</code>的地址空间！</li><li>下一步，它把操作系统内核读入内存中，最后把控制权交给内核！</li></ol><p>通过查看反汇编的<code>obj/boot/boot.asm</code>，我们可以看出，<code>bootloader</code>的第一行代码被<code>BIOS</code>存放在地址为<code>0x7c00</code>的位置，通过<code>jmp</code>指令设置<code>CS:IP</code>为<code>0000:7c00</code>，把控制权交给它</p><h4 id="2-1-boot-S分析"><a href="#2-1-boot-S分析" class="headerlink" title="2-1 boot.S分析"></a>2-1 <code>boot.S</code>分析</h4><p>下面进入bootloader的实体了，它做了如下工作：</p><ol><li><p>关闭中断，CPU不再响应中断，它的作用是保证引导程序能够顺利地执行。然后清除eflags里面的DF，作用是在字串操作中让变址寄存器SI和DI的地址指针自动增加，字符串处理从前向后</p></li><li><p>下一步初始化重要的段寄存器，比如ds，es，ss，异或操作让他们全部为0</p></li><li><p>然后开启A20地址线。为了后向兼容早期的PC机，20号物理地址线绑定在低地址，所以高于1MB的地址默认是0，这个作用就是撤销这个，开启所有地址线</p><ul><li>其中seta20.1的作用是在64号端口写入0xd1，说明我要向键盘控制器的P2端口写数据了。</li><li>写数据的方法是把数据通过键盘控制器的60号端口写进去，写入的数据是0xdf，这样打开了A20 gate</li></ul></li><li><p>下面要做的是从实地址模式到保护模式的转换</p><ul><li>首先准备gdt（全局描述符表），上面是带有宏的代码，翻译出来就是底下的代码</li></ul><pre class=" language-assembly"><code class="language-assembly">#翻译之前gdt:  SEG_NULL                # null seg  SEG(STA_X|STA_R, 0x0, 0xffffffff)    # code seg  SEG(STA_W, 0x0, 0xffffffff)     # data seg#翻译出来之后  gdt:  .word 0, 0;  .byte 0, 0, 0, 0                             # 空  .word 0xffff, 0x0000;  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段  .word 0xffff, 0x0000;  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段</code></pre><p>我们可以看出来DB=1表示的是地址和操作数是32位，G等于1表示20位的段limit的粒度是4KB，最大长度是4GB，所以根据上面的代码来看，limit都是0xfffff，说明32位寻址，段长度是0xfffff=2^20，根据粒度等于4KB，所以段界限为4GB，也就是全部地址空间！</p><p>E为1是代码段，为0是数据段，这样即使RW位都相同，但是因为E不同，代码段是只可读，而数据段是可读写</p><ul><li>下面正式进入保护模式，下面这段代码正好对应了<code>gdtr</code>的48位，高32位是gdt的首地址，而低16位是gdt的长度！（长度可以看出来有多少个全局描述符表项）</li></ul><pre class=" language-assembly"><code class="language-assembly">gdtdesc:  .word   (gdtdesc - gdt - 1)             # 16 位的 gdt 大小sizeof(gdt) - 1  .long   gdt                             # 32 位的 gdt 所在物理地址</code></pre><p>其中<code>lgdt</code>指令把<code>gdtdesc</code>的值加载到<code>gdtr</code>里面！</p><ul><li><p>下面一步是打开保护模式的“开关”，x86的控制寄存器有<code>CR0</code>,<code>CR1</code>,<code>CR2</code>,<code>CR3</code>这四个，保护模式的开关再<code>CR0</code>上面</p><p>下面这个代码的意思是把CR0的PE位设置为1，开启保护模式！</p></li></ul><pre class=" language-assembly"><code class="language-assembly">  movl    %cr0, %eax  orl     $CR0_PE_ON, %eax  movl    %eax, %cr0</code></pre></li><li><p>开启保护模式之后，使用长跳转语句，跳转到内核的数据段，这时候寻址方式变成“段基址+段内偏移量”，此时基址寄存器里面的内容是gdt的索引，经过CPU的MMU翻译之后，跳转到相应位置。其中有一些需要解释的地方：为什么<code>PROT_MODE_DSEG</code>的值是0x10呢，因为段基址的高13位代表GDT的下标，所以这样表示下标为2，刚好是内核数据段的下标！查找GDT表之后，我们知道基地址为0，所以后面的段内偏移量就是<code>$protcseg</code>，直接跳转到32位的<code>protcseg</code>函数部分</p></li><li><p>最后设置各个段寄存器，设置栈指针为0x7c00，然后调用<code>bootmain</code>！</p></li></ol><h4 id="2-2-bootmain-c分析"><a href="#2-2-bootmain-c分析" class="headerlink" title="2-2 bootmain.c分析"></a>2-2 <code>bootmain.c</code>分析</h4><p>我们进入<code>bootmain.c</code>的时候，通过反汇编的代码我们可以看出<code>ph</code>被存入了<code>ebx</code>寄存器中，而<code>eph</code>存入了<code>esi</code>寄存器里。</p><pre class=" language-assembly"><code class="language-assembly">    ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);    7d3a:    a1 1c 00 01 00           mov    0x1001c,%eax    eph = ph + ELFHDR->e_phnum;    7d3f:    0f b7 35 2c 00 01 00     movzwl 0x1002c,%esi    ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);    7d46:    8d 98 00 00 01 00        lea    0x10000(%eax),%ebx    eph = ph + ELFHDR->e_phnum;    7d4c:    c1 e6 05                 shl    $0x5,%esi    7d4f:    01 de                    add    %ebx,%esi</code></pre><p>首先分析等待磁盘操作<code>waitdisk</code>，下面的操作就是去读<code>0x1fc</code>端口的<code>bit6</code>和<code>bit7</code>，当<code>bit6=1</code>并且<code>bit7=0</code>的时候，就代表磁盘空闲。其中<code>bit6</code>等于1表示驱动器就绪，<code>bit7</code>空闲表示控制器空闲！</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// wait for disk reaady</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span><span class="token number">0x1F7</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xC0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x40</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/* do nothing */</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后说一下<code>readseg</code>函数，先等待磁盘空闲，就可以读磁盘了。为什么要把offset写入这些端口呢？</p><p>IDE定义了8个寄存器操作硬盘。PC 体系结构将第一个硬盘控制器映射到端口 1F0-1F7 处，而第二个硬盘控制器则被映射到端口 170-177 处。out函数主要是是把扇区计数、扇区LBA地址等信息输出到端口1F2-1F6，然后将0x20命令写到1F7，表示要进行读扇区的操作。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token function">readsect</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> uint32_t offset<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// wait for disk to be ready</span>    <span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// count = 1</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F3</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F4</span><span class="token punctuation">,</span> offset <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F5</span><span class="token punctuation">,</span> offset <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F6</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>offset <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xE0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F7</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// cmd 0x20 - read sectors</span>    <span class="token comment" spellcheck="true">// wait for disk to be ready</span>    <span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// read a sector</span>    <span class="token function">insl</span><span class="token punctuation">(</span><span class="token number">0x1F0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> SECTSIZE<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是有一个问题，上面的代码里有一个<code>insl</code>函数，这个是什么呢？</p><p>看它的实现是一个内联汇编</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span>    <span class="token function">insl</span><span class="token punctuation">(</span>uint32_t port<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>            <span class="token string">"cld;"</span>            <span class="token string">"repne; insl;"</span>            <span class="token punctuation">:</span> <span class="token string">"=D"</span> <span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=c"</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">)</span>            <span class="token punctuation">:</span> <span class="token string">"d"</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"0"</span> <span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"1"</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">)</span>            <span class="token punctuation">:</span> <span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我去<code>StackOverflow</code>搜到了相应的解释：</p><blockquote><p>That function will read <code>cnt</code> <code>dwords</code> from the input port specified by <code>port</code> into the supplied output array <code>addr</code>.</p></blockquote><p>大概意思就是说，从<code>port</code>端口里面读出<code>cnt</code>个<code>dword</code>（4字节），读入到特定的内存地址上去。</p><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// read a sector</span>    <span class="token function">insl</span><span class="token punctuation">(</span><span class="token number">0x1F0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> SECTSIZE<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以看出来，因为一个<code>dword</code>是4字节，所以后面的<code>cnt</code>就是<code>SECTSIZE/4</code></p><p>跟踪<code>for</code>循环语句，我们从<code>asm</code>代码可以看出，下面这段代码是跟循环有关，首先用<code>cmp</code>指令比较<code>ph</code>和<code>eph</code>的大小，如果<code>ph</code>大于等于<code>eph</code>的话，就跳出循环，跳到入口函数。否则继续执行，给<code>readseg</code>的参数入栈，中间会进行一些<code>ph</code>自增的操作，最后跳回比较操作！</p><pre class=" language-assembly"><code class="language-assembly">    for (; ph < eph; ph++)    7d51:    39 f3                    cmp    %esi,%ebx    7d53:    73 16                    jae    7d6b <bootmain+0x56>        readseg(ph->p_pa, ph->p_memsz, ph->p_offset);    7d55:    ff 73 04                 pushl  0x4(%ebx)    7d58:    ff 73 14                 pushl  0x14(%ebx)    for (; ph < eph; ph++)    7d5b:    83 c3 20                 add    $0x20,%ebx        readseg(ph->p_pa, ph->p_memsz, ph->p_offset);    7d5e:    ff 73 ec                 pushl  -0x14(%ebx)    7d61:    e8 76 ff ff ff           call   7cdc <readseg>    for (; ph < eph; ph++)    7d66:    83 c4 0c                 add    $0xc,%esp    7d69:    eb e6                    jmp    7d51 <bootmain+0x3c>    ((void (*)(void)) (ELFHDR->e_entry))();    7d6b:    ff 15 18 00 01 00        call   *0x10018</code></pre><p>具体的源代码就不放出来了，有兴趣请去网上找资源</p><h4 id="2-3-回答问题"><a href="#2-3-回答问题" class="headerlink" title="2-3 回答问题"></a>2-3 回答问题</h4><p>回答下列问题：</p><ol><li><p>问：处理器在哪一个点开始执行32位的代码？实际上是什么造成了16位到32位的转换？</p><p>回答：处理器从<code>boot.S</code>的<code>.code32</code>伪指令开始执行32位代码，在这之前处理器还处于16位的实模式，而打开了cr0的PE位之后，开启了保护模式，从16位变成32位</p></li><li><p>问：bootloader执行的最后一个指令是什么？kernel第一个被加载的指令是什么？</p><p>下面是<code>bootloader</code>的最后一条指令，对应的c语言代码就是跳转到<code>Kernel</code>的入口处！</p><pre class=" language-assembly"><code class="language-assembly">((void (*)(void)) (ELFHDR->e_entry))();7d6b:    ff 15 18 00 01 00        call   *0x10018</code></pre><p>而下面这段是<code>kernel</code>的第一条指令</p><pre class=" language-assembly"><code class="language-assembly">0x10000c:    movw   $0x1234,0x472   </code></pre></li><li><p>问：内核的第一条指令地址在哪里？</p><p>回答：根据GDB调试，地址在<code>0x10000c</code>处</p></li><li><p><code>bootloader</code>如何知道它要从磁盘里读多少扇区？从哪里找到这些信息的？</p><p>回答：可以从<code>bootmain.c</code>的源代码看出，它的所有信息都是从ELF头里面读出来的！首先找到程序头表的位置，然后找到程序头表里有多少条目。根据程序头表条目给出的信息，把kernel的相应内容从磁盘读入内存！</p></li></ol><pre class=" language-c"><code class="language-c">    ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> Proghdr <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span> ELFHDR <span class="token operator">+</span> ELFHDR<span class="token operator">-></span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>    eph <span class="token operator">=</span> ph <span class="token operator">+</span> ELFHDR<span class="token operator">-></span>e_phnum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// p_pa is the load address of this segment (as well</span>        <span class="token comment" spellcheck="true">// as the physical address)</span>        <span class="token function">readseg</span><span class="token punctuation">(</span>ph<span class="token operator">-></span>p_pa<span class="token punctuation">,</span> ph<span class="token operator">-></span>p_memsz<span class="token punctuation">,</span> ph<span class="token operator">-></span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h4><p>问：修改链接地址并且观察<code>bootloader</code>的运行情况</p><p>答：我先把链接地址从<code>0x7c00</code>改成了<code>0x8c00</code>，然后用<code>gdb</code>来看看发生了什么问题。我在上述这两个地址处都设置了断点，然后按c继续运行，这时我可以看见，仍然在<code>0x7c00</code>处执行第一条指令<code>cli</code>，这让我很疑惑。但是在查阅相关资料之后，发现这是<code>BIOS</code>在捣鬼，实际上不管链接地址是加载到哪里的，<code>BIOS</code>是固定会把<code>bootloader</code>加载到<code>0x7c00</code>的位置，这样也就不难解释为什么还是从<code>0x7c00</code>开始执行代码了。但是我再一次按c继续执行，发现了报错！</p><pre class=" language-assembly"><code class="language-assembly">Program received signal SIGTRAP, Trace/breakpoint trap.[   0:7c2d] => 0x7c2d:    ljmp   $0x8,$0x8c32</code></pre><p>也就是说，在<code>ljmp $PROT_MODE_CSEG, $protcseg</code>这句汇编语句出现了错误，这是因为，链接器在链接的时候是根据<code>protcseg</code>相对于第一条指令的相对地址来确定链接地址的，所以确定地址为<code>0x8c32</code>，而实际上加载到的真实地址还是<code>0x7c32</code>！（其实包括前面的<code>lgdt</code>也出错了！）</p><h4 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h4><p>问：查看<code>bootloader</code>把内核加载前后<code>kernel</code>入口处的内存地址，看看为什么有这样的不同</p><p>回答：从下面这段<code>gdb</code>调试的代码可以看出，在<code>bootloader</code>加载<code>kernel</code>之前，这段内存都是0，在加载之后，内存中有了相应的内容，我对比<code>kernel.asm</code>看一看，它们刚好对应</p><pre class=" language-assembly"><code class="language-assembly">The target architecture is assumed to be i8086[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b0x0000fff0 in ?? ()+ symbol-file obj/kern/kernel(gdb) b *0x7d6bBreakpoint 1 at 0x7d6b(gdb) x/10x 0x10000c0x10000c:    0x00000000    0x00000000    0x00000000    0x000000000x10001c:    0x00000000    0x00000000    0x00000000    0x000000000x10002c:    0x00000000    0x00000000(gdb) cContinuing.The target architecture is assumed to be i386=> 0x7d6b:    call   *0x10018Breakpoint 1, 0x00007d6b in ?? ()(gdb) x/10x 0x10000c0x10000c:    0x7205c766    0x34000004    0x2000b812    0x220f00110x10001c:    0xc0200fd8    0x0100010d    0xc0220f80    0x10002fb80x10002c:    0xbde0fff0    0x00000000(gdb) </code></pre><h3 id="3-Kernel"><a href="#3-Kernel" class="headerlink" title="3.Kernel"></a>3.Kernel</h3><p>下面开始分析<code>Kernel</code>了。</p><h4 id="3-1有关分页"><a href="#3-1有关分页" class="headerlink" title="3-1有关分页"></a>3-1有关分页</h4><h5 id="练习七"><a href="#练习七" class="headerlink" title="练习七"></a>练习七</h5><p>要求首先看看关于地址映射的问题，我先在<code>mov %eax, %cr0</code>所在位置设置了断点，运行到这里。然后检查了两段地址的内存，刚开始是不一样，然后执行完这句指令，发现两块内存是一样的了！这很神奇！这是因为在开启PE位之后，开启了虚拟内存模式，把虚拟内存空间高地址的内存映射到对应的物理内存上，所以他们的内容是一样的</p><pre class=" language-assembly"><code class="language-assembly">(gdb) b *0x100025Breakpoint 2 at 0x100025(gdb) cContinuing.=> 0x100025:    mov    %eax,%cr0Breakpoint 2, 0x00100025 in ?? ()(gdb) x/8x 0x1000000x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c7660x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8(gdb) x/8x 0xf01000000xf0100000 <_start+4026531828>:    0x00000000    0x00000000    0x00000000    0x000000000xf0100010 <entry+4>:    0x00000000    0x00000000    0x00000000    0x00000000(gdb) si=> 0x100028:    mov    $0xf010002f,%eax0x00100028 in ?? ()(gdb) x/8x 0x1000000x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c7660x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8(gdb) x/8x 0xf01000000xf0100000 <_start+4026531828>:    0x1badb002    0x00000000    0xe4524ffe    0x7205c7660xf0100010 <entry+4>:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8(gdb) </code></pre><p>如果开启PE失败的话，那么下面两句就会出现问题：</p><pre class=" language-assembly"><code class="language-assembly">    mov    $relocated, %eaxf0100028:    b8 2f 00 10 f0           mov    $0xf010002f,%eax    jmp    *%eaxf010002d:    ff e0                    jmp    *%eax</code></pre><p>其实我们在阅读源代码的时候会注意到注释上给了一点问题</p><blockquote><pre class=" language-assembly"><code class="language-assembly"># Now paging is enabled, but we're still running at a low EIP# (why is this okay?).  Jump up above KERNBASE before entering# C code.</code></pre></blockquote><p>问的是为什么开启分页之后，用原来的<code>EIP</code>还能继续运行，我们需要注意，<strong>我们是将两个范围的虚拟地址映射到物理地址上，而不仅仅是高地址！</strong>这也是这么做的目的！</p><p>既然提到了有关分页的操作，我们不得不分析一下代码了</p><ol><li>在开启分页之前，我们要把页目录的地址存入<code>cr3</code>，注意：我们要加载的是页目录表的<strong>物理地址</strong>，这是因为到时候直接从<code>cr3</code>中取出地址来寻找页目录表，不经过地址转换，所以不能是虚拟地址！（虚拟地址转换需要借助<code>cr3</code>，不能够因果倒置！）</li><li>然后把<code>cr0</code>的<code>PG</code>位打开</li><li>然后跳转到高地址！（变成<code>high EIP</code>）</li></ol><pre class=" language-assembly"><code class="language-assembly">    movl    $(RELOC(entry_pgdir)), %eax    movl    %eax, %cr3    # Turn on paging.    movl    %cr0, %eax    orl    $(CR0_PE|CR0_PG|CR0_WP), %eax    movl    %eax, %cr0    # Now paging is enabled, but we're still running at a low EIP    # (why is this okay?).  Jump up above KERNBASE before entering    # C code.    mov    $relocated, %eax    jmp    *%eax</code></pre><p>那么，我们就知道了如果没有映射成功的话，打开<code>cr0</code>的<code>PG</code>位之后的下两条指令就会出错，因为<code>relocated</code>是高地址，如果没有映射的话，跳转到那里就会报错！</p><p>我们来测试一下，注释掉设置<code>cr0</code>的操作，可见那个地址的内存全是0，系统崩溃掉了！</p><pre class=" language-assembly"><code class="language-assembly">(gdb) b *0x100025Breakpoint 1 at 0x100025(gdb) cContinuing.The target architecture is assumed to be i386=> 0x100025:    mov    $0xf010002c,%eaxBreakpoint 1, 0x00100025 in ?? ()(gdb) si=> 0x10002a:    jmp    *%eax0x0010002a in ?? ()(gdb) si=> 0xf010002c <relocated>:    add    %al,(%eax)relocated () at kern/entry.S:7474        movl    $0x0,%ebp            # nuke frame pointer(gdb) Remote connection closed(gdb) </code></pre><p>还有关于<code>entry_pgdir</code>这个东西的一些讨论，我们可以从<code>entrypgdir.c</code>里面看出来，<code>Jos</code>利用的是二级页表操作，也就是说，把逻辑地址分为页目录10位，页表号10位，页内偏移量12位这三个部分，而我们只需要映射两个部分的虚拟内存！所以页目录设置为下面这样！</p><pre class=" language-c"><code class="language-c"><span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__aligned__</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pde_t entry_pgdir<span class="token punctuation">[</span>NPDENTRIES<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Map VA's [0, 4MB) to PA's [0, 4MB)</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>entry_pgtable <span class="token operator">-</span> KERNBASE<span class="token punctuation">)</span> <span class="token operator">+</span> PTE_P<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span>    <span class="token punctuation">[</span>KERNBASE<span class="token operator">>></span>PDXSHIFT<span class="token punctuation">]</span>        <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>entry_pgtable <span class="token operator">-</span> KERNBASE<span class="token punctuation">)</span> <span class="token operator">+</span> PTE_P <span class="token operator">+</span> PTE_W<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>页表在下面这样的格式。</p><pre class=" language-c"><code class="language-c"><span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__aligned__</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pte_t entry_pgtable<span class="token punctuation">[</span>NPTENTRIES<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token number">0x000000</span> <span class="token operator">|</span> PTE_P <span class="token operator">|</span> PTE_W<span class="token punctuation">,</span>    <span class="token number">0x001000</span> <span class="token operator">|</span> PTE_P <span class="token operator">|</span> PTE_W<span class="token punctuation">,</span>    <span class="token number">0x002000</span> <span class="token operator">|</span> PTE_P <span class="token operator">|</span> PTE_W<span class="token punctuation">,</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span></code></pre><h4 id="3-2有关格式化输出"><a href="#3-2有关格式化输出" class="headerlink" title="3-2有关格式化输出"></a>3-2有关格式化输出</h4><p>我们在进行下几步之前，先阅读一下源代码。</p><p>在阅读过程中有几个宏让我感到很疑惑，就是下面这几个，经过查阅引用[5]我得知这几个宏跟格式化输出函数的可变参数有关！</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> va_start(ap, last) __builtin_va_start(ap, last)</span><span class="token macro property">#<span class="token directive keyword">define</span> va_arg(ap, type) __builtin_va_arg(ap, type)</span><span class="token macro property">#<span class="token directive keyword">define</span> va_end(ap) __builtin_va_end(ap)</span></code></pre><p>我们需要修改的一个地方就是打印8进制数字，理解了代码之后不难写出这个</p><pre class=" language-c"><code class="language-c">        <span class="token comment" spellcheck="true">// (unsigned) octal</span>        <span class="token keyword">case</span> <span class="token string">'o'</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> <span class="token function">getuint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ap<span class="token punctuation">,</span>lflag<span class="token punctuation">)</span><span class="token punctuation">;</span>            base <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> number<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span></code></pre><p>下面回答几个问题：</p><ol><li><p>问：Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</p><p>答：<code>printf.c</code>里面的<code>putch</code>调用了<code>console.c</code>里面的<code>cputchar</code>函数，同时<code>vcprintf</code>调用了<code>putch</code>函数，<code>cprintf</code>调用了<code>vcprintf</code>函数</p><p>总结下来调用关系就是：</p><pre class=" language-c"><code class="language-c">cprintf<span class="token operator">-></span>vcprintf<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-></span>putch<span class="token operator">-></span><span class="token function">cputchar</span><span class="token punctuation">(</span>consule<span class="token punctuation">.</span>c<span class="token punctuation">)</span>                  <span class="token operator">|</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">></span><span class="token function">vprintfmt</span><span class="token punctuation">(</span>ptintfmt<span class="token punctuation">.</span>c<span class="token punctuation">)</span></code></pre></li><li><p>问：explain the following from <code>console.c</code></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// What is the purpose of this?</span><span class="token keyword">if</span> <span class="token punctuation">(</span>crt_pos <span class="token operator">>=</span> CRT_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span>crt_buf<span class="token punctuation">,</span> crt_buf <span class="token operator">+</span> CRT_COLS<span class="token punctuation">,</span> <span class="token punctuation">(</span>CRT_SIZE <span class="token operator">-</span> CRT_COLS<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> CRT_SIZE <span class="token operator">-</span> CRT_COLS<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> CRT_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        crt_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x0700</span> <span class="token operator">|</span> <span class="token string">' '</span><span class="token punctuation">;</span>    crt_pos <span class="token operator">-</span><span class="token operator">=</span> CRT_COLS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>答：这段代码的目的是：当屏幕已经装满了字符，再次输入的时候，让屏幕向上回滚一行，也就是说把内存里面的内容向前移动80个字符的大小，然后最后一行用黑色填满</p></li><li><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"x %d, y %x, z %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>问1：上面这段代码里，<code>fmt</code>指代什么？<code>ap</code>指代什么？</p><p>答：<code>fmt</code>是字符串<code>"x %d, y %x, z %d\n"</code>的首地址，根据上面的解释<code>ap</code>是后面参数的首地址</p><p>问2：列出调用过程</p><p>答：</p><ul><li><code>cprintf</code>首先调用<code>vcprintf</code>，参数<code>fmt</code>的值为格式化字符串的地址，参数<code>ap</code>指向变量<code>x</code>的地址。</li><li><code>vcprintf</code>调用<code>vprintfmt</code>，<code>vprintfmt</code>函数中多次调用<code>va_arg</code>和<code>putch</code>，<code>putch</code>调用<code>cputchar</code>，而<code>cputchar</code>调用<code>cons_putc</code>，<code>putch</code>的字符参数传给<code>cons_putc</code></li><li>调用<code>cons_putc</code>，参数为字符<code>'x'</code></li><li>调用<code>cons_putc</code>，参数为字符空格</li><li>调用<code>va_arg</code>，<code>lflag=0</code>，调用前<code>ap</code>指向<code>x</code>，调用后<code>ap</code>指向<code>y</code></li><li>调用<code>cons_putc</code>，参数是字符<code>'1'</code></li><li>调用<code>cons_putc</code>，参数为字符<code>','</code></li><li>调用<code>cons_putc</code>，参数为字符空格</li><li>调用<code>cons_putc</code>，参数为字符<code>'y'</code></li><li>调用<code>cons_putc</code>，参数为字符空格</li><li>调用<code>va_arg</code>，<code>lflag=0</code>，调用前<code>ap</code>指向<code>y</code>，调用后<code>ap</code>指向<code>z</code></li><li>调用<code>cons_putc</code>，参数为字符<code>'3'</code></li><li>调用<code>cons_putc</code>，参数为字符<code>','</code></li><li>调用<code>cons_putc</code>，参数为字符空格</li><li>调用<code>cons_putc</code>，参数为字符<code>'z'</code></li><li>调用<code>cons_putc</code>，参数为字符空格</li><li>调用<code>va_arg</code>，<code>lflag=0</code>，调用前<code>ap</code>指向<code>z</code>，调用后<code>ap</code>指向<code>z</code>后面一块内存</li><li>调用<code>cons_putc</code>，参数为字符<code>'4'</code></li><li>调用<code>cons_putc</code>，参数为字符<code>'\n'</code></li></ul></li><li><p>运行下面程序，看看运行结果</p><pre class=" language-c"><code class="language-c">    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span>    <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果：</span><span class="token comment" spellcheck="true">//He110 World</span></code></pre><p>原因如下：10进制57616的16进制表示是E110，而<code>i</code>所在内存将被解读成一个字符串，根据小端法，依次输出0x72，0x6c，0x64表示<code>ASCII</code>码所表示的字符，分别是r，l，d这三个字符！</p><p>综上，我们得到输出结果<code>He110 World</code></p></li><li><p>执行下面代码会把y输出成什么呢？</p><pre class=" language-c"><code class="language-c"><span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>实际上输出参数3后面的内存地址所指向的4字节值（按照小端法读取）</p><p>经过测试，实际上输出的是整数1600，具体的过程如何呢？</p><p>在下面这段代码里面，我们发现在把3入栈之前，先把<code>esp</code>加8，那么我们可以知道，y所输出的值就是<code>esp</code>加8之后的所指向的内存，继续往回看，在调用<code>test_backtrace(5)</code>的时候，并没有把5压栈，而是直接把<code>esp</code>所指向的内存的值改成了5，所以我们需要继续向上找。可以看出<code>cprintf</code>有两个参数，所以<code>esp</code>加8应该跳到这两个参数之上的那个参数，我们发现在<code>0xf01000d4</code>这里还有一个给<code>esp</code>加8的操作，所以再回溯两个<code>push</code>操作，我们注意到这一行<code>f01000c6:    50                       push   %eax</code>，没错，这个<code>eax</code>就是显示出来的y的值！根据上面的<code>sub</code>指令，我们算出来<code>eax</code>的值就是十进制的1600！！！</p><pre class=" language-c"><code class="language-c">f01000b8<span class="token punctuation">:</span>    c7 c2 <span class="token number">60</span> <span class="token number">30</span> <span class="token number">11</span> f0        mov    $<span class="token number">0xf0113060</span><span class="token punctuation">,</span><span class="token operator">%</span>edxf01000be<span class="token punctuation">:</span>    c7 c0 a0 <span class="token number">36</span> <span class="token number">11</span> f0        mov    $<span class="token number">0xf01136a0</span><span class="token punctuation">,</span><span class="token operator">%</span>eaxf01000c4<span class="token punctuation">:</span>    <span class="token number">29</span> d0                    sub    <span class="token operator">%</span>edx<span class="token punctuation">,</span><span class="token operator">%</span>eaxf01000c6<span class="token punctuation">:</span>    <span class="token number">50</span>                       push   <span class="token operator">%</span>eaxf01000c7<span class="token punctuation">:</span>    6a <span class="token number">00</span>                    push   $<span class="token number">0x0</span>f01000c9<span class="token punctuation">:</span>    <span class="token number">52</span>                       push   <span class="token operator">%</span>edxf01000ca<span class="token punctuation">:</span>    e8 <span class="token number">20</span> <span class="token number">15</span> <span class="token number">00</span> <span class="token number">00</span>           call   f01015ef <span class="token operator">&lt;</span>memset<span class="token operator">></span>    <span class="token comment" spellcheck="true">// Initialize the console.</span>    <span class="token comment" spellcheck="true">// Can't call cprintf until after we do this!</span>    <span class="token function">cons_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f01000cf<span class="token punctuation">:</span>    e8 4e <span class="token number">05</span> <span class="token number">00</span> <span class="token number">00</span>           call   f0100622 <span class="token operator">&lt;</span>cons_init<span class="token operator">></span>    <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"6828 decimal is %o octal!\n"</span><span class="token punctuation">,</span> <span class="token number">6828</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f01000d4<span class="token punctuation">:</span>    <span class="token number">83</span> c4 <span class="token number">08</span>                 add    $<span class="token number">0x8</span><span class="token punctuation">,</span><span class="token operator">%</span>espf01000d7<span class="token punctuation">:</span>    <span class="token number">68</span> ac 1a <span class="token number">00</span> <span class="token number">00</span>           push   $<span class="token number">0x1aac</span>f01000dc<span class="token punctuation">:</span>    8d <span class="token number">83</span> <span class="token number">6f</span> <span class="token number">07</span> ff ff        lea    <span class="token operator">-</span><span class="token function">0xf891</span><span class="token punctuation">(</span><span class="token operator">%</span>ebx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>eaxf01000e2<span class="token punctuation">:</span>    <span class="token number">50</span>                       push   <span class="token operator">%</span>eaxf01000e3<span class="token punctuation">:</span>    e8 <span class="token number">72</span> <span class="token number">09</span> <span class="token number">00</span> <span class="token number">00</span>           call   f0100a5a <span class="token operator">&lt;</span>cprintf<span class="token operator">></span>    <span class="token comment" spellcheck="true">// Test the stack backtrace function (lab 1 only)</span>    <span class="token function">test_backtrace</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f01000e8<span class="token punctuation">:</span>    c7 <span class="token number">04</span> <span class="token number">24</span> <span class="token number">05</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>     movl   $<span class="token number">0x5</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span>f01000ef<span class="token punctuation">:</span>    e8 4c ff ff ff           call   f0100040 <span class="token operator">&lt;</span>test_backtrace<span class="token operator">></span>    <span class="token comment" spellcheck="true">//int x = 1, y = 3, z = 4;</span>    <span class="token comment" spellcheck="true">//cprintf("x %d, y %x, z %d\n", x, y, z);</span>    <span class="token comment" spellcheck="true">//unsigned int i = 0x00646c72;</span>    <span class="token comment" spellcheck="true">//cprintf("H%x Wo%s", 57616, &amp;i);</span>    <span class="token comment" spellcheck="true">//Sasm("pushl $200");</span>    <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f01000f4<span class="token punctuation">:</span>    <span class="token number">83</span> c4 <span class="token number">08</span>                 add    $<span class="token number">0x8</span><span class="token punctuation">,</span><span class="token operator">%</span>espf01000f7<span class="token punctuation">:</span>    6a <span class="token number">03</span>                    push   $<span class="token number">0x3</span>f01000f9<span class="token punctuation">:</span>    8d <span class="token number">83</span> 8a <span class="token number">07</span> ff ff        lea    <span class="token operator">-</span><span class="token function">0xf876</span><span class="token punctuation">(</span><span class="token operator">%</span>ebx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>eaxf01000ff<span class="token punctuation">:</span>    <span class="token number">50</span>                       push   <span class="token operator">%</span>eaxf0100100<span class="token punctuation">:</span>    e8 <span class="token number">55</span> <span class="token number">09</span> <span class="token number">00</span> <span class="token number">00</span>           call   f0100a5a <span class="token operator">&lt;</span>cprintf<span class="token operator">></span>f0100105<span class="token punctuation">:</span>    <span class="token number">83</span> c4 <span class="token number">10</span>                 add    $<span class="token number">0x10</span><span class="token punctuation">,</span><span class="token operator">%</span>esp</code></pre></li><li><p>问：Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>答：可以在最后push一个整数来表示参数的数目！</p></li></ol><h4 id="3-3有关内核栈"><a href="#3-3有关内核栈" class="headerlink" title="3-3有关内核栈"></a>3-3有关内核栈</h4><h5 id="练习九"><a href="#练习九" class="headerlink" title="练习九"></a>练习九</h5><p>内核是如何初始化栈的？我们结合下面的代码来看，首先把栈顶指针的内容赋值给<code>esp</code>，然后看下面，<code>bootstack</code>给分配了<code>KSTKSIZE</code>的内存空间，也就是8个页的大小。然后栈顶的值是分配的内存空间结束的地址，是高地址！</p><pre class=" language-assembly"><code class="language-assembly">    # Set the stack pointer    movl    $(bootstacktop),%esp.data#################################################################### boot stack###################################################################    .p2align    PGSHIFT        # force page alignment    .globl        bootstackbootstack:    .space        KSTKSIZE    .globl        bootstacktop   bootstacktop:</code></pre><h5 id="练习十"><a href="#练习十" class="headerlink" title="练习十"></a>练习十</h5><p>对于<code>testbacktrace</code>，我们从源代码可以看出每次进入这个函数之后进行如下步骤：</p><ol><li>把栈底指针压入栈（然后让<code>ebp</code>变成新的栈底指针）</li><li>把<code>esi</code>和<code>ebx</code>推入栈中，保存寄存器</li><li>然后进行<code>cprintf</code>有关的处理</li><li>把<code>fmt</code>地址入栈</li><li>调用<code>cprintf</code></li><li>把<code>test_backtrace(x-1)</code>的参数压栈</li><li>递归调用</li></ol><p>后面是写代码的题目，懒得写了，先把代码贴上，后期再解释…</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span><span class="token function">mon_backtrace</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">struct</span> Trapframe <span class="token operator">*</span>tf<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Your code here.</span>    uint32_t ebp<span class="token punctuation">,</span> old_ebp<span class="token punctuation">,</span> eip<span class="token punctuation">;</span>    uint32_t args<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    ebp <span class="token operator">=</span> <span class="token function">read_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ebp = *((uint32_t*)ebp);</span>    <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"Stack backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ebp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        old_ebp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span>ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>        eip <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"  ebp %x  eip %x  args %08x %08x %08x %08x %08x\n"</span><span class="token punctuation">,</span>             ebp<span class="token punctuation">,</span> eip<span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> Eipdebuginfo info<span class="token punctuation">;</span>        <span class="token function">debuginfo_eip</span><span class="token punctuation">(</span>eip<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">char</span> fn_name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strncpy</span><span class="token punctuation">(</span>fn_name<span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_fn_name<span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_fn_namelen<span class="token punctuation">)</span><span class="token punctuation">;</span>        fn_name<span class="token punctuation">[</span>info<span class="token punctuation">.</span>eip_fn_namelen<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"         %s:%d: %s+%d\n"</span><span class="token punctuation">,</span>             info<span class="token punctuation">.</span>eip_file<span class="token punctuation">,</span>             info<span class="token punctuation">.</span>eip_line<span class="token punctuation">,</span>             fn_name<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//info.eip_fn_name, </span>            eip <span class="token operator">-</span> info<span class="token punctuation">.</span>eip_fn_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        ebp <span class="token operator">=</span> old_ebp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="练习十二"><a href="#练习十二" class="headerlink" title="练习十二"></a>练习十二</h5><p>先看一下<code>kern/kernel.ld</code>，可以知道<code>__STAB_BEGIN__</code>和<code>__STAB_END__</code>，<code>__STABSTR_BEGIN__</code>和<code>__STABSTR_END__</code>这四个变量是内存中他们的地址（指针）！</p><p>然后<code>objdump -h</code>查看<code>kernel</code>的节头表，发现有如下内容，所以<code>__STAB_BEGIN__</code>的值应该是<code>0xf01022bc</code>，<code>__STAB_END__</code>的值应该是<code>0xf0106090</code>（另外两个以此类推）</p><p><img src="/picture/6.828-1-1.png" alt="kernel的节头表"></p><p>再<code>kernel</code>被加载好之后，我来查看一下符号表是否也被加载到预期的位置，根据下面这张图来看，确实！</p><p><img src="/picture/6.828-1-2.png" alt="检查stabstr段所在内存"></p><p>下面看一下符号段是什么样的，从下面看出，符号段每个表项包含下面的成员，下面是对各个成员的解释：</p><pre><code>Symnum n_type n_othr n_desc n_value  n_strx String</code></pre><ul><li><code>Symnum</code>是符号索引，换句话说，整个符号表看作一个数组，<code>Symnum</code>是当前符号在数组中的下标</li><li><code>n_type</code>是符号类型，<code>FUN</code>指函数名，<code>SLINE</code>指在<code>text</code>段中的行号</li><li><code>n_othr</code>目前没被使用，其值固定为0</li><li><code>n_desc</code>表示在文件中的行号</li><li><code>n_value</code>表示地址。特别要注意的是，这里只有<code>FUN</code>类型的符号的地址是绝对地址，<code>SLINE</code>符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。</li></ul><p>注意，下面这句两个指针相减得到的是数组的下标！</p><pre class=" language-c"><code class="language-c">rfile <span class="token operator">=</span> <span class="token punctuation">(</span>stab_end <span class="token operator">-</span> stabs<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>所以二分搜索利用下标对地址进行搜索！</p><p>我们先搜索到相应的源文件，然后对函数进行搜索，所以如下代码用来搜索行号</p><pre class=" language-c"><code class="language-c"><span class="token function">stab_binsearch</span><span class="token punctuation">(</span>stabs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lline<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rline<span class="token punctuation">,</span> N_SLINE<span class="token punctuation">,</span> addr<span class="token operator">-</span>info<span class="token operator">-></span>eip_fn_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lline <span class="token operator">></span> rline<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        info<span class="token operator">-></span>eip_line <span class="token operator">=</span> stabs<span class="token punctuation">[</span>lline<span class="token punctuation">]</span><span class="token punctuation">.</span>n_desc<span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><h2 id="三-reference"><a href="#三-reference" class="headerlink" title="三.reference"></a>三.reference</h2><p>1.<a href="https://www.cnblogs.com/wuhualong/p/lab01_exercise02_trace_into_bios.html">《MIT 6.828 Lab 1 Exercise 2》实验报告 - whl1729 - 博客园 (cnblogs.com)</a></p><p>2.<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6 - DRAFT as of September 4, 2018 (mit.edu)</a></p><p>3.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">elf.pdf (mit.edu)</a></p><p>4.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Lanugage (mit.edu)</a></p><p>5.<a href="https://blog.csdn.net/u011728480/article/details/62044567">C 可变参数函数分析(va_start,va_end,va_list…)_Sky的专栏-CSDN博客___builtin_va_start</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记传输层</title>
      <link href="/2021/06/16/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2021/06/16/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-传输层简介transport-layer"><a href="#一-传输层简介transport-layer" class="headerlink" title="一.传输层简介transport layer"></a>一.传输层简介transport layer</h2><h3 id="1-传输层作用"><a href="#1-传输层作用" class="headerlink" title="1.传输层作用"></a>1.传输层作用</h3><ul><li>进程间通信<ul><li>应用进程间的多路复用和解复用</li><li>用端口实现</li></ul></li><li>为应用程序提供端到端的服务<ul><li>可靠的，按序的数据交付</li><li>很好的交付节奏</li></ul></li><li>TCP和UDP是常用的运输层协议<ul><li>还有其他的，就不说了</li></ul></li><li>UDP是极简化的传输层协议<ul><li>只提供复用和分解能力</li></ul></li><li>TCP提供可靠的，按序的，字节流的抽象<ul><li>有拥塞控制，但是没有性能担保</li></ul></li></ul><h3 id="2-应用程序和套接字"><a href="#2-应用程序和套接字" class="headerlink" title="2.应用程序和套接字"></a>2.应用程序和套接字</h3><p>套接字（socket）：给应用进程和操作系统之间交换网络消息的一个软件抽象</p><p>传输层寻址：**&lt;HostIP , Port&gt;**，叫做一个套接字</p><p>两个重要的套接字类型：</p><ul><li>UDP套接字：TYPE是SOCK_DGRAM</li><li>TCP套接字：TYPE是SOCK_STREAM</li></ul><h3 id="3-端口"><a href="#3-端口" class="headerlink" title="3.端口"></a>3.端口</h3><ul><li>帮助区别APP的16比特的数字<ul><li>分组在传输层头带着src和dst端口号</li><li>有常用端口（0-1023）和临时端口</li></ul></li><li>OS存储套接字和端口的映射<ul><li>端口在分组里面，套接字在OS里</li><li>对于UDP端口，OS存储（local port，local IP）来映射套接字</li><li>对于TCP端口，OS存储（local port，local IP，remote port， remote IP）来映射套接字</li></ul></li></ul><h3 id="4-多路复用和多路分解"><a href="#4-多路复用和多路分解" class="headerlink" title="4.多路复用和多路分解"></a>4.多路复用和多路分解</h3><p>在发送方：处理来自多个套接字的数据，添加传输层头。</p><p>在接收方：用header信息来把收到的传输层报文段交付给正确的套接字。</p><h4 id="4-1-如何多路分解"><a href="#4-1-如何多路分解" class="headerlink" title="4-1 如何多路分解"></a>4-1 如何多路分解</h4><p>主机收到IP数据报，里面有源和目的IP，数据报携带传输层报文段，保温段里面有源和目的端口</p><p>主机用IP地址和端口号来把报文段导向正确的套接字</p><p><img src="/picture/format.png"></p><h5 id="4-1-1-无连接的多路分解"><a href="#4-1-1-无连接的多路分解" class="headerlink" title="4-1-1 无连接的多路分解"></a>4-1-1 无连接的多路分解</h5><p>对于UDP协议，当我们收到了目的端口相同，但是源端口或源IP不同的报文段，仍然要引导向同一个目的套接字</p><p>4-1-2基于连接的多路分解</p><p><strong>对于TCP协议，我们确定一个套接字通过一个4元组</strong></p><ul><li>源IP地址</li><li>源端口号</li><li>目的IP地址</li><li>目的端口号</li></ul><p>多路分解：接收方用四元组来导向正确的套接字</p><p>服务器主机或许支持许多同时的TCP套接字：每个套接字通过4元组来确定</p><p>下面是一个例子：</p><p><img src="/picture/socket.png"></p><h2 id="二-传输层设计"><a href="#二-传输层设计" class="headerlink" title="二.传输层设计"></a>二.传输层设计</h2><p>为什么要用传输层？</p><ol><li>IP分组寻址到一个主机，但是端到端的交流是介于进程之间的，需要一种方式（多路复用和分解）来定位到应用进程</li><li>IP提供很弱的服务模型（尽力而为）<ul><li>分组可能错误，延迟，丢包…</li><li>对拥塞情况没有控制</li><li>这些事情还不能让应用程序来处理</li></ul></li></ol><p>尽力而为协议可能做很多很不好的事情，所以我们需要可靠传输</p><p>我们处理这些不好事情需要一些机制：</p><ul><li>检验和：来检测错误</li><li>ACK：接受者告诉发送者收到了包</li><li>NACK：接受者告诉发送者没有收到包</li><li>序号：一种识别分组的方式</li><li>重传</li><li>超时</li><li>发送纠正后的包</li><li>网络编码</li></ul><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p><img src="/picture/sw.png"></p><p>这个协议比较可靠，但是比较低效，浪费带宽。</p><p><img src="/picture/ine.png"></p><p><img src="/picture/ine1.png"></p><h3 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h3><p>流水线：发送方允许多个飞行中的等待“被ACK“的分组。序号的必须增加，在接收方和发送方缓存。</p><p><img src="/picture/uti.png"></p><h4 id="三种设计决策"><a href="#三种设计决策" class="headerlink" title="三种设计决策"></a>三种设计决策</h4><p>哪一个包可以发送根据<strong>滑动窗口</strong></p><p>接收方如何发送ACK？有两种，积累的，选择性的</p><p>发送方需要重传哪些包？Go-Back N（GBN）回退n帧，Selective Repeat(SR)选择重传</p><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>窗口就是一些相邻的序号的集合，集合的大小是窗口大小，假定窗口大小是n</p><p>一次发送n个包：</p><ul><li>发送者可以发送窗口里的包</li><li>接受者可以接受窗口里的包</li><li>当收到ACK，可接受的包的窗口滑动</li></ul><p><img src="/picture/slide.png"></p><h5 id="积累确认"><a href="#积累确认" class="headerlink" title="积累确认"></a>积累确认</h5><p>累计确认永远确认的是还没有收到的序列号最小的那个</p><p><img src="/picture/ca.png"></p><p><img src="/picture/ca1.png"></p><h5 id="选择性确认"><a href="#选择性确认" class="headerlink" title="选择性确认"></a>选择性确认</h5><p>选择确认确认的是收到的包本身的序列！！！</p><p>收到一个正确的包就进行确认，这样需要记录下来哪些已经收到了</p><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>重传包：两种标准的方法：回退n帧GBN和选择重传SR</p><h5 id="回退N帧"><a href="#回退N帧" class="headerlink" title="回退N帧"></a>回退N帧</h5><p>发送方发送最多n个没有被ACK的包</p><p>接收方只按序接收，时序的分组会被丢弃</p><p>接收方用积累确认：ACK的序号等于下一个被期待的正确顺序的序号</p><p>发送方为第一个未完成的ack设置定时器（A+1），如果超时就重传A+1，A+2……</p><h5 id="GBN的滑动窗口"><a href="#GBN的滑动窗口" class="headerlink" title="GBN的滑动窗口"></a>GBN的滑动窗口</h5><p><img src="/picture/gbn.png"></p><p>下面是没有出错的GBN滑动窗口</p><p><img src="/picture/gbn1.png"></p><p>下面是出错的GBN滑动窗口，可以看出4在传输图中丢失了，那么5和6倍接收方丢弃，而4超时没收到ACK之后发送方重传456！！！</p><p><img src="/picture/gbn2.png"></p><h5 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h5><p>发送方发送最多n个没有被ACK的包</p><p>假定分组k丢掉了，<code>K+1</code>没有丢掉</p><ul><li>那么接收方：发送k+1的ACK</li><li>发送方：k超时，只重传k</li></ul><p>高效重传但是记账很复杂，<strong>对于每个包都要一个定时器</strong>！！！</p><p><img src="/picture/sr.png"></p><h5 id="GBN-vs-SR"><a href="#GBN-vs-SR" class="headerlink" title="GBN vs SR"></a>GBN vs SR</h5><p>什么时候GBN更好？错误率低，否则重传多余的包会浪费带宽</p><p>什么时候SR更好？错误率高，否则会搞得很复杂</p><p>对于滑动窗口，只要窗口大小足够大，就可以充分利用链接。</p><p>发送方不得不缓存所有没有被ACK的包，因为可能需要重传</p><p>接收方或许能够接收失序的包，但是不能超过缓存大小！</p><p>实现的复杂度取决于协议的细节！！！</p><h2 id="三-UDP"><a href="#三-UDP" class="headerlink" title="三.UDP"></a>三.UDP</h2><p>UDP是User Datagram Protocol（用户数据报协议）</p><p>TCP是Transmission Control Protocol（传输控制协议）</p><ul><li>进程之间的轻量级交流，避免了额外开销</li><li>目的IP地址和端口来支撑多路分解</li><li>尽力而为服务，UDP报文段或许会丢失，失序交付给app</li><li>无连接的，没有握手，每个UDP报文段都独立被处理</li></ul><p>UDP用：</p><ul><li>流多媒体APP</li><li>DNS</li><li>SNMP</li></ul><p>为什么要有UDP？</p><ol><li>不需要连接建立（没有额外时间开销）</li><li>简单：收发方都没有连接状态</li><li>header比较小</li><li>没有拥塞控制：UDP速度可以爆炸增长</li></ol><h3 id="UDP报文段的格式"><a href="#UDP报文段的格式" class="headerlink" title="UDP报文段的格式"></a>UDP报文段的格式</h3><p><img src="/picture/udp.png"></p><h4 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h4><p>检测传输地报文段的错误</p><p>进行16bit和的反码运算，值得注意的是，在进行16bit加法运算的时候如果有溢出就要进行回卷（把溢出位加到后面！！！），对最后的和进行反码运算</p><p>检验和字段是0意味着没有用检验和</p><h2 id="四-TCP"><a href="#四-TCP" class="headerlink" title="四.TCP"></a>四.TCP</h2><p>TCP交付可靠的，按序的字节流</p><h3 id="TCP头"><a href="#TCP头" class="headerlink" title="TCP头"></a>TCP头</h3><p><img src="/picture/TCP.png"></p><p>用源端口和目的端口来进行多路复用和分解</p><p>checksum用来计算数据和伪头</p><p>序列号是字节偏移量（因为TCP是一个字节流）</p><h3 id="TCP做什么"><a href="#TCP做什么" class="headerlink" title="TCP做什么"></a>TCP做什么</h3><ol><li>检验和</li><li>序号是字节偏移量</li><li>接收方发送积累确认（像GBN）</li><li>接收方缓存时序分组（像SR）</li></ol><h3 id="TCP引入什么"><a href="#TCP引入什么" class="headerlink" title="TCP引入什么"></a>TCP引入什么</h3><p>引入了快速重传机制：冗余的ACK触发早期重传</p><p>发送方维护一个单独的重传计时器，当超时就重传</p><p>那么我们如何确定超时时间是多少呢？</p><p>要跟RTT成一定比例，我们怎么知道RTT呢</p><p>RTT样本的指数加权平均值</p><p><img src="/picture/exp.png"></p><p>我们如何区分真的ACK和重传分组的ACK呢？</p><p><img src="/picture/ACK.png"></p><h4 id="Karn-Partridge算法"><a href="#Karn-Partridge算法" class="headerlink" title="Karn/Partridge算法"></a>Karn/Partridge算法</h4><p>不用来自重传的ACK，一旦重传就忽略后面的ACK报文段</p><p>用α=0.125来计算<code>EstimatedRTT</code></p><p>超时的值设置成<code>EstimatedRTT</code>的2倍</p><p>使用指数回退：当超时就让<code>RTO=2* RTO</code>。每次新的估计值（收到不是重传的ACK）出现，就回退到<code>2*EstimatedRTT</code></p><h4 id="Jacobson-Karels算法"><a href="#Jacobson-Karels算法" class="headerlink" title="Jacobson/Karels算法"></a>Jacobson/Karels算法</h4><p><img src="/picture/JK.png"></p><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><h4 id="双向握手"><a href="#双向握手" class="headerlink" title="双向握手"></a>双向握手</h4><p>A发送SYN，B回复SYN</p><p>如何识别就连接中的报文段</p><p>如何识别冗余过期的SYN</p><h5 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h5><p>用一个和之前连接不同的初始化序列号开始每段新连接</p><p>连接请求的形式为SYN i+1，其中i是将在此连接上发送的第一个数据段的序列号。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/picture/3.png"></p><p><img src="/picture/shake.png"></p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>正常的终止，一次一边</p><p><img src="/picture/fin1.png"></p><p>正常的终止，两边同时</p><p><img src="/picture/fin2.png"></p><p>意外终止</p><p><img src="/picture/fin3.png"></p><p>下面是客户机的生命周期</p><p><img src="/picture/client.png"></p><p>下面是服务器的生命周期</p><p><img src="/picture/server.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记应用层</title>
      <link href="/2021/06/14/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2021/06/14/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-多媒体网络应用"><a href="#一-多媒体网络应用" class="headerlink" title="一.多媒体网络应用"></a>一.多媒体网络应用</h2><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>以恒定速率采样的模拟音频信号</p><ul><li>telephone：8000样本每秒</li><li>CD音乐：44100样本每秒</li></ul><p>每个样本被量化，例如四舍五入(比如2^8=256种可能的量化值)</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>以恒定速率播放的图片序列，比如24张图片每秒</p><p>数字图片：像素的数组，每张图片通过比特来表示</p><p>编码：利用图片之间的冗余（相同的地方）来编码可以节省空间</p><ul><li>空间上的冗余：比如同一排一样的颜色，只需要发送一个颜色和重复的次数即可</li><li>时间上的冗余：相邻两帧只需要发送不一样的地方即可</li></ul><h3 id="三种应用类型"><a href="#三种应用类型" class="headerlink" title="三种应用类型"></a>三种应用类型</h3><h4 id="1-流媒体"><a href="#1-流媒体" class="headerlink" title="1.流媒体"></a>1.流媒体</h4><p>因为整个视频文件太大，所以变成”流“来存储音频和视频，在完全下载下来之前就可以播放。在服务器上面的存储：可以比音频或者视频传输地更快（意味着在客户机缓存）。</p><p>流媒体存储的视频：</p><p><img src="/picture/streaming.png"></p><p>存在一些挑战：</p><ul><li>持续的播放约束，一旦客户播放开始，重放就要匹配得上原来的时间。但是网络延迟是可变的，所以我们需要客户机端的缓冲区来匹配播放需要</li><li>客户机需要交互：暂停，快进，回退…</li><li>视频包可能会丢失</li></ul><p>改进之后：（多了buffer）</p><p><img src="/picture/s.png"></p><h5 id="利用的协议"><a href="#利用的协议" class="headerlink" title="利用的协议"></a>利用的协议</h5><p>UDP</p><p>服务器以一个对于客户合适的速率发送</p><p>要有一个比较短的播放延迟来对抗网络抖动</p><p>UDP可能穿不过防火墙</p><p>HTTP</p><p>通过<code>HTTP GET</code>来获取多媒体文件。在TCP下以一个最小的可能速率发送</p><p><img src="/picture/HTTPTCP.png"></p><p>填充速率波动取决于TCP拥塞控制，重传机制。需要更大的播放延时。HTTP/TCP可以轻松穿过防火墙</p><p>DASH</p><p>Dynamic，Adaptive Streaming over HTTP</p><p>发送方：</p><ul><li>把视频文件分为多个块</li><li>每个块都存下来，以不同的速率编码</li><li>清单文件：提供不同块的URL</li></ul><p>接收方：</p><ul><li>周期性测量服务器到客户的带宽</li><li>询问清单，一次性请求一个块。选择给定当前带宽下可以忍受的最小的编码速率，可以在不同的时间点根据不同带宽选择不同的速率。</li></ul><h4 id="2-基于IP的会话视频或音频"><a href="#2-基于IP的会话视频或音频" class="headerlink" title="2.基于IP的会话视频或音频"></a>2.基于IP的会话视频或音频</h4><p>人和人交互式的场景限制了对延迟的容忍度</p><p>VoIP</p><p>VoIP端到端延迟要求：更高的延迟会明显影响交互性。小于150ms：好，大于400ms：坏。包括应用的等级（分组，播放），网络时延</p><p>会话初始化：接电话的人如何通知它的IP地址，端口号，编码算法呢？</p><p>增值业务：电话转移，筛选，记录</p><p>紧急服务：911</p><h4 id="3-流媒体直播视频或音频"><a href="#3-流媒体直播视频或音频" class="headerlink" title="3.流媒体直播视频或音频"></a>3.流媒体直播视频或音频</h4><p>比如，体育赛事</p><p>三.因特网QoS</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/2021/06/14/NP%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/14/NP%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一-NP问题"><a href="#一-NP问题" class="headerlink" title="一.NP问题"></a>一.NP问题</h2><h3 id="1-优化问题和判定问题"><a href="#1-优化问题和判定问题" class="headerlink" title="1.优化问题和判定问题"></a>1.优化问题和判定问题</h3><p>优化问题是关注某种特殊的结构，并且希望优化该结构的某种指标。判定问题是给出某个特定的指标，来判断某个特殊结构是否可以满足这个指标。一般来说，优化问题可以转化成对应判定问题。下面的最大团问题就是一种优化问题。</p><h4 id="CLIQUE优化问题"><a href="#CLIQUE优化问题" class="headerlink" title="CLIQUE优化问题"></a>CLIQUE优化问题</h4><p>最大团问题：给定一个无向图G，如果G的子图H是一个完全图，那么称H是G的一个团（clique）。定义一个团的大小是它所含节点的个数，那么最大问题就是，给定一个无向图，请找到无向图中最大团的大小。</p><p>那么根据上面的抽象概念，我们所说关注的特殊结构就是团，而指标就是团的大小。一个优化问题可以定义对应的判定问题，判定问题关注同样的结构和同样的指标。但是和优化问题不同的是，判定问题往往给出指标的一个具体的值，问你“能不能”，“可不可以”。</p><p>那么下面我们就可以引出最大团问题对应的判定问题</p><h4 id="CLIQUE判定问题"><a href="#CLIQUE判定问题" class="headerlink" title="CLIQUE判定问题"></a>CLIQUE判定问题</h4><p>问题：给定一个无向图G，请问G中是否存在大小为k的团？</p><p>优化问题比判定问题难。当我们得到优化问题的解，就很容易知道判定问题的解；但是当我们得到判定问题的解，就很难得到优化问题的解。举个例子，我们知道图G的最大团大小为a，那么我问是否存在大小为k的团的时候，只需要比较a和k的大小就可以得到答案；但是当我知道存在大小为k的团，但无法判断是否还有更大的团，所以无法知道最大团的大小！</p><p>由此，我们看出优化问题比判定问题要难！！！</p><h3 id="2-P问题"><a href="#2-P问题" class="headerlink" title="2.P问题"></a>2.P问题</h3><p>P问题就是多项式时间内可解的问题。具体定义如下：</p><p>一个问题是P问题，如果存在关于n的一个多项式<code>poly(n)</code>，并且存在解决该问题的一个算法，满足算法的代价是<code>f(n)=O(poly(n))</code></p><p>P问题可以内聚为一个问题类，是因为多项式运算的封闭性。多项式时间是一个非常大的范围，比如说<code>n^1000000</code>也是一个多项式，但在现实生活中非常不实用。那么有一个问题出现了，我们为什么要引入P问题来研究问题的难度？问题的难易是相对的，多项式时间算法不一定实用，但是如果当算法的代价不是多项式时间的，那么我们可以断定这个问题在较大规模输入的时候必然是不实用的。我们关注的一些难问题，P问题是一个很有意义的分类。</p><p>优化问题和判定问题在难度上往往差距不大，严格的说，<strong>很多优化问题在多项式时间内可解，等价于它的判定问题在多项式时间内可解！</strong></p><p>那么，对于最大团问题，我们有：<strong>最大团问题的优化问题是多项式时间可解的，当且仅当它的判定问题是多项式时间可解的</strong>。</p><p>3.NP问题</p><p>定义过P问题，我们进一步定义NP问题。NP的名称来自<code>Non-deterministic P</code>，含义是非确定性算法在多项式时间内可解，也可以理解为在多项式时间内可验证。具体如下：</p><p>我们定义一个问题为NP问题，如果该问题的解在多项式时间内可验证。这里可验证的含义是首先我们先随便猜一个解，然后可以在多项式时间内可以检查这个解是不是该问题的正确的解。</p><p>定理：**<code>CLIQUE∈NP</code>**</p><p>证明：我们可以通过O(n)来猜想图中的任意k个顶点，然后来检查他们之间是否两两都有边，那么验证过程复杂度是O(k^2)=O(n^2)，所以我们可以在多项式时间内完成问题的验证！</p><h2 id="二-问题的归约"><a href="#二-问题的归约" class="headerlink" title="二.问题的归约"></a>二.问题的归约</h2><h3 id="归约的定义"><a href="#归约的定义" class="headerlink" title="归约的定义"></a>归约的定义</h3><p>问题P可以规约到Q的含义是解决问题P可以间接通过解决问题Q来实现。下面是P到Q的归约的定义：</p><p>判定问题P到Q的归约为一个转换函数<code>T(x)</code>满足：</p><ul><li>它能够将问题P的任意一个合法输入x转换成问题Q的一个合法输入<code>T(x)</code>。假设已经有了解决问题Q的算法，将<code>T(x)</code>输入到该算法，得到问题Q的一个输出。</li><li>P问题对于任意输入x的输出是YES，当且仅当Q问题对输入<code>T(x)</code>的输出是YES</li></ul><p><img src="/picture/gy.png" alt="P到Q的归约"></p><p>在定义归约时，我们看到了研究判定问题带来的便利。不同算法问题的解可能非常不一样，但是如果仅仅讨论判定问题的话，问题的解都是YES或者NO，这样为两个判定问题之间的归约带来了很多便利！！！</p><h3 id="归约代价和问题难度的比较"><a href="#归约代价和问题难度的比较" class="headerlink" title="归约代价和问题难度的比较"></a>归约代价和问题难度的比较</h3><p>我们引入问题的归约是为了衡量问题间相对的难易程度。我们需要对归约作出一定限制，下面定义多项式时间归约<code>≤p</code>：</p><p>如果T是问题P到Q的归约，且T的代价为其输入规模的多项式，则称问题P可以多项式时间归约到问题Q，记为<code>P ≤p Q</code></p><p>对于一个难问题而言，输入转换代价如果是多项式的，那么这个代价对于解决问题的代价而言是一个小量，所以研究难问题之间的难以关系时，我们集中关注多项式时间归约。如果<code>P ≤p Q</code>，说明P的难度不超过Q的难度。对于多项式时间归约，我们有：</p><p><strong>多项式时间归约关系是一个传递关系，即对于问题P，Q，R，如果<code>P ≤p Q</code>，<code>Q ≤p R</code>，那么<code>P ≤p R</code>。</strong></p><h2 id="三-NP完全问题"><a href="#三-NP完全问题" class="headerlink" title="三.NP完全问题"></a>三.NP完全问题</h2><p><strong>NP难问题定义：一个问题P是NP难问题，如果对于属于NP的任意问题Q，<code>Q ≤p P</code></strong></p><p><strong>NP完全问题：一个问题P是NP完全问题，如果<code>P∈NP</code>，并且P是NP难问题</strong></p><p>参考书：《算法设计与分析》第二版–黄宇</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP复杂性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-零钱兑换问题</title>
      <link href="/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="零钱兑换系列问题"><a href="#零钱兑换系列问题" class="headerlink" title="零钱兑换系列问题"></a>零钱兑换系列问题</h1><h2 id="1-零钱兑换1"><a href="#1-零钱兑换1" class="headerlink" title="1.零钱兑换1"></a>1.零钱兑换1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这道题目是力扣上面的题目，最近正好在学DP就做了个题解</p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>提示</p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们先从暴力方法入手，我们只需要<code>DFS</code>遍历所有可能的组合数量就可以从中找到一个最优解，但是这样暴力枚举的复杂度相当大，我们需要想一个更加优秀的算法。这种问题我们还是用递归更加恰当，试想我们想知道金额x最少需要多少，那么我只需要知道金额<code>x-coin_i(i&gt;=0 &amp;&amp; i&lt;size)</code>最少需要多少枚硬币，然后找到它们最小那个加一就行了，这样利用了动态规划的思想，站在前人的成果之上来解题，就方便了很多，所以我们只需要从1开始计算到amount分别最少需要多少钱就可以了</p><p>状态转移方程：<code>dp[i]=min(dp[i-coin_j]+1) (j&gt;=0 &amp;&amp; j&lt;coins.size)</code></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    int coinChange(vector<int>& coins, int amount) {        vector<int> dp(amount+1,INT_MAX-1);        dp[0]=0;        for(int i=1;i<=amount;i++){            for(auto coin:coins){                if(i-coin>=0){                    dp[i]=min(dp[i],dp[i-coin]+1);                }            }        }                return dp[amount]<INT_MAX-1?dp[amount]:-1;    }};</code></pre><h2 id="2-零钱兑换2"><a href="#2-零钱兑换2" class="headerlink" title="2.零钱兑换2"></a>2.零钱兑换2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><pre><code>输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题跟</p><p>类似，但是他们要求解的东西不一样，那道题要求凑成总金额需要最少的硬币数，这道题要求有多少种可以凑成总金额的组合</p><p>对于某一个金额x，我们可以查看<code>x-coin_i</code>的组合数，加到一起即可，等等…我是不是忘了什么，这样很可能出现重复的组合，比如说<code>amount=5</code>，<code>coins=[1,2,5]</code>，那么1+2可以组合成3，那么3+2可以组合成5；2+2可以组合成4，那么4+1可以组合成5，所以<code>1+2+2=5</code>这个组合至少用了两次！！！所以这种做法需要被<code>pass</code>掉！！！</p><p>那么正确的做法应该是什么呢？我们可以在外层对硬币金额进行遍历，内层更新每一个金额。这样每层循环解释起来就是，我用前k种硬币，凑成每一种金额有多少组合。那么我进行每一次遍历的时候，我之前积累起来的是用前k种硬币有多少种，那么加上第k+1种硬币能够有多少种。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    int change(int amount, vector<int>& coins) {        vector<int> dp(amount+1,0);        dp[0]=1;        for(auto coin:coins){            for(int i=coin;i<=amount;i++){                dp[i]+=dp[i-coin];            }        }        return dp[amount];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记网络层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-网络层的功能"><a href="#一-网络层的功能" class="headerlink" title="一.网络层的功能"></a>一.网络层的功能</h2><ol><li>从发送主机到接收主机传送报文段</li><li>在发送端把运输层报文段封装进网络层数据报</li><li>在接收方，把报文段递交给运输层</li><li>在每一个主机和路由器都有运输层协议</li><li>路由器检查IP数据报的header域，然后通过它传递</li></ol><p><img src="/picture/zzy.png"></p><p>两个关键的功能：</p><p>交换和路由：运用路由算法决定从源到目的发包的路由路线，找到从源到目的最短路线（路由决定转发表）</p><p>转发：从输入端口转发到特定的输出端口，进行错误处理排队和调度</p><p>连接建立：在数据报开始发送之前，终端主机和路由器之间建立虚拟连接（和运输层对比，网络层的连接建立是包括主机和路由器，而运输层是在两个主机进程之间！）</p><h2 id="二-网络服务模型"><a href="#二-网络服务模型" class="headerlink" title="二.网络服务模型"></a>二.网络服务模型</h2><p>信道的什么服务模型来从发送方到接收方传输数据报？</p><h3 id="例子：ATM的网络服务模型"><a href="#例子：ATM的网络服务模型" class="headerlink" title="例子：ATM的网络服务模型"></a>例子：ATM的网络服务模型</h3><p>恒定比特率（CBR）和可变比特率（VBR），有效比特率和未定义比特率</p><p><img src="/picture/atm.png"></p><h3 id="例子：IP的网络服务模型"><a href="#例子：IP的网络服务模型" class="headerlink" title="例子：IP的网络服务模型"></a>例子：IP的网络服务模型</h3><p>尽力而为</p><p><img src="/picture/ip.png"></p><h2 id="三-IP路由器"><a href="#三-IP路由器" class="headerlink" title="三.IP路由器"></a>三.IP路由器</h2><p>互联网基础设施的核心！</p><p>路由器的容量=NXR（其中N是外部路由端口的数量，R是每个端口的速率）</p><p><img src="/picture/isp.png"></p><h3 id="不同类型的路由器"><a href="#不同类型的路由器" class="headerlink" title="不同类型的路由器"></a>不同类型的路由器</h3><h4 id="1-核心路由器"><a href="#1-核心路由器" class="headerlink" title="1.核心路由器"></a>1.核心路由器</h4><p>R = 10/40/100/200/400 Gbps  NR = O(100) Tbps (总共)</p><h4 id="2-边缘路由器"><a href="#2-边缘路由器" class="headerlink" title="2.边缘路由器"></a>2.边缘路由器</h4><p>R = 1/10/40/100 Gbps NR = O(100) Gbps</p><h4 id="2-小型商用"><a href="#2-小型商用" class="headerlink" title="2.小型商用"></a>2.小型商用</h4><p>R = 1 Gbps  NR &lt; 10 Gbps</p><h3 id="路由器的内部：架构概览"><a href="#路由器的内部：架构概览" class="headerlink" title="路由器的内部：架构概览"></a>路由器的内部：架构概览</h3><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h4><p><img src="/picture/router%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88.png"></p><h4 id="2-输入端口"><a href="#2-输入端口" class="headerlink" title="2.输入端口"></a>2.输入端口</h4><p><img src="/picture/11.png"></p><p>输入端口的任务：</p><ul><li>收到包（物理层的任务）</li><li>更新IP头：TTL，checksum，可选字段，切片等</li><li>查找目的IP对应的合适的输出端口</li><li>排队：如果包到达太快就要缓存排队</li></ul><h5 id="查找合适的输出端口"><a href="#查找合适的输出端口" class="headerlink" title="查找合适的输出端口"></a>查找合适的输出端口</h5><p>如果一个表项对应一个地址就要有40亿个表项，为了可扩展性，地址是聚合的，目标地址按一定范围映射。<strong>按照最长前缀匹配规则</strong></p><p><img src="/picture/%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80.png"></p><p>由于一个个表项匹配复杂度有点高，我们可以利用树形结构</p><p><img src="/picture/tree.png"></p><h5 id="处理速度"><a href="#处理速度" class="headerlink" title="处理速度"></a>处理速度</h5><p>输入端口的任务要更新包头还有转发表查询，大多数被硬件处理！</p><h4 id="3-输出端口"><a href="#3-输出端口" class="headerlink" title="3.输出端口"></a>3.输出端口</h4><p><img src="/picture/outputport.png"></p><p>输出端口任务：</p><ul><li>包分类：把包映射到流里面</li><li>缓冲处理：决定什么时候和哪些包要扔掉</li><li>调度：决定哪些包什么时候传输（从排队的包里面选择进行传输，当buffer满了就要选择包丢弃）</li></ul><p>缓冲处理先进先出：最简单，没有分类，buffer满了的话就丢掉后来的包</p><p><img src="/picture/fifo.png"></p><p>包分类：根据header域来把IP包分类，比如源和目的的IP地址，源和目的的TCP端口号，服务类型，协议类型……</p><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>对于每一个流（“flow”）都有一个队列，调度器决定什么时候才能够哪个队列发包。调度器的目标是：快！</p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>在最高优先级的要在低优先级之前转发</p><h6 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h6><p>轮转：每个队列里的包被轮流调度</p><p>公平排队（FQ）：对于不同大小的队列进行轮转调度</p><p>加权公平队列（WFQ）：按照权重比例来调度</p><h4 id="4-交换结构"><a href="#4-交换结构" class="headerlink" title="4.交换结构"></a>4.交换结构</h4><p>交换结构用来连接输入端口和输出端口，从输入buffer传送到合适的输出buffer。</p><p>交换速率：包可以从输入端口到输出端口传送的速率</p><p>有三种结构来交换：</p><ul><li>通过共享内存交换</li><li>通过总线交换</li><li>通过物联的网络交换：比如横梁</li></ul><p><img src="/picture/3%E7%A7%8D.png" alt="三种交换结构"></p><h5 id="4-1-通过共享内存交换"><a href="#4-1-通过共享内存交换" class="headerlink" title="4-1 通过共享内存交换"></a>4-1 通过共享内存交换</h5><p>第一代路由器采用这种，它是一种直接在CPU控制下交换的传统的电脑，分组被拷贝到系统的内存里面。速度被内存的带宽限制</p><h5 id="4-2-通过总线交换"><a href="#4-2-通过总线交换" class="headerlink" title="4-2 通过总线交换"></a>4-2 通过总线交换</h5><p>数据报通过共享总线从输入端口内存传送到输出端口内存，速率被总线的带宽限制</p><h5 id="4-3-通过网状结构交换"><a href="#4-3-通过网状结构交换" class="headerlink" title="4-3 通过网状结构交换"></a>4-3 通过网状结构交换</h5><p>克服了总线带宽的限制</p><h2 id="四-虚电路和数据报网络"><a href="#四-虚电路和数据报网络" class="headerlink" title="四.虚电路和数据报网络"></a>四.虚电路和数据报网络</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>为了传输数据会预留端到端的资源（比如带宽和交换能力）</p><p>专用的资源，没有共享</p><p>对性能有保证</p><p>连接需要建立和撤销</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>每个端到端的数据流被划分为分组</p><p>应用A，B的分组共享网络资源</p><p>存储和转发：分组一次移动一跳，并且在交换机里需要排队</p><p>资源争夺：总共的资源需要量可以超过可获得的资源总量总量</p><p>拥塞：分组排队和等待链路</p><h4 id="分组交换的两种类型"><a href="#分组交换的两种类型" class="headerlink" title="分组交换的两种类型"></a>分组交换的两种类型</h4><p>虚电路网络：对信息流提供网络服务，VC网络提供基于服务的网络连接，比如ATM，X.25，Frame Relay</p><p>数据报网络：对单个的分组提供网络服务，数据报网络提供网络层无连接服务，例如IP网络</p><p><img src="/picture/%E8%99%9A%E7%94%B5%E8%B7%AF%E8%B7%AF%E7%94%B1.png" alt="虚电路路由"></p><p><img src="/picture/%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%B7%AF%E7%94%B1.png" alt="数据报路由"></p><h5 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h5><ul><li>对于每个信息流要进行连接建立和拆除</li><li>每个分组带着VC号</li><li>在源到目的路径上的每个交换机维护每个传输连接的状态</li><li>连接，交换资源（带宽，缓存）或许被分配给虚电路</li></ul><h6 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h6><p>这个是虚电路网络的必要功能，两个主机和中间交换机预留一条路径给虚连接，路由没用来找到一条合适的路径</p><h6 id="虚电路的实现"><a href="#虚电路的实现" class="headerlink" title="虚电路的实现"></a>虚电路的实现</h6><p>一个虚电路包括一条从源到目的的路径，还包括VC号（每个链路一个），交换机里面转发表的表项。</p><p>注意：属于VC的分组携带VC号（而不是地址！！！），VC号可能在每条链路上被改变，转发表列出了新的VC号</p><p>VC的转发表如下：</p><p><img src="/picture/vc%E8%BD%AC%E5%8F%91%E8%A1%A8.png" alt="vc转发表"></p><h6 id="信令协议"><a href="#信令协议" class="headerlink" title="信令协议"></a>信令协议</h6><p>被用来建立，维护，拆除虚电路</p><p>被用在ATM，frame-relay，X.25</p><p>现在已经不用了</p><p><img src="/picture/%E4%BF%A1%E4%BB%A4%E5%8D%8F%E8%AE%AE.png" alt="信令协议"></p><h5 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h5><p>在网络层不需要连接建立，没有网络层的“连接”概念</p><p>交换：没有端对端的链接的状态</p><p>用目的主机地址来进行分组转发</p><p>在同一组源和目的之间或许会有不同的路径</p><p><img src="/picture/sjbwl.png" alt="数据报网络发包"></p><p>数据报网络的转发表：</p><p><img src="/picture/datagram.png" alt="数据报网络转发表"></p><h5 id="数据报网络和虚电路的对比"><a href="#数据报网络和虚电路的对比" class="headerlink" title="数据报网络和虚电路的对比"></a>数据报网络和虚电路的对比</h5><p>数据报：</p><ul><li>在计算机间交换数据，有弹性，没有严格的计时</li><li>聪明的端系统：可以适应，控制，错误恢复，网络内部简单，边缘复杂</li><li>不同的链路类型：不同的特点，统一的服务是很困难的</li></ul><p>虚电路：</p><ul><li>从电话演变而来</li><li>人类的交流，有严格的时限，需要可靠性，需要服务保障</li><li>沉默的端系统：电话，网络内部复杂</li><li>链路类型统一化</li></ul><h2 id="五-IP协议"><a href="#五-IP协议" class="headerlink" title="五.IP协议"></a>五.IP协议</h2><p><code>IP=Internet Protocol</code>，最著名的因特网协议，它被<code>ARPANET</code>开发</p><p>IP层的内容位于各个主机和路由器上，提供无连接服务</p><p>网络层的概览：</p><p><img src="/picture/ipwlc.png" alt="网络层"></p><h3 id="因特网寻址"><a href="#因特网寻址" class="headerlink" title="因特网寻址"></a>因特网寻址</h3><h5 id="寻址等级"><a href="#寻址等级" class="headerlink" title="寻址等级"></a>寻址等级</h5><p>物理因特网地址：用于PDU（目的MAC地址）在单个物理网络中的路由</p><p>因特网地址：IP地址或者因特网地址，用于在网络中路由PDU。对于每个端系统或者介质系统都有唯一的地址</p><p>应用层地址：在目的主机分配的进程ID，比如TCP/IP端口</p><h5 id="寻址作用域"><a href="#寻址作用域" class="headerlink" title="寻址作用域"></a>寻址作用域</h5><p>全局地址</p><p>网络连接地址</p><p>端口地址：在网络层之上并且在一个系统独一无二，例如端口80-TCP/IP的网络服务器监听端口</p><h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>个人或者单播寻址</p><p>广播地址</p><p>多播地址</p><p>任播地址</p><p><img src="/picture/al.png" alt="地址层级"></p><h3 id="IP的操作"><a href="#IP的操作" class="headerlink" title="IP的操作"></a>IP的操作</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li><p>主机和路由器维护路由表，指出数据报应被发送到的下一个路由器，静态-可能包含可替代的路径，动态-对拥塞和错误灵活的回复</p></li><li><p>路由策略：距离向量，链路状态，路径向量</p></li></ul><h4 id="数据报的生存期"><a href="#数据报的生存期" class="headerlink" title="数据报的生存期"></a>数据报的生存期</h4><p>数据报可能无限期地在两个路由器间循环</p><p>我们给数据报一个生存时间可以解决这个问题：在IP头里面放了一个TTL域（Time to live）</p><h3 id="IP结构"><a href="#IP结构" class="headerlink" title="IP结构"></a>IP结构</h3><p>IP分组包括头和负载：</p><ul><li>负载对于网络层是不透明的</li><li>头是我们需要关注的</li><li>IP层第一个端到端的层级（从下往上看）</li></ul><p>IP头是如何设计出来的呢？</p><p>我们思考一下IP头是一种在源和目的，源和中间路由器间传递网络信息的接口，那么我们设计它的话需要考虑他有多少使命要完成，很多东西既然存在必然会尤其需要的地方：需要它-&gt;被设计出来。</p><p>IP的功能：</p><ul><li>解析包</li><li>能把包送到目的</li><li>处理路上的一些问题：循环（bugs），错误，包过大</li><li>可以根据情况调节革新</li><li>处理特殊情况</li></ul><h4 id="1-解析包"><a href="#1-解析包" class="headerlink" title="1.解析包"></a>1.解析包</h4><p>首先，想要解析包，就要根据固定的格式，不同的版本格式可能不同，所以我们需要<code>IP version number（4bit）</code>，包的长度（16bit，用来查看是否有optional域，如果没有就是20byte）</p><p><code>Header length</code>表明头里面有多少个4字节，一般是5（20bype），如果有<code>Options</code>域的话可能就更多</p><h4 id="2-把包送到目的"><a href="#2-把包送到目的" class="headerlink" title="2.把包送到目的"></a>2.把包送到目的</h4><p>需要目的IP地址，32bit</p><p>我们插入一个小插曲，辨析一下MAC地址和IP地址的区别</p><table><thead><tr><th>MAC地址</th><th>IP地址</th></tr></thead><tbody><tr><td>在适配器生产时被硬编码</td><td>后期被配置的，可以被动态学习到</td></tr><tr><td>扁平的48bit的名空间</td><td>层级式的32bit名空间</td></tr><tr><td>类似身份证号</td><td>类似邮政地址</td></tr><tr><td>可携带的，不管主机移动到哪都不变</td><td>不可携带，取决于主机在哪个地方</td></tr><tr><td>被用来在同一个网络下传送包</td><td>用来给目的IP子网传送包</td></tr></tbody></table><h4 id="3-处理路径上的问题"><a href="#3-处理路径上的问题" class="headerlink" title="3.处理路径上的问题"></a>3.处理路径上的问题</h4><p>循环：为了破除循环，设计了<code>TTL(Time to Live)</code>，8bit</p><p>错误：检验和<code>checksum(16bit)</code></p><p>包太大：分段域，一共32bit，里面还有更细致的划分</p><h5 id="3-1TTL"><a href="#3-1TTL" class="headerlink" title="3-1TTL"></a>3-1TTL</h5><p>因为一些<code>bugs</code>造成包在网络中循环，这样积累起来会慢慢消耗掉网络的所有容量，所以我们设计了TTL域，开始的时候设置一个值，在每一跳都减一，当减为0的时候就丢弃这个包并且给源地址发送”Time exceeded”超时错误包</p><h5 id="3-2错误"><a href="#3-2错误" class="headerlink" title="3-2错误"></a>3-2错误</h5><p>需要检验和，在包头有一个特定的格式，如果检查出错误就丢包。</p><p>有一个问题，就是为什么在每一个路由器都要重新计算检验和呢？是因为<code>TTL</code>的改变或者包的切片会导致<code>checksum</code>发生变化！</p><h5 id="3-3分片"><a href="#3-3分片" class="headerlink" title="3-3分片"></a>3-3分片</h5><p>每一个链路都有最大传输单元（<code>MTU</code>），就是它所能承载的最大比特数量</p><p>如果包的大小超出了链路的MTU，一个路由器可以把包分成多个片。我们在目的主机必须重组恢复成最原始的包。</p><p>下面我们举一个例子：</p><p>一个<code>4000byte</code>大小的包要穿越一个<code>MTU</code>是<code>1500byte</code>的链路</p><p>那么可以切成下面这样的3片</p><p><img src="/picture/qp1.png" alt="切片"></p><p>有一个问题，切片之后为什么还要重组？下面的图片给了解答</p><p>因为上层协议的包头都在一个包的前面，后面都是数据的部分，所以我们要重组以便能够完整地交付给上层</p><p><img src="/picture/whyre.png" alt="why重组"></p><p>那么又有问题来了，我们在哪里重组？目的主机？还是路由器？</p><p>这个是端到端原理的典型案例</p><p>在如果由路由器重组就给网络带来了负担，因为重组算法比较复杂，要维护各种状态；而且切片不一定走同一条路径，所以可能很多路由器得到的切片是一些碎片。所以在中间路由器重组是事倍功半的，所以在目的主机重组</p><p>那么我们重组需要那些信息来填充字段呢？</p><p>我们需要来找到切片属于哪个分组，所以分组的ID被需要；我们还要知道每个切片是分组的哪部分，所以需要偏移量字段；<code>Flag</code>字段：</p><ul><li><code>Reserved</code>：目前被忽略</li><li>DF：不要被切片，可能会触发错误包发回发送者</li><li>MF：置1，表示这个不是末尾的切片</li></ul><p>下面我们来举个分片的例子</p><p><img src="/picture/%E5%88%86%E7%89%871.png"></p><p><img src="/picture/%E5%88%86%E7%89%872.png"></p><p><img src="/picture/%E5%88%86%E7%89%873.png"></p><p><img src="/picture/%E5%88%86%E7%89%874.png"></p><p><img src="/picture/%E5%88%86%E7%89%875.png"></p><h4 id="4-支持更新"><a href="#4-支持更新" class="headerlink" title="4.支持更新"></a>4.支持更新</h4><p>通过版本号<code>version number(4 bit)</code>，或许还可以算上”特殊处理域“</p><h4 id="5-支持一些特殊处理"><a href="#5-支持一些特殊处理" class="headerlink" title="5.支持一些特殊处理"></a>5.支持一些特殊处理</h4><h5 id="5-1特殊处理域"><a href="#5-1特殊处理域" class="headerlink" title="5-1特殊处理域"></a>5-1特殊处理域</h5><p><code>Type of Service</code>服务类型域</p><p>允许包被按需对待，比如不同的优先级，不同的拥塞提醒之类的（比如说一些实时语音通话比较注重时延，一些文件比较注重准确率）。在不同的运营商（自治域）可能要被重新定义</p><h5 id="5-2Options"><a href="#5-2Options" class="headerlink" title="5-2Options"></a>5-2Options</h5><p>它是可变长度，解析时候通过<code>packet len</code>字段来判断是否有<code>Options</code></p><h4 id="6-其他一些字段"><a href="#6-其他一些字段" class="headerlink" title="6.其他一些字段"></a>6.其他一些字段</h4><h5 id="源地址"><a href="#源地址" class="headerlink" title="源地址"></a>源地址</h5><p>我们需要告诉目的端系统是谁发来的包，所以需要<code>Source Address</code>字段</p><h5 id="协议Protocol"><a href="#协议Protocol" class="headerlink" title="协议Protocol"></a>协议Protocol</h5><p>告诉我们上层协议是什么，对于接收主机端的多路分解很重要，告诉主机要交付给哪个上层协议</p><p><img src="/picture/protocol.png" alt="协议栈"></p><h3 id="IPv4头"><a href="#IPv4头" class="headerlink" title="IPv4头"></a>IPv4头</h3><p><img src="/picture/ipv4.png" alt="IPv4"></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4地址枯竭迫使它的出现，专注于简化IP协议，抛弃一些不必要的字段，形成了一种优雅，无二义性的协议</p><p><img src="/picture/%E5%AF%B9%E6%AF%94.png" alt="IPv4和IPv6的对比"></p><p>总结一下这些变化：</p><ol><li>切片被清除</li><li>校验和被清除</li><li>options字段被清除</li><li>头的长度字段被清除</li><li>扩展了地址大小</li><li>添加了流标签</li></ol><h4 id="IPv6头"><a href="#IPv6头" class="headerlink" title="IPv6头"></a>IPv6头</h4><p><img src="/picture/ipv6.png" alt="IPv6头"></p><h5 id="Traffic-Class字段"><a href="#Traffic-Class字段" class="headerlink" title="Traffic Class字段"></a>Traffic Class字段</h5><h5 id="Flow-Label字段"><a href="#Flow-Label字段" class="headerlink" title="Flow Label字段"></a>Flow Label字段</h5><p>什么是流？</p><p>它是一个从特定源到特定目的的分组的序列</p><p>从主机的视角来看，由一个应用生成并且有同样的传输服务要求，或许包含一个单独的或者多个TCP连接。一个应用可能生成一个或者多个流</p><p>从路由器的视角看，这个是影响这些包如何被路由器处理的共享属性</p><p>流是独一无二的标识，被源和目的地址标识和非零的流标签所定义。流需求被定义优先于流的发端。路由器通过简单的在一个表中查询流标签来决定如何路由和处理分组。</p><h5 id="IPv6头的结构（包含拓展的header）"><a href="#IPv6头的结构（包含拓展的header）" class="headerlink" title="IPv6头的结构（包含拓展的header）"></a>IPv6头的结构（包含拓展的header）</h5><p><img src="/picture/ipv6s.png"></p><p>可选的部分在拓展headers里面，在主header后面呈菊花链状</p><p><img src="/picture/header.png"></p><p>这些header是按序出现的</p><p>路由器在ipv6里面不切片，因为要在核心里面更有效率的处理，切片已经在主机里面做好了。如果包在下一跳发现太大了，那么就发送包太大error消息（ICMPv6消息）</p><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>iPv6没有广播，有一个“全部节点”多播群组：ff02::1</p><p>广播的缺点，它唤醒了全部节点，实际上只有很少的设备被需要，可能造成广播风暴</p><h5 id="邻居节点探索"><a href="#邻居节点探索" class="headerlink" title="邻居节点探索"></a>邻居节点探索</h5><p>IPv6没有ARP，取而代之的是<code>Neighbor Discovery</code>，使用<code>ICMPv6</code>和多播</p><p><code>Neighbor Discovery</code>被节点使用为了获取地址，发现邻居路由器，跟踪地址变化，检查邻居可达性，做地址复制检测</p><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>128bit，单个接口或许有多个单播地址，有三种类型地址：单播，多播，任播</p><h4 id="从IPv4迁移到IPv6"><a href="#从IPv4迁移到IPv6" class="headerlink" title="从IPv4迁移到IPv6"></a>从IPv4迁移到IPv6</h4><p>所有节点不可以同时更新，所以需要有一种机制让IPv4和IPv6同时工作。</p><p>两种可能：</p><ul><li>双栈技术</li><li>隧道：在IPv4路由器中，在IPv4数据报中的IPv6头被当做数据负载</li></ul><h2 id="六-IP地址"><a href="#六-IP地址" class="headerlink" title="六.IP地址"></a>六.IP地址</h2><p>IP地址是32位的全局地址，分为网络部分（高位）和主机部分（低位）</p><p>对于主机和路由器的每个物理接口都需要一个通向一个网络的分离的地址。</p><p>使用十进制点的记法</p><p>网络部分ID被如下的三个机构管辖：</p><ul><li>American Registry for Internet Numbers (ARIN)</li><li>Reseaux IP Europeens (RIPE）</li><li>Asia Pacific Network Information Centre (APNIC)</li></ul><p>主机部分ID被指定的组织来分配</p><h3 id="IPv4地址格式"><a href="#IPv4地址格式" class="headerlink" title="IPv4地址格式"></a>IPv4地址格式</h3><p>分为A类地址，B类地址，C类地址……</p><p><img src="/picture/ipv4dizhi.png" alt="IPv4地址"></p><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p><img src="/picture/A.png" alt="A类地址"></p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p><img src="/picture/B.png" alt="B类地址"></p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p><img src="/picture/C.png" alt="C类地址"></p><h3 id="子网和子网掩码"><a href="#子网和子网掩码" class="headerlink" title="子网和子网掩码"></a>子网和子网掩码</h3><p>处理网络地址不足，地址的主机部分分为子网号和主机号。子网掩码指出哪些比特是子网号，哪些是主机号，每个局域网被分配一个子网号，本地路由器在子网里面路由</p><p>子网对于因特网的其余部分看起来像一个单独的网络，把全部的网络从网络号和路由的复杂中隔离出来</p><p><img src="/picture/subtorest.png"></p><p><img src="/picture/route.png"></p><h3 id="CIDR记法"><a href="#CIDR记法" class="headerlink" title="CIDR记法"></a>CIDR记法</h3><p>无类域间路由，一个IP地址以“A.B.C.D/n”的形式被呈现，n叫做IP前缀</p><p><img src="/picture/CIDR.png"></p><h2 id="七-网络层协议簇"><a href="#七-网络层协议簇" class="headerlink" title="七.网络层协议簇"></a>七.网络层协议簇</h2><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h3><p>对内部和外部流量启用不同的IP地址</p><p>网络地址转换发生在带有更广阔的因特网的内联网接口</p><p>目的：</p><ul><li>作为一个防火墙隐藏内部IP地址</li><li>允许一个组织使用更多的内部IP地址</li><li>隔离组织的变化</li></ul><p>下面有3种NAT：</p><ul><li>静态NAT：一个私有的IP地址映射到一个预留的共有IP地址，用于网络服务器</li><li>动态NAT：NAT路由器保持一个已注册IP地址池，在需要的时候分配给私有IP地址，通常用于客户内部网PC</li><li>单地址：NAT/Overloading/Masquerading/Network Address  Port Translation (NAPT）</li></ul><p>图解NAT：</p><p><img src="/picture/NAT.png"></p><p><img src="/picture/overload.png"></p><p><img src="/picture/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="网络地址转换"></p><p>NAT是很有争议的，地址不时会发生变化，必须被P2P应用纳入考虑</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><code>Internet Control Message Protocol</code></p><p>用来在主机和路由器间传播错误和控制消息</p><ul><li>Echo请求和Echo回复被用来诊断网络</li><li>还会传达关于问题的反馈，比如超时，不可达主机……</li></ul><p>被封装在IP数据报里面</p><ul><li><code>Protocol type=1</code></li><li>不可靠</li></ul><p><img src="/picture/ICMP.png" alt="ICMP信息格式"></p><p><img src="/picture/ICMP1.png" alt="ICMP类型"></p><p><img src="/picture/ICMP2.png" alt="ICMP不同类型格式"></p><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>测试目的地址是否可达，源发送一个<code>echo request</code>给遥远的主机或者路由器。如果远程系统收到了<code>ICMP</code>包，他会给源回复一个<code>echo reply</code>。</p><p>ping的实用程序可以做得更好，比如计算从发送到接收时间，计算到目的有多少跳</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>用来测量到目的地址需要多少跳</p><ol><li>源发送TTL等于1的第一个IP（UDP）包，第一个路由器把TTL减为0，然后发送TTL超时错误给源。源计算RTT，然后重复三次</li><li>源发送第二个IP包（TTL设置为2），第二个路由器发回TTL超时错误，源计算RTT，然后重复三次</li><li>源继续增加TTL知道到达目的</li></ol><p>Path MTU</p><p>用来找到路径上的最小MTU</p><ol><li>源发送不带有切片位的大IP包</li><li>如果包太大，相关路由器会发送错误包</li><li>源相应减小包的大小，再次尝试</li><li>重复直到包到达目的（没有收到错误包）</li></ol><h2 id="八-移动IP"><a href="#八-移动IP" class="headerlink" title="八.移动IP"></a>八.移动IP</h2><p>移动IP标准在1996年被IESG批准，同年被IETF作为一种被提议的标准发布。它被发明出来是为了应对日益增长的PDA和Laptop的使用需求。</p><p>数据报从一个网络移动到另一个网络需要用到目的的IP地址，IP地址被划分为两部分<code>&lt;netID,hostID&gt;</code>，大多数网络应用支持<code>TCP</code>连接，<code>TCP</code>使用IP地址和端口号来路由和交付。当移动设备从一个网络移动到另一个的时候，它的IP地址动态改变，因此TCP连接在每次移动的时候需要重启正在进行的会话。移动IP正在解决动态变化的IP地址的问题，就不必重启TCP，就好像移动设备的IP地址假装没改变</p><p><img src="/picture/mip.png"></p><h3 id="不同的实体"><a href="#不同的实体" class="headerlink" title="不同的实体"></a>不同的实体</h3><p>移动节点：一个或许会改变它的接入点或者从一个网络到另一个网络连接的主机</p><p>通信节点：一个要给移动节点发包的主机</p><p>归属代理：一个在归属网络上维护一个已注册移动节点列表的节点</p><p>外部代理：一个在外部网络上帮助移动节点发送数据报的路由器</p><h3 id="三角路由"><a href="#三角路由" class="headerlink" title="三角路由"></a>三角路由</h3><p><img src="/picture/%E4%B8%89%E8%A7%92%E8%B7%AF%E7%94%B1.png"></p><h3 id="协议的细节"><a href="#协议的细节" class="headerlink" title="协议的细节"></a>协议的细节</h3><p>移动路由有三种能力：发现，注册，隧道技术</p><h4 id="1-发现"><a href="#1-发现" class="headerlink" title="1.发现"></a>1.发现</h4><p>移动（外部）代理：周期性发送带有移动代理广告扩展的ICMP路由广告来表明它的存在</p><p>移动节点：可以向代理请求广告或者简单地等待下一个广告</p><h4 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h4><p>移动节点：需要来自外部代理的转交地址。请求它的归属代理来转发数据包到外部代理。</p><p>四步：</p><ol><li>移动节点发送<code>registration request</code>给外部代理</li><li>外部代理转发这个请求给归属代理</li><li>归属代理发送<code>registration reply</code>给外部代理</li><li>外部代理转发这个<code>reply</code>给移动节点</li></ol><p><img src="/picture/registration.png"></p><p>下面是一个注册的例子</p><p><img src="/picture/%E4%BE%8B%E5%AD%90.png"></p><h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h4><p>在注册之后，一个IP隧道建立起来了，在归属代理和移动节点的COA之间建立。归属节点广播把移动节点IP地址绑定到归属代理MAC地址的ARP请求。因此，归属代理收到了发送给移动节点的包，会通过IP隧道转发给外部代理</p><p><img src="/picture/111.png"></p><h2 id="九-路由算法"><a href="#九-路由算法" class="headerlink" title="九.路由算法"></a>九.路由算法</h2><p>路由分为中心化的路由和分布式路由</p><p>中心化：固定的并且需要配置</p><p>分布式：通过洪泛，随机的，自适应的</p><p><img src="/picture/cvd.png"></p><h3 id="插播：洪泛（分布式）"><a href="#插播：洪泛（分布式）" class="headerlink" title="插播：洪泛（分布式）"></a>插播：洪泛（分布式）</h3><p>洪泛不需要全局网络信息，分组被交换机发送给所有邻居，分组在除了入链路的每个链路都会转发，最后很多拷贝会到达目的。</p><p>洪泛的性质：所有可能的路由都会被尝试，至少一个包会通过最小cost路由，所有的交换机都被访问过（分布式，可能用于路由）</p><h3 id="随机路由（分布式）"><a href="#随机路由（分布式）" class="headerlink" title="随机路由（分布式）"></a>随机路由（分布式）</h3><p>节点选择一个出链路来转发到来的包，选择是随机或者轮流的，基于概率。不需要什么网络信息，适合强连通网络，路由不是最佳的。</p><p>以下说明如何分配概率：</p><p><img src="/picture/p.png"></p><h3 id="自适应路由"><a href="#自适应路由" class="headerlink" title="自适应路由"></a>自适应路由</h3><p>被用作几乎所有分组交换网络，当网络状况改变时候路由决策也会改变。需要网络的信息，需要在网络质量和开销之间权衡。有助于拥塞控制</p><h3 id="两种最小花费算法"><a href="#两种最小花费算法" class="headerlink" title="两种最小花费算法"></a>两种最小花费算法</h3><p><code>Dijkstra</code>算法和<code>Bellman-Ford</code>算法</p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>找到从给定源到其他所有节点的最短路径</p><ul><li>N是网络中的节点集合</li><li>s是源节点</li><li>T是到目前为止已经被算法合并的节点</li><li><code>w(i,j)</code>是从i到j的链路消耗<ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li></ul><h5 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h5><p><code>L(n)</code>是从源s到当前已知的节点n的最小路径花费</p><ol><li>初始化<ul><li><code>T={s}</code>是只包含源点s被合并其中的节点的集合</li><li><code>L(n)=w(s,n) for n≠s</code></li><li>初始化到邻居节点的路径花费</li></ul></li><li>得到下一个节点<ul><li>找到不在T中的到源点s的最短路径的x，<code>min L(x)</code></li><li>把x合并在T中</li></ul></li><li>更新路径<ul><li><code>L(n)=min{L(n),L(x)+w(x,n)} for all n∉T</code></li><li>如果后者更小的话，那么从s到n的路径就变成了从s到x再从x到n的路径</li></ul></li></ol><p>算法在所有节点被添加到T中时结束</p><p>步骤2和3的一次迭代会添加一个新节点到T中</p><p><img src="/picture/dijkstra.png"></p><p>但是可能会出现震荡，解决办法就是非同步运行路由算法，链路代价更新随机化（让每台路由器发送链路通告的时间随机化）</p><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>找到一条从给定节点包含最多一条链路的最短路径，</p><p>找到一条从给定节点包含最多两条链路的最多路径（基于前面的步骤）</p><p>找到一条…不断进行迭代</p><ul><li><p>s是源点</p></li><li><p><code>w(i,j)</code>是从i到j的链路消耗</p><ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li><li><p>h是在当前阶段路径上链路的最大数量</p></li><li><p><code>L_h(n)</code>是在当前不超过h条链路的限制下从s到n的最短链路消耗</p></li></ul><h5 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>初始化<ul><li><code>L_0(n) = ∞, for all n ≠ s</code> </li><li><code>L_1(n) = w(s, n) </code></li><li><code>L_h(s) = 0, for all h</code></li></ul></li><li>更新<ul><li>对于每个连续的<code>h&gt;0</code></li><li>对于每个<code>n≠s</code>，计算<code>L_(h+1)(n) = min_j [Lh(j)+w(j,n)]</code></li><li>用已经找到最小的预处理节点j连接n</li><li>消除在早期迭代过程中形成的n的任何连接</li></ul></li><li>重复一直到没有改变</li></ol><p><img src="/picture/Bellman.png"></p><h5 id="链路花费改变"><a href="#链路花费改变" class="headerlink" title="链路花费改变"></a>链路花费改变</h5><p>当链路代价改变时候：</p><ul><li>节点检测到本地链路代价改变了</li><li>更新路由信息，重新计算距离向量</li><li>如果<code>DV</code>，改变了，就通知周围邻居<ul><li><img src="/picture/dv.png"></li><li>t0:y检测到链路代价改变，更新dv，通知邻居</li><li>t1:z收到来自y的更新，更新自己的表，计算到x的最小距离，发送给邻居</li><li>t2:y收到z的更新，更新自己的表，没有改变，所以不用给z发送消息</li></ul></li></ul><p>这样会出现无穷计数问题，当链路代价改变时候需要非常多次迭代才可以稳定下来！！！所以我们需要一种机制，叫做<strong>毒性逆转</strong></p><p>毒性逆转：当一个节点a通过b到达c，那么我向b声称我到c的距离是无穷！！！</p><h4 id="Dijkstra-VS-Bellman-Ford"><a href="#Dijkstra-VS-Bellman-Ford" class="headerlink" title="Dijkstra VS Bellman-Ford"></a>Dijkstra VS Bellman-Ford</h4><p>基于DIjkstra路由：</p><ul><li><strong>链路状态</strong>洪泛到其他所有节点</li><li>每个节点将会有一个完整的拓扑，并且建立他自己的路由表</li><li>不能处理负权值</li></ul><p>基于Bellman-Ford路由：</p><ul><li>每个节点维护一个到其他已知节点的<strong>距离向量</strong></li><li>距离向量要发送给直接邻居来更新路径和cost</li><li>路由表是分布式的</li></ul><h5 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h5><p>DK：n个节点，e个链路，有O(ne)个消息</p><p>BF：取决于收敛时间</p><h5 id="收敛时间："><a href="#收敛时间：" class="headerlink" title="收敛时间："></a>收敛时间：</h5><p>DK：O(n^2)并且很快，或许会有震动</p><p>BF：很慢并且取决于链路代价改变，或许包含路由环</p><h5 id="鲁棒性："><a href="#鲁棒性：" class="headerlink" title="鲁棒性："></a>鲁棒性：</h5><p>DK：可能广播不正确的链路代价，但是错误的范围被限制</p><p>BF：错误节点可能交换不正确的路径代价，错误可能会传播到网络中</p><h3 id="路由算法分类："><a href="#路由算法分类：" class="headerlink" title="路由算法分类："></a>路由算法分类：</h3><h4 id="中心化算法和去中心化（分布式）算法"><a href="#中心化算法和去中心化（分布式）算法" class="headerlink" title="中心化算法和去中心化（分布式）算法"></a>中心化算法和去中心化（分布式）算法</h4><p>中心化：所有节点都要有完整的拓扑，链路代价信息，比如<strong>链路状态算法</strong></p><p>分布式：路由器知道物理上直接连接的邻居，还有到邻居的代价，通过迭代的计算过程和邻居交换信息，比如<strong>距离向量算法</strong></p><h4 id="静态或动态"><a href="#静态或动态" class="headerlink" title="静态或动态"></a>静态或动态</h4><p>静态：经过时间，路由很慢的改变</p><p>动态：路由很快进行改变，为了回应链路代价的改变，周期化进行更新</p><h3 id="如何判断链路代价？"><a href="#如何判断链路代价？" class="headerlink" title="如何判断链路代价？"></a>如何判断链路代价？</h3><p>在ARPANET中有3个阶段：</p><h4 id="1969年第一个阶段"><a href="#1969年第一个阶段" class="headerlink" title="1969年第一个阶段"></a>1969年第一个阶段</h4><p>输出队列的长度作为链路代价</p><p>Bell-Ford被用于路由</p><h4 id="1979年第二个阶段"><a href="#1979年第二个阶段" class="headerlink" title="1979年第二个阶段"></a>1979年第二个阶段</h4><p>测量出来的延时作为链路代价，其中混合了排队时延，传输时延，传播时延。Dijkstra算法用于路由</p><h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>为了处理Dijkstra的震荡问题，让一些连接保持在加载的链路上来平衡流量。把链路利用率来表示链路状态，用之前的值和新的利用率结合起来更新。也有的用跳归一化指标来计算链路代价。</p><p>链路利用率：</p><ul><li>p=2（Ts-T）/(Ts-2T)</li><li>T是当前测量的时延</li><li>Ts是分组的长度除以传输速率（传输时延）</li></ul><p>更新利用率</p><ul><li><code>Un=αp+(1-α)Un-1</code></li><li>Un是第n次的链路利用率</li><li>α是常数，现在设置为0.5</li></ul><h2 id="十-因特网路由"><a href="#十-因特网路由" class="headerlink" title="十.因特网路由"></a>十.因特网路由</h2><p>层级化路由：把路由器整合到一个个域里面，叫自治系统（autonomous system，AS）。同一个AS里面的运行同样的路由协议（AS内部路由协议）；不同AS可以运行不同的AS内部路由协议。网关路由器负责目的地址在AS外部的路由，跟外面的路由器一起运行AS间路由协议，和内部路由器运行AS内部路由协议。</p><h3 id="自治系统（Autonomous-Systems，AS）"><a href="#自治系统（Autonomous-Systems，AS）" class="headerlink" title="自治系统（Autonomous  Systems，AS）"></a>自治系统（Autonomous  Systems，AS）</h3><p>它是被单个ISP或者更大组织掌管的路由器和网络的集合。一个被分配独一无二的AS号（ASN）的网络，使用普通的路由协议。</p><p>IGP是Interior Gateway Protocol，用于AS内路由。EGP是Exterior Gateway Protocol，用于AS间路由</p><h4 id="IGP"><a href="#IGP" class="headerlink" title="IGP"></a>IGP</h4><ul><li>RIP: Routing Information Protocol, use distance  vector</li><li>OSPF: Open Shortest Path First, use link state</li><li>IGRP: Interior Gateway Routing Protocol (Cisco proprietary)</li></ul><h4 id="EGP"><a href="#EGP" class="headerlink" title="EGP"></a>EGP</h4><ul><li>BGP: Border Gateway Protoco</li></ul><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>每个节点和邻居节点交换信息。节点维护自己到邻居链路代价，下一跳到目的的距离向量。DV根据跟邻居交换信息来更新路由表</p><h3 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h3><p>要把消息告知拓扑中的所有其他路由器（不只是邻居）</p><p>每一个路由器都可以构建出整个拓扑，可以计算出到达每个目的网络的最短路径。路由器实际上使用<code>Dijkstra</code>算法</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>使用距离向量算法。距离靠多少跳来度量，距离向量每三十秒跟邻居交换一次。如果180秒没收到信息，说明邻居没了。用UDP包。</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先，利用链路状态路由算法。每十秒更新一次，直接用IP承载，不用UDP。</p><p>网络，主机和BGP路由器都是目的，每个路由器计算它到其他目的最短路径的SPF tree</p><p><img src="/picture/SPF.png"></p><h4 id="OSPF高级的功能"><a href="#OSPF高级的功能" class="headerlink" title="OSPF高级的功能"></a>OSPF高级的功能</h4><ul><li>安全性：所有的OSPF消息需要认证来组织恶意入侵</li><li>可以允许多个相同路径</li><li>对于每个链路，对于不同TOS有多种不同代价度量方式</li><li>综合单播和多播支持</li><li>在更大的域里面用层级OSPF</li></ul><h4 id="层级式OSPF"><a href="#层级式OSPF" class="headerlink" title="层级式OSPF"></a>层级式OSPF</h4><p>为了提升可扩充性，AS或许被划分为不同区域</p><ul><li>区域被32位Aera ID认定</li><li>区域里的路由器只知道区域内部的拓扑</li><li>限制链路状态信息洪泛到其他区域</li><li>区域边界路由器从其他区域总结信息</li></ul><p>每个区域必须连接到骨干区域(0.0.0.0)</p><ul><li>在区域间的分布式路由信息</li></ul><p>好处：划分区域的好处是将洪泛交换链路状态信息的范围局限于每一个区域 而不是整个的自治系统。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其 他区域的网络拓扑的情况。主干区域用于连通其他下层区域</p><p><img src="/picture/OSPFarea.png"></p><h4 id="RIP-vs-OSPF"><a href="#RIP-vs-OSPF" class="headerlink" title="RIP vs OSPF"></a>RIP vs OSPF</h4><p>RIP</p><ul><li>配置简单，适用于小型网络（小于15跳）</li><li>可分布式实现</li><li>收敛速度较慢</li><li>网络是一个平面，不适用于大规模网络</li></ul><p>OSPF</p><ul><li>收敛速度快，无跳数限制</li><li>支持不同服务类型选路</li><li>支持身份认证</li><li>支持层次式网络，适用于大规模复杂网络</li><li>集中式算法</li><li>每个节点需要维护全局拓扑</li><li>配置复杂</li></ul><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><h4 id="由于跨AS业务关系形成的拓扑和策略"><a href="#由于跨AS业务关系形成的拓扑和策略" class="headerlink" title="由于跨AS业务关系形成的拓扑和策略"></a>由于跨AS业务关系形成的拓扑和策略</h4><p>AS间的三种基本关系</p><ul><li>A是B的客户</li><li>A是B的供应商</li><li>A是B的伙伴</li></ul><p>客户给供应商交钱。伙伴之间不需要交钱，大概网络程度类似</p><p><img src="/picture/AS%E4%B8%9A%E5%8A%A1%E5%85%B3%E7%B3%BB.png"></p><p>为什么要伙伴关系</p><p><img src="/picture/peer.png"></p><p>AS为他们的客户提供传输服务，但是不提供它的peers之间的传输服务</p><p><img src="/picture/allow.png"></p><p>总结来说，AS拓扑反映了AS之间的业务关系，AS之间的业务关系反映了什么样的路由选择是可接受的</p><h4 id="基本想法"><a href="#基本想法" class="headerlink" title="基本想法"></a>基本想法</h4><p><img src="/picture/basic.png"></p><p>BGP是被DV算法所启发</p><p>每个目的地址进行通知，没有全局共享拓扑信息，在路径上进行迭代和分布式收敛。不过有四种关键的不同之处</p><h4 id="和BGP的不同之处"><a href="#和BGP的不同之处" class="headerlink" title="和BGP的不同之处"></a>和BGP的不同之处</h4><h5 id="1-不选择最短路径"><a href="#1-不选择最短路径" class="headerlink" title="1.不选择最短路径"></a>1.不选择最短路径</h5><p>BGP基于策略选择最好的路由，而不是最短的距离（比如最小的花费），如下图可能A可能选择ABC而不是AC</p><p><img src="/picture/abc.png"></p><h5 id="2-路径向量路由"><a href="#2-路径向量路由" class="headerlink" title="2.路径向量路由"></a>2.路径向量路由</h5><p>主要思想：message要记录整个路径</p><ul><li>DV：发送到目的的距离度量</li><li>BGP：发送到目的的整个路径</li></ul><p>好处：避免循环（遇到路径上有我自己的直接丢弃）；灵活并且有表现力</p><h5 id="3-选择性的路由通告"><a href="#3-选择性的路由通告" class="headerlink" title="3.选择性的路由通告"></a>3.选择性的路由通告</h5><p>出于策略上的原因，AS可以选择不发布到目的地的路由。因此，即使物理上相连，也不一定可达</p><h5 id="4-BGP或许会合并路由"><a href="#4-BGP或许会合并路由" class="headerlink" title="4.BGP或许会合并路由"></a>4.BGP或许会合并路由</h5><p>为了稳定性，BGP或许会把不同前缀地址的路由进行合并</p><h4 id="BGP的细节"><a href="#BGP的细节" class="headerlink" title="BGP的细节"></a>BGP的细节</h4><p>谁来运行BGP呢？自治系统中的边界路由器</p><p><img src="/picture/border.png"></p><p>Speak BGP意味着什么？</p><ul><li>实现BGP协议标准</li><li>说明要和其他BGP speaker交换什么消息</li><li>如何处理这些消息</li></ul><p>边界路由器之间使用eBGP会话，边界路由器和同一个AS内的其他路由器使用iBGP会话</p><p>eBGP：在不同AS的边界路由器之间的BGP会话</p><p>IBGP：在边界路由器和同一个AS下的其他路由器之间的BGP会话</p><p>IGP：内部网关协议提供内部可达性，比如OSPF，RIP</p><h5 id="BGP里面的基础消息"><a href="#BGP里面的基础消息" class="headerlink" title="BGP里面的基础消息"></a>BGP里面的基础消息</h5><h6 id="open"><a href="#open" class="headerlink" title="open"></a>open</h6><p>建立BGP会话（利用TCP）</p><h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><p>报道不寻常的情况</p><h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><p>通知新邻居路由器</p><p>通知不活跃的老邻居路由器</p><h6 id="保持开放"><a href="#保持开放" class="headerlink" title="保持开放"></a>保持开放</h6><p>告诉邻居连接依然保持</p><h5 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h5><p>格式<code>&lt;IP prefix : route attributes&gt;</code>（<code>attributes</code>描述了路由的性质）</p><p>两种更新</p><p>通告：有新的路由或者已存在路由发生改变</p><p>撤回：移除不再存在的路由</p><h5 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h5><p>路由用属性来描述，一些属性是本地的（在AS内部，不在通告中）；一些属性通过eBGP通告被传播出去</p><h6 id="ASPATH"><a href="#ASPATH" class="headerlink" title="ASPATH"></a>ASPATH</h6><p>在路由通告里面被装载，列出了经过的所有AS的向量（反向列出）</p><p><img src="/picture/AS.png"></p><h6 id="Local-Pref"><a href="#Local-Pref" class="headerlink" title="Local Pref"></a>Local Pref</h6><p>本地偏好是用来在不同AS路径中做出选择，只在iBGP消息中，值越大越偏好</p><p><img src="/picture/pref.png"></p><h6 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h6><p>当AS通过2个或多个链路互连时，使用多出口识别器;它指定前缀离宣布它的链接有多近。越低越好</p><p><img src="/picture/MED.png"></p><p>下面是BGP更新的过程</p><p><img src="/picture/BGP.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>主要用于表示路由的可达性，不一定走最短路径路由</p></li><li><p>通过携带AS路径信息，可以解决路由循环问题</p></li><li><p>使用TCP协议，端口号179，可实现协议的可靠性</p></li><li><p>BGP 协议交换路由信息的结点数量级是自治系统数的量级。</p></li><li><p>由于自治系统中 BGP Speaker（或边界路由器）的数 目是很少的，使得自治系统之间的路由选择不致过分复杂。</p></li><li><p>支持 CIDR，可以进行路由聚合。</p></li><li><p>在BGP 刚刚运行时，BGP的邻站交换整个的BGP路由表</p><p>。但以后只需要在发生变化时增量更新有变化的部分，减少开销。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DP-有向无环图的最长路径</title>
      <link href="/2021/06/07/DP-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/06/07/DP-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图中的最长路径"><a href="#有向无环图中的最长路径" class="headerlink" title="有向无环图中的最长路径"></a>有向无环图中的最长路径</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为一个数字<code>n</code>，表示总点数。之后点的标号为从<code>0</code>到<code>n-1</code>。</p><p>之后的每一行，格式为<code>3</code>个数字，以空格隔开，分别为相连的两个点的编号，它们的边的权值。</p><p>注：输入为有向图。如果出现了<code>“0 1 50”</code>表示点<code>0</code>到点<code>1</code>之间有一条边，权值为<code>50</code>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>点0到其他所有点的最长路径，以空格隔开。注：点0到其他所有点都是可达的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度要求在<strong>O(m+n)</strong></p><p>样例输入输出</p><pre><code>输入：60 1 10 3 21 2 62 4 12 5 23 4 33 1 44 5 1输出：6 12 2 13 14 </code></pre><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先，看到复杂度是线性时间复杂度，我们想到不太可能用类似<code>Dijkstra</code>，<code>Prime</code>之类的算法，大概是用一个<code>DFS</code>或者<code>BFS</code>框架来完成。</p><p>对于有向无环图，我们会敏锐地发觉它的一些特性：从0经过某些顶点之前，路径上必然会经过另一些顶点！！！如果我们在处理顶点A之前，对它之前的所有顶点的路径进行处理的话，我们就可以依托之前的路径来对顶点A进行处理。这句话怎么听起来这么耳熟？没错，这似乎就是动态规划的具体做法！</p><p>众所周知，动态规划的思路就是<strong>利用前面已经求出的子问题来解决其他的子问题</strong>。我们通过前面经过的顶点来求后面的顶点，与这个思想相符。那么我们怎么判断谁在前谁在后呢？联系算法需要的线性复杂度，我们联想到<code>Topo</code>排序，对顶点进行拓扑序小的在前面，拓扑序大的在后面。那么基本的思路逐渐清晰了。</p><p>先利用拓扑排序对顶点进行排序，这样我在遍历某一个顶点A的时候，从0到A的路径上的所有顶点必然已经被遍历过！那么我们如何找到他前面的顶点呢？做法有两种，第一种是建立一个逆邻接表，这样就可以找到哪一个路径通向点A；第二种做法是在遍历A前面节点X的时候，直接对X的邻居进行处理，这样在遍历到A的时候，A已经被处理完了，A的任务就只变成了对A的邻居进行处理。这两种做法本质上是一样的，但是鉴于省下更多的时间和空间，我采用了第二种方法！</p><p>复杂度分析：<code>topo</code>排序是线性复杂度，后面的<code>DP</code>也是线性复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面我们就可以进行Coding了！代码如下：</p><pre class=" language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS#include<iostream>#include<vector>#include<stack>using namespace std; //邻接表节点，存储邻居节点和路径长度struct node {    int v, weight;    node(int _v, int _w) { v = _v; weight = _w; }};//邻接表，二维矩阵vector<vector<node>> table;//topo的本质是DFS，需要visit数组vector<bool> visit;//存储topo序，顶端的topo序更小stack<int> topo;//存储答案vector<int> res; void dfs(int v) {    visit[v] = true;    for (int i = 0; i < table[v].size(); i++) {        if(!visit[table[v][i].v])dfs(table[v][i].v);    }    topo.push(v);//在处理过v后面所有的节点之后，v的节点topo序要小于它后面的所有节点} int main() {    int n;    scanf("%d", &n);    //初始化         res = vector<int>(n, 0);    visit = vector<bool>(n, false);    table = vector<vector<node>>(n);    int v1, v2, w;    while (scanf("%d %d %d",&v1,&v2,&w)!=-1) {        table[v1].push_back(node(v2, w));    }     dfs(0);//topo排序     while (!topo.empty()) {        int cur = topo.top();        topo.pop();        for (int i = 0; i < table[cur].size(); i++) {//处理cur的邻居            res[table[cur][i].v] = max(res[table[cur][i].v], res[cur] + table[cur][i].weight);        }    }    for (int i = 1; i < n; i++) {        printf("%d ", res[i]);    }     return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记链路层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-直接链路"><a href="#一-直接链路" class="headerlink" title="一.直接链路"></a>一.直接链路</h2><p>主机和路由器都是节点。连接相邻结点的信道叫做链路。</p><p>链路的不同类型：</p><ul><li>有线点对点链路</li><li>有线多址链路（LANs）</li><li>无线链路（WIFI）</li></ul><h2 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二.数据链路层"></a>二.数据链路层</h2><p>二层分组（链路层分组）：帧，封装了网络层数据报</p><p>在相邻节点之间或者同一个局域网中的节点之间传送数据</p><p><img src="/picture/image-20210607210230081.png"></p><h3 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h3><p>在主机，路由器，交换机中实现。</p><p>链路层被实现在适配器中<code>"adaptor"</code>，比如网络接口卡（<code>NIC</code>）。以太网卡，802.11卡。</p><p>实现链路层和物理层，和主机的系统总线相连</p><p>硬件软件和固件的结合体</p><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p>提供了4种初级服务</p><h4 id="1-成帧"><a href="#1-成帧" class="headerlink" title="1.成帧"></a>1.成帧</h4><p>添加头尾封装上层数据报成帧</p><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>把数据报封装在帧中，添加错误检测比特，流控信息等等</p><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>寻找错误，进行流控等等。然后提取数据报交付给上层</p><h4 id="2-链路接入"><a href="#2-链路接入" class="headerlink" title="2.链路接入"></a>2.链路接入</h4><p>协调多路媒体访问，MAC地址被用在帧的头部来确定源和目的主机</p><p>全双工和半双工：接收和发送是否同时进行</p><p>有两种链路：</p><ul><li>点对点链路：专用的成对通信<ul><li>长距离光纤链路</li><li>在以太网交换机和主机之间的点对点链路</li></ul></li><li>广播链路：共享线路和媒介<ul><li>传统的以太网</li><li>802.11无线局域网</li></ul></li></ul><p><img src="/picture/image-20210607212004381.png"></p><h5 id="多路访问控制（MAC）"><a href="#多路访问控制（MAC）" class="headerlink" title="多路访问控制（MAC）"></a>多路访问控制（MAC）</h5><p>环境是一个共享的广播信道，它必须避免多个节点同时传送信息，否则碰撞导致数据错误！所以需要一个分布式的算法来决定哪一个节点可以传输数据，这样多路访问协议就诞生了。</p><p>多路访问协议是一个决定节点如何共享信道的分布式的算法，比如决定节点什么时候可以传输数据。关于信道共享的交流必须用到信道本身来交流（没有带外通道进行协作）</p><h5 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h5><p>这里有三种方式</p><h6 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h6><p>把信道分成不同的片，把这些片分配给节点，让节点单独占用</p><h6 id="轮流"><a href="#轮流" class="headerlink" title="轮流"></a>轮流</h6><p>节点轮流传送数据，但是需要发送更多数据的节点可能会等待较长时间</p><h6 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h6><p>信道不被分割，并且允许碰撞。碰撞之后要进行恢复。</p><h4 id="3-可靠交付"><a href="#3-可靠交付" class="headerlink" title="3.可靠交付"></a>3.可靠交付</h4><p>这种服务很少被用在像光纤这样的低比特错误率的链路，用在无线链路是高比特错误率。</p><p>进行流控：控制收发速率，确保发送者不会发送太快导致接收者的buffer溢出，有两种方法：</p><ul><li>停等协议</li><li>滑动窗口协议</li></ul><h5 id="3-1停等协议"><a href="#3-1停等协议" class="headerlink" title="3-1停等协议"></a>3-1停等协议</h5><h6 id="源主机传输帧，目的主机接收帧并且回复ACK"><a href="#源主机传输帧，目的主机接收帧并且回复ACK" class="headerlink" title="源主机传输帧，目的主机接收帧并且回复ACK"></a>源主机传输帧，目的主机接收帧并且回复ACK</h6><p>源主机在收到ACK之前不发送下一个包，目的主机可以通过不发送ACK来停止流</p><p>这种对于大型帧工作得很好</p><p><img src="/picture/image-20210607224657108.png"></p><h5 id="3-2滑动窗口协议"><a href="#3-2滑动窗口协议" class="headerlink" title="3-2滑动窗口协议"></a>3-2滑动窗口协议</h5><p>允许多个帧同时传送。接收者有一个大小为WIn得buffer（窗口），发送者可以发送最多Win个没有收到ACK的帧。每一个帧都被标号，ACK包含了下一个期待的帧的编号。序号被size域的大小k限制，帧的大小以2的k次方取模。</p><p>有一个问题：如果给定WIn，那么如何设置k？Win&lt;=2^k</p><p><img src="/picture/image-20210607224627065.png"></p><p>下面的图帮助理解滑动窗口</p><p><img src="/picture/image-20210607224804564.png"></p><h6 id="3-2-1后退n帧"><a href="#3-2-1后退n帧" class="headerlink" title="3-2-1后退n帧"></a>3-2-1后退n帧</h6><p>如果出现错误就恢复NAK，错误的帧和后面的所有帧都需要重传</p><h6 id="3-2-2选择性拒绝（选择重传）"><a href="#3-2-2选择性拒绝（选择重传）" class="headerlink" title="3-2-2选择性拒绝（选择重传）"></a>3-2-2选择性拒绝（选择重传）</h6><p>只有被拒绝的错误帧需要重传，接收者需要维护一个足够大的buffer</p><h4 id="4-错误检测和纠正"><a href="#4-错误检测和纠正" class="headerlink" title="4.错误检测和纠正"></a>4.错误检测和纠正</h4><p>处理由信号衰减和噪声导致的错误。接收者检测错误的出现，让信号发送者重传或者直接丢弃帧</p><p><img src="/picture/image-20210607225210550.png"></p><p>EDC是错误检测纠正码（冗余码），D是被错误检查保护的数据（包括头）</p><p>注意错误检测不是百分百可靠！比较大的EDC能更好的检测和纠正错误</p><h5 id="4-1奇偶校验法"><a href="#4-1奇偶校验法" class="headerlink" title="4-1奇偶校验法"></a>4-1奇偶校验法</h5><p>单比特奇偶校验：只能检测一位错误</p><p><img src="/picture/image-20210607225453805.png"></p><p>二维奇偶校验：能够检测和纠正单比特错</p><p><img src="/picture/image-20210607225658684.png"></p><h5 id="4-2CRC循环冗余码"><a href="#4-2CRC循环冗余码" class="headerlink" title="4-2CRC循环冗余码"></a>4-2CRC循环冗余码</h5><p>CRC被广泛运用硬件实现。数据部分D是二进制数字，有d位。选择一个<code>r+1</code>位的模式串G（生成多项式）<br>$$<br>𝐷∗2^𝑟=𝑎∗𝐺⊕𝑅, so 𝐷∗2^𝑟⊕R=a*G<br>$$<br>发送方发送左侧的<code>𝐷∗2^𝑟⊕R</code>代表<code>&lt;D,R&gt;</code></p><p>接收方当收到<code>&lt;D,R&gt;</code>的时候，如果被G整除就没错，否则就有错</p><p>限制：只可以检测出少于r+1位的突发错误</p><p><img src="/picture/image-20210607230618063.png"></p><h2 id="三-不同类型的局域网"><a href="#三-不同类型的局域网" class="headerlink" title="三.不同类型的局域网"></a>三.不同类型的局域网</h2><p>局域网有不同的拓扑</p><p><img src="/picture/image-20210607205650526.png"></p><h3 id="1-令牌环Token-Ring"><a href="#1-令牌环Token-Ring" class="headerlink" title="1.令牌环Token Ring"></a>1.令牌环Token Ring</h3><p>令牌环是一种局域网协议（IEEE802.5）</p><p>从IBM的商业的令牌环开始发展。因为IBM，令牌环获得了广泛的接受，但是从来没有达到以太网的流行程度</p><h4 id="环的操作"><a href="#环的操作" class="headerlink" title="环的操作"></a>环的操作</h4><p>每一个转发器（repeater）通过单向的传输链路连接另外两个，转发器扮演连接点的角色。</p><p><img src="/picture/image-20210607202641735.png"></p><p>数据一个比特一个比特地从一个转发器到另一个转发器传输。</p><ul><li>转发器重新生成和重传每一个比特</li><li>转发器执行数据插入，数据接收，数据删除的功能</li></ul><p>帧再进行一个循环的传递之后被发送器移除</p><h5 id="不同的状态"><a href="#不同的状态" class="headerlink" title="不同的状态"></a>不同的状态</h5><p><img src="/picture/image-20210607203827632.png"></p><h6 id="侦听状态"><a href="#侦听状态" class="headerlink" title="侦听状态"></a>侦听状态</h6><ul><li>扫描通过的比特流的模式：<ul><li>相连的站点的地址和目的站点的地址</li><li>令牌的传输权限</li></ul></li><li>复制输入位，发送给相连的站点<ul><li>如果目的地址匹配</li><li>再传发每一个比特</li></ul></li><li>当经过的的时候修改比特<ul><li>比如，表示数据包已经被复制（ACK）</li><li>或者做一个保留</li></ul></li></ul><h6 id="传输状态"><a href="#传输状态" class="headerlink" title="传输状态"></a>传输状态</h6><ul><li>回收帧，然后传回站点（为了ACK）</li><li>缓存别人的帧等候重传</li></ul><h6 id="路过的状态"><a href="#路过的状态" class="headerlink" title="路过的状态"></a>路过的状态</h6><ul><li>什么也不做</li></ul><h4 id="802-5MAC协议"><a href="#802-5MAC协议" class="headerlink" title="802.5MAC协议"></a>802.5MAC协议</h4><p>一个小的帧（令牌）在等候的时候循环，站点等待令牌</p><p>改变令牌的一个bit让它变成SOF（Start of Frame），然后再后面添加剩下的数据帧的内容</p><p>帧进行一个环形的旅行，然后被某一个传输站点吸收。然后站台当传输结束的时候插入新令牌</p><p>轻负载的时候有点效率底下，高度负载的时候，进行轮询</p><p><img src="/picture/image-20210607204827237.png"></p><h5 id="802-5的物理层"><a href="#802-5的物理层" class="headerlink" title="802.5的物理层"></a>802.5的物理层</h5><p><img src="/picture/image-20210607205538538.png"></p><h3 id="2-以太网Ethernet"><a href="#2-以太网Ethernet" class="headerlink" title="2.以太网Ethernet"></a>2.以太网Ethernet</h3><p>以太网是一种主导有线局域网的技术，有如下的好处：</p><ul><li>NIC网卡比较便宜</li><li>首先被广泛运用于局域网技术</li><li>比令牌局域网和ATM简单廉价</li><li>速度比较不错</li></ul><h4 id="以太网的物理拓扑"><a href="#以太网的物理拓扑" class="headerlink" title="以太网的物理拓扑"></a>以太网的物理拓扑</h4><h5 id="总线：在90年代中期很流行"><a href="#总线：在90年代中期很流行" class="headerlink" title="总线：在90年代中期很流行"></a>总线：在90年代中期很流行</h5><p>所有节点在同一个碰撞域中，可以互相碰撞</p><h5 id="星型拓扑：现在比较盛行"><a href="#星型拓扑：现在比较盛行" class="headerlink" title="星型拓扑：现在比较盛行"></a>星型拓扑：现在比较盛行</h5><p>每一个节点运行一个分离的以太网协议，不会相互碰撞（一般用交换机作为星型中心）</p><p><img src="/picture/image-20210607141806849.png"></p><p>下面说说他们的比较；广播vs交换以太网</p><p>总线拓扑是一种广播技术</p><ul><li>主机之间共享信道</li><li>每个包被所有相连的主机收到</li><li>通过CSMA/CD来进行媒体访问控制</li></ul><p>现代的以太网是交换以太网</p><ul><li>链路是交换机之间或者交换机和主机之间的</li><li>不需要共享信道-&gt;不用CSMA/CD</li><li>依靠自学习和生成树算法来路由！！</li></ul><h4 id="以太网的发展演变"><a href="#以太网的发展演变" class="headerlink" title="以太网的发展演变"></a>以太网的发展演变</h4><p>几乎除了帧的格式以外的所有东西都变了</p><ul><li>从共享媒介的线缆变成专用链路！</li></ul><ul><li>速度从3Mbps变成100Gbps！</li></ul><ul><li>从电子信号变成光信号！</li></ul><p>我们从中学到什么？正确的方法（比如以太网）可以经受得住很多改变，并且在保持方法的时候要更新技术！（后向兼容）</p><h4 id="以太网：不可靠，无连接"><a href="#以太网：不可靠，无连接" class="headerlink" title="以太网：不可靠，无连接"></a>以太网：不可靠，无连接</h4><p>无连接是说在收发的NIC之间没有握手的过程</p><p>不可靠是说接收者的NIC不给发送者的NIC发送确认消息，这样只有更上层的协议有可靠传输协议（TCP）才可以让丢掉的包得到恢复，否则抛弃的包就丢了！</p><h4 id="以太网帧的格式"><a href="#以太网帧的格式" class="headerlink" title="以太网帧的格式"></a>以太网帧的格式</h4><p>前导码Preamble：有七个字节，为了时钟同步，有一个字节指出帧的开始！</p><p>MAC地址Addresses：6字节，一共48bit</p><p>类型Type：2字节，填入上层协议，比如IP</p><p>数据负载Data payload：最大1500字节，最小46字节</p><p>CRC循环冗余码：4字节，一共32bit，进行错误检测</p><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>MAC地址是一个和网络适配器有关的数值地址</p><p>有48bit的名空间，比如16进制的00-15-C5-49-04-A9</p><p>当适配器生产时候就有一个独一无二的硬编码MAC地址</p><h6 id="MAC地址的分配"><a href="#MAC地址的分配" class="headerlink" title="MAC地址的分配"></a>MAC地址的分配</h6><p>分为不同的块，在MAC地址的前3个字节，被分配给不同的厂家，下面的3个字节由厂家来分配给每一个适配器</p><h5 id="成帧Framing-frames"><a href="#成帧Framing-frames" class="headerlink" title="成帧Framing frames"></a>成帧Framing frames</h5><p>物理层把bit放入链路，但是两个联通在相同物理媒介的主机需要交换帧，这个服务由链路层提供，由网络适配器来实现！</p><p>那么有一个问题：链路层如何判断每个帧的起止位置呢？</p><ol><li><p>简单的方法：比特计数，在帧的开始填入后面所跟的数据的大小，然后接受者根据这个值来解析！有一个缺点就是，如果这个计数的数值错了，将导致后面的帧全部错误！</p></li><li><p>哨兵位：用哨兵来标记帧的起止位置，<code>01111110</code>表示开始，<code>01111111</code>表示结束。但是有一个问题，如果在数据里面有哨兵怎么办？问题的解决办法是比特填充，如果在内容里面遇到5个1就在后面插入一个0，然后接收方每遇到5个1就拿掉后面的1个0！</p><p><img src="/picture/image-20210607145115984.png"></p></li></ol><p>举个例子，如果接收者看见了5个1：后面如果是0，那么就移走它继续解析；如果后面是1的话再看下一位，下一位是0，说明是帧的开始，否则是帧的结束！</p><h4 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h4><p><img src="/picture/image-20210607145201877.png"></p><h5 id="802-3的物理层"><a href="#802-3的物理层" class="headerlink" title="802.3的物理层"></a>802.3的物理层</h5><p>有许多不同的标准：</p><ul><li><p>类似的MAC协议和帧格式</p></li><li><p>不同的速率：2Mbps，10Mbps，100Mbps，1Gbps，10Gbps</p></li><li><p>不同的物理媒介：线缆，光纤</p><p><img src="/picture/image-20210607145639218.png"></p></li></ul><h2 id="四-媒体访问控制（MAC）"><a href="#四-媒体访问控制（MAC）" class="headerlink" title="四.媒体访问控制（MAC）"></a>四.媒体访问控制（MAC）</h2><p> 多路访问链路的性质：</p><ul><li>单一的共享广播信道</li><li>两个或以上的节点同时发送数据就会相互干扰</li><li>碰撞：节点同时接收两个或者更多信号</li></ul><h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><ul><li>决定节点如何共享信道的分布式算法，比如决定节点什么时候可以传输</li><li>关于信道共享的规划需要用到信道本身</li></ul><p>一个理想的多路访问协议是下面这样，给定一个广播信道的速率<code>R bps</code>，我们想要</p><ol><li>一个节点发送时，速率可以达到R</li><li>M个节点发送时，每个节点速率可达到R/ M</li><li>纯粹的分布式（去中心化）<ol><li>不需要特殊节点来协调传输</li><li>不需要同步时钟</li></ol></li><li>尽可能简单！</li></ol><h4 id="1-信道划分"><a href="#1-信道划分" class="headerlink" title="1.信道划分"></a>1.信道划分</h4><h5 id="1-1时分多路复用time-division-multiple-access"><a href="#1-1时分多路复用time-division-multiple-access" class="headerlink" title="1-1时分多路复用time division multiple access"></a>1-1时分多路复用time division multiple access</h5><p>把时间切分成等大的时间片，分为不同的轮次。每个站点得到固定大小的时间片（slot），如果轮到某个节点的时间片了，但是节点没有发送，那么这个时间片空闲！</p><p>可以达到的目标234</p><p>例如下面：6个站点，134要发包，256空闲</p><p><img src="/picture/TDMA.png"></p><h5 id="1-2频分多路复用frequence-division-muliple-access"><a href="#1-2频分多路复用frequence-division-muliple-access" class="headerlink" title="1-2频分多路复用frequence division muliple access"></a>1-2频分多路复用frequence division muliple access</h5><p>把信道划分为不同的频段，每个站点分配固定的频段，没有用到的频段空闲！FDMA和TDMA类似</p><h5 id="1-3码分多址复用（CDMA）"><a href="#1-3码分多址复用（CDMA）" class="headerlink" title="1-3码分多址复用（CDMA）"></a>1-3码分多址复用（CDMA）</h5><p>多用于无线广播网络，例如蜂窝网，卫星等等。</p><p>所有的节点共享相同的频率，但是每个节点有自己的chipping序号来编码数据</p><p>编码求原始数据 X chipping序号；解码求原始数据和chipping序号的内积</p><p>S1(D1XS1+D2XS2+D2XS3)/(|S1|^2)</p><p>需要code是正交的，多个节点可以以最小的干扰同时传输</p><p>CDMA计算比较复杂</p><p><img src="/picture/CDMA.png"></p><h4 id="2-轮流"><a href="#2-轮流" class="headerlink" title="2.轮流"></a>2.轮流</h4><h5 id="2-1轮询Polling"><a href="#2-1轮询Polling" class="headerlink" title="2-1轮询Polling"></a>2-1轮询Polling</h5><p>主节点邀请从节点轮流传输，傻瓜式从节点设备，比如蓝牙</p><p>问题：产生轮询开销，时延，master出问题所有都出问题，不是完全的分布式</p><p><img src="/picture/%E8%BD%AE%E8%AF%A2.png"></p><h5 id="2-2令牌传递"><a href="#2-2令牌传递" class="headerlink" title="2-2令牌传递"></a>2-2令牌传递</h5><p>控制令牌按照顺序从一个节点发送到下一个节点</p><p>问题：令牌的额外开销，时延，单个节点出错导致令牌丢失</p><h4 id="3-随机访问"><a href="#3-随机访问" class="headerlink" title="3.随机访问"></a>3.随机访问</h4><p>当节点有分组要发送的时候，以全速R进行发送，节点之间没有提前协调！如果多个节点同时传输就造成<strong>碰撞</strong></p><p>随机访问MAC协议指定如何检测和避免碰撞，如何从碰撞中恢复</p><p>随机访问多路媒体访问控制协议有：</p><ul><li>ALOHA，slotted ALOHA</li><li>CSMA，CSMA/CD，CSMA/CA</li></ul><h5 id="3-1ALOHA"><a href="#3-1ALOHA" class="headerlink" title="3-1ALOHA"></a>3-1ALOHA</h5><p>Additive Link On-line HAwaii system，被夏威夷大学设计</p><p>对于发送方：</p><ol><li>如果有帧要发就发</li><li>如果得到ACK就继续，否则以概率p重传，或者以1-p的概率等待</li><li>如果重复重传还没有ACK就放弃</li></ol><p>对于接收方：</p><ol><li>检查帧是否有问题</li><li>如果帧没问题，并且地址正确就发送ACK</li></ol><p>帧有可能被噪声和碰撞毁坏，有可能是另一个站点同时在发送，帧的任何一种重叠都会造成碰撞</p><p><img src="/picture/ALOHA.png"></p><h5 id="3-2时隙ALOHA"><a href="#3-2时隙ALOHA" class="headerlink" title="3-2时隙ALOHA"></a>3-2时隙ALOHA</h5><p>所有的帧大小相同，每一个时隙等于帧的传输时间。节点是同步的，需要一个中心时钟来同步时间。从一个时隙起点开始传输。帧要么不冲突，要么就完全冲突。</p><p>具体做法：节点如果有帧要传输，要在下一个时隙开始传输，如果没有碰撞节点下一个时隙就继续传输；如果有碰撞就每个时隙以p的概率重传</p><p><img src="/picture/slotALOHA.png"></p><h5 id="3-3CSMA载波侦听多路访问"><a href="#3-3CSMA载波侦听多路访问" class="headerlink" title="3-3CSMA载波侦听多路访问"></a>3-3CSMA载波侦听多路访问</h5><p>在传输之前先侦听，如果信道空闲就发送，否则停下来等待再发送。类比到人类就是在别人讲话时候不要打断别人。但是不可以消除所有碰撞，因为有传播时延！！！</p><p><img src="/picture/csma%E7%A2%B0%E6%92%9E.png"></p><h6 id="3-3-1-非持续CSMA"><a href="#3-3-1-非持续CSMA" class="headerlink" title="3-3-1 非持续CSMA"></a>3-3-1 非持续CSMA</h6><ol><li>站点要传输的时候就监听，如果空闲就传输，否则转到2</li><li>如果繁忙，等待一个随机的时间，转到1</li></ol><p>随机时间减小了碰撞的可能性，但是信道空间会被浪费，因为在传输完当前的包之后可能会等待</p><h6 id="3-3-2-1-坚持CSMA"><a href="#3-3-2-1-坚持CSMA" class="headerlink" title="3-3-2 1-坚持CSMA"></a>3-3-2 1-坚持CSMA</h6><p>为了避免等待信道时间造成的浪费，采用1坚持</p><ol><li>站点希望传输的时候监听，如果空闲就传输，否则转到2</li><li>如果繁忙就一直监听到空闲，空闲时立刻重传</li></ol><p>这是一种比较自私的做法，如果多个站点同时监听等待，肯定会造成碰撞</p><h6 id="3-3-3-p-坚持CSMA"><a href="#3-3-3-p-坚持CSMA" class="headerlink" title="3-3-3 p-坚持CSMA"></a>3-3-3 p-坚持CSMA</h6><p>一个折中的办法是p坚持CSMA，像非持续CSMA一样尽量减少碰撞，像1持续CSMA那样尽量减少等待时间</p><ol><li>如果监听信道空闲，以概率p的概率发送，以1-p的概率延迟一个时间单元（时间单元等于传播时延的最大值）</li><li>如果信道繁忙，监听知道空闲，然后转到1</li><li>延迟了一个时间单元之后，转到1</li></ol><p>那么p的值最好取多少呢？</p><p>我们p值的目标是避免在高负载的情况下的不稳定性</p><p>如果N个站点等候发送，理论上最好的值是1/N；如果是高负载的话，p是很小的，从而站点等候时间变长，造成很长时间的延迟！</p><h6 id="3-3-4比较！"><a href="#3-3-4比较！" class="headerlink" title="3-3-4比较！"></a>3-3-4比较！</h6><p>下面是不同类型CSMA的比较</p><p><img src="/picture/dCSMA.png"></p><h5 id="3-4-CSMA-CD-collision-detection"><a href="#3-4-CSMA-CD-collision-detection" class="headerlink" title="3-4 CSMA/CD(collision detection)"></a>3-4 CSMA/CD(collision detection)</h5><p>在使用CSMA的话，碰撞在传输期间仍然会发生，所以CSMA/CD碰撞传输一旦被检测到就会中断。具体做法如下：</p><ol><li>站点在传输的时候侦听，如果空闲就传输，否则转2</li><li>如果繁忙，持续侦听直到空闲。然后立刻传输</li><li>如果检测到碰撞，发送拥塞信号然后终止传输</li><li>在拥塞之后，等待一个随机的时间然后转到1</li></ol><p>下面是碰撞的发生</p><p><img src="/picture/CSMAcd.png"></p><h6 id="帧的最小长度"><a href="#帧的最小长度" class="headerlink" title="帧的最小长度"></a>帧的最小长度</h6><p>为了能够检测出碰撞，我们需要限制最小的帧的长度，否则有可能检测不到碰撞。</p><p>如下图，我们假设信道长度是L，传播的速度是V，带宽是B，帧的大小是size，那么从一端到另一端传播时延是<code>L/V</code>，如果在主机2即将传播到4的时候（t=L/V），4发送了帧，这样从主机4发送的帧到达主机2的时间t=2L/V，这样只有当传输时间大于2L/V时才可以检测到碰撞，也就是<code>size/B&gt;2L/V</code>！</p><p><img src="/picture/%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E.png"></p><h5 id="总结-随机访问的三个重要思想"><a href="#总结-随机访问的三个重要思想" class="headerlink" title="总结.随机访问的三个重要思想"></a>总结.随机访问的三个重要思想</h5><h6 id="载波侦听"><a href="#载波侦听" class="headerlink" title="载波侦听"></a>载波侦听</h6><ul><li>在讲话之前先侦听，不要打扰其他人讲话</li><li>检测是否已经有人在说话了</li><li>等到别人说完</li></ul><h6 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h6><ul><li>有别人同时说话就停下来，但是要确保所有人都知道碰撞了（最小帧长度的限制）</li><li>了解什么时候两个节点立刻传输</li><li>通过检测数据是否混乱来检测碰撞</li></ul><h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><ul><li>不要立刻重传</li><li>等一个随机时间再重传</li></ul><p>应该等待多久时间？</p><p>IEEE802.3使用1持续的CSMA，采用二进制指数退避的方式</p><ol><li>在前十次尝试发送中，每一次随机延迟的时间加倍，比如第一次重传从1 2里面选，第二次重传从1 2 3 4里面选….</li><li>超过十次重传的话，就保持第十次的最大时间不变，从中选择一个时间重传</li><li>超过16次重传说明信道过于繁忙，就会放弃，并且报告错误！</li></ol><p>1持续的二进制指数退避算法在很大范围的负载内表现得不错：低负载的时候保证了效率，高负载的时候保证了稳定性</p><h5 id="以太网CSMA-CD算法"><a href="#以太网CSMA-CD算法" class="headerlink" title="以太网CSMA/CD算法"></a>以太网CSMA/CD算法</h5><p>下面是以太网CSMA/CD算法的描述：</p><p><img src="/picture/ethernetcsmacd.png"></p><p>流程图</p><p><img src="/picture/cdmacdliuchengtu.png"></p><h3 id="多路访问协议的性能分析"><a href="#多路访问协议的性能分析" class="headerlink" title="多路访问协议的性能分析"></a>多路访问协议的性能分析</h3><h4 id="1-没有ACK的点到点链路"><a href="#1-没有ACK的点到点链路" class="headerlink" title="1.没有ACK的点到点链路"></a>1.没有ACK的点到点链路</h4><p>不管对于大型帧还是小型帧来说，利用率等于传输时间占总时间的比值。（<strong>总时间是指这个帧发出的时间到下一个帧发出的间隔时间</strong>）</p><p>假设传输时间为1，传播时间为a，那么总时间为<br>$$<br>U=1/(1+a)<br>$$</p><h4 id="2-令牌环"><a href="#2-令牌环" class="headerlink" title="2.令牌环"></a>2.令牌环</h4><p>对于大的令牌环来说，令牌从<code>t0</code>开始传输，然后在<code>t0+1</code>时候，帧的最后一个bit发送出去并且第一个比特回来，令牌开始传送，在<code>t=t0+1+a/n</code>到达下一个站点，这个时候下一个站点开始传输。</p><p>对于小的令牌环来说，令牌从<code>t0</code>开始传输，然后在<code>t0+a</code>从站点完全释放并且第一个比特回来，这时候令牌开始传给下一个站点，在<code>t=t0+a+a/N</code>时候令牌到达下一个站点</p><p>两种情况：</p><ol><li>case1：a&lt;1（当帧比环长）<br>$$<br>U=1/(1+a/N)<br>$$</li><li>case2：a&gt;1（帧比环短）<br>$$<br>U=1/(a+a/N)<br>$$</li><li></li></ol><h4 id="3-时隙ALOHA"><a href="#3-时隙ALOHA" class="headerlink" title="3.时隙ALOHA"></a>3.时隙ALOHA</h4><p>所有的帧有相同的大小，时间被同一分割，各个节点是同步的，传输在时隙的开始部分开始，帧要么全部碰撞要么就不碰撞。</p><p>假定N个节点有帧要发送，每一个在以p的概率在时隙发送，那么一个节点成功发送的概率是<code>p * (1-p)^(N-1)</code>，那么N个节点成功的概率是<code>A = N * p * (1-p)^(N-1)</code>。</p><p>如何找到成功概率，那么就是让<code>p=1/N</code>，<code>A=(1-1/N)^(N-1)</code>（利用函数求导）</p><p>如果能够被成功利用，信道的利用率<code>Us=1/(1+2α)</code></p><p>因为A是成功的概率，所以成功传送的利用率是<code>U=UsXA=(1-1/N)^(N-1)</code>，让N等于正无穷，U约等于<code>1/e</code></p><h4 id="4-纯ALOHA"><a href="#4-纯ALOHA" class="headerlink" title="4.纯ALOHA"></a>4.纯ALOHA</h4><p>更简单但是碰撞概率更高。当我t0发送一个帧的时候，我在<code>[t0-1,t0+1]</code></p><p><code>A=N*P(一个人在时隙传输)*P(没人在t0-1~t0传输)*P(没人在t0~t0+1传输)</code><br>$$<br>U=A=N<em>p</em>(1-p)^{2N-1}<br>$$<br>当<code>p=1/2N</code>并且N趋于无穷时，<code>U=1/(2e)</code></p><h4 id="5-CSMA-CD"><a href="#5-CSMA-CD" class="headerlink" title="5.CSMA/CD"></a>5.CSMA/CD</h4><p>暂时略</p><h3 id="MAC地址和它的发现"><a href="#MAC地址和它的发现" class="headerlink" title="MAC地址和它的发现"></a>MAC地址和它的发现</h3><p><img src="/picture/123.png"></p><p>一个主机A被制造时只有他自己的mac地址，那么我要联系主机B却不知道它的MAC地址，怎么办呢？</p><h4 id="1-链路层发现协议"><a href="#1-链路层发现协议" class="headerlink" title="1.链路层发现协议"></a>1.链路层发现协议</h4><p>ARP：Address Resolution Protocols</p><p>DHCP：Dynamic Host Configuration Protocol</p><p>被限制在单一局域网里，依靠广播能力</p><p>它们有两个功能：</p><ol><li>发现局域终端设备</li><li>辅助远程主机的交流</li></ol><h4 id="2-DHCP"><a href="#2-DHCP" class="headerlink" title="2.DHCP"></a>2.DHCP</h4><p>主机用DHCP来找到它自己的IP地址，网络掩码，DNS服务器的IP地址，默认的第一跳路由器的IP地址（默认网关）</p><h5 id="DHCP的标准过程"><a href="#DHCP的标准过程" class="headerlink" title="DHCP的标准过程"></a>DHCP的标准过程</h5><p><img src="/picture/dhcp.png"></p><h6 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h6><ol><li>客户在它所在的子网广播一个DHCP-Discover消息</li><li>每一个服务器都可能用一个DHCP-Offer消息回复</li><li>客户机选择一个服务器广播一个包含服务器IP地址的DHCP-Request消息</li><li>被选择的服务器确认绑定，用一个DHCP-ACK消息回复！</li><li>客户机根据DHCP-ACK设置它的配置参数</li></ol><h6 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h6><ol><li>客户机通过发送DHCP-RELEASE消息废除绑定</li><li>如果客户机不更新之前绑定的关系，绑定会过期</li></ol><p><img src="/picture/guocheng.png"></p><h5 id="当DHCP出现问题怎么办"><a href="#当DHCP出现问题怎么办" class="headerlink" title="当DHCP出现问题怎么办"></a>当DHCP出现问题怎么办</h5><p><img src="/picture/dhcphd.png"></p><h4 id="3-ARP"><a href="#3-ARP" class="headerlink" title="3.ARP"></a>3.ARP</h4><p>用户137.196.7.23想要ping 137.196.7.88</p><ul><li>源IP：137.196.7.23</li><li>目的IP：137.196.7.88</li><li>源MAC：71-65-F7-2B-08-53</li><li>目的MAC是多少呢？？？？？？？</li></ul><p>我们需要目的主机的MAC地址才可以传输数据，在局域网中，我们用ARP来获得MAC地址，需要给定目的主机IP地址！</p><p>ARP是一种IP到MAC地址的映射，只在局域网中起作用。对比DNS服务，DNS服务是域名到IP地址的映射！</p><h5 id="ARP的运行过程"><a href="#ARP的运行过程" class="headerlink" title="ARP的运行过程"></a>ARP的运行过程</h5><p>每一个主机都维护一个ARP表（IP地址到MAC地址的映射表），其中表项在一段时间之后会过期被删除</p><h6 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h6><ol><li>先查看本地的cache（ARP表）</li><li>如果没有发现目的IP对应的MAC地址的话，就构建一个ARP请求插入&lt;发送方IP，发送方MAC，目的IP&gt;</li><li>用MAC帧进行广播</li><li>收到ARP回复，进行缓存（加上时间戳）！</li></ol><h6 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h6><ol><li>检查ARP包的目的IP</li><li>如果目的IP是我的某个接口，构建一个ARP回复，插入&lt;目的IP，目的MAC&gt;</li><li>用MAC帧发送给发送</li><li>把发送方的&lt;IP,MAC&gt;存入cache</li></ol><p>但如果目的地址很远不在局域网之内怎么办？</p><p>我们要先用ARP查找第一跳路由器的MAC地址</p><p>那么主机如何知道我和目的没有在同一个局域网里？</p><p>通过子网掩码！</p><p>那么主机咋知道第一跳路由器在哪？</p><p>通过DHCP协议！！！（默认网关）</p><p>下面是ARP的一个具体例子</p><p><img src="/picture/arpex.png"></p><h4 id="4-ARP和DHCP的关键"><a href="#4-ARP和DHCP的关键" class="headerlink" title="4.ARP和DHCP的关键"></a>4.ARP和DHCP的关键</h4><p>广播：通过广播来交流</p><p>缓存：在一定时间内记住过去的记录，存储信息来减少一定查询开销</p><p>软状态：记录最终会被删除</p><table><thead><tr><th>层</th><th>例子</th><th>结构</th><th>配置</th><th>解决服务</th></tr></thead><tbody><tr><td>应用层</td><td>p.nju.edu.cn</td><td>组织层级</td><td>根据手册</td><td>DNS（应用层-网络层）</td></tr><tr><td>网络层</td><td>123.23.88.66</td><td>拓扑层级</td><td>DHCP</td><td></td></tr><tr><td>链路层</td><td>45-CD-AC-38</td><td>供应商</td><td>硬编码</td><td>ARP（网络层-链路层）</td></tr></tbody></table><h4 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h4><h5 id="发现机制"><a href="#发现机制" class="headerlink" title="发现机制"></a>发现机制</h5><p>广播（ARP，DHCP）</p><p>洪泛，没有非常关键的中心化节点，不需要手动配置</p><p>目录服务（DNS）</p><p>不洪泛，可扩充，根目录是容易受到攻击的，需要辅助程序配置</p><h2 id="五-桥和二层交换机"><a href="#五-桥和二层交换机" class="headerlink" title="五.桥和二层交换机"></a>五.桥和二层交换机</h2><h3 id="局域网的互联"><a href="#局域网的互联" class="headerlink" title="局域网的互联"></a>局域网的互联</h3><p>要具备拓展到单一局域网之外的能力，提供到其他局域网或者广域网的互联服务，所以用到了桥</p><p>桥<code>bridge</code>的作用：</p><ul><li>连接不同的局域网，通常超过两个</li><li>同样使用链路层和物理层协议</li><li>存储转发局域网的帧</li><li>精准的位复制帧</li><li>需要交换路由的功能</li></ul><p><img src="/picture/bridge.png"></p><p>桥需要的特性：</p><ul><li>存储和转发<ul><li>读取在局域网中传播的帧，检查帧的MAC地址，选择性地存储这些地址</li><li>利用第二局域网的MAC协议，重传每一个帧</li></ul></li><li>透明度<ul><li>站点不应该感受到桥的存在</li></ul></li><li>即插即用，自学习<ul><li>桥不需要配置</li></ul></li></ul><h3 id="桥协议体系架构"><a href="#桥协议体系架构" class="headerlink" title="桥协议体系架构"></a>桥协议体系架构</h3><p>IEEE802.1D</p><p><img src="/picture/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png"></p><p>桥的机制：帧广播，环的破除，地址学习</p><h3 id="广播以太网"><a href="#广播以太网" class="headerlink" title="广播以太网"></a>广播以太网</h3><p>发送方通过一个广播链路来广播帧。如果目的MAC地址和接受者的MAC地址匹配或者是广播MAC地址<code>FF:FF:FF:FF:FF:FF</code>的话，每一个接受者的链路层把帧递交给网络层</p><p>广播以太网即插即用，不需要人工配置，广播作为一种辅助交流的方式</p><h4 id="广播风暴问题"><a href="#广播风暴问题" class="headerlink" title="广播风暴问题"></a>广播风暴问题</h4><p>在有环的扩充局域网里面广播会造成不断广播，造成帧不断重复并且永生，那么究竟是什么造成这个问题呢？答案是：环</p><p><img src="/picture/huan.png"></p><p>Perlman提出了她的解决办法：在拓扑中破除环，最简单的方法就是构建一个最小生成树！</p><h4 id="生成树协议（Perlman’85）"><a href="#生成树协议（Perlman’85）" class="headerlink" title="生成树协议（Perlman’85）"></a>生成树协议（Perlman’85）</h4><p>这个协议判断这个扩充局域网里面如何构建一个生成树。它有很好的性质：不需要人工配置，一旦出现错误会自恢复。因为它很方便好用，至今仍被使用！</p><h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><p>以任意的网络拓扑作为输入，找到一个形成生成树的链路的子集</p><p>它有两个方面：</p><ul><li>先找到一个根，其他节点都到根有一个最短路径，找到一个id最小的节点作为根</li><li>计算到根的最短路径。最短路径不可能有环，节点之间只要保持到最短路径的链路即可。如果有多个最短路径我们就选择相邻接点ID最小的那一条路径</li></ul><p>那么具体如何构建一个生成树呢？</p><p>我们需要一个特殊的消息来辅助，这个消息包含一个三元组（Y,d,X），表明包是来自X，以Y为根，和Y的距离为d。</p><p>当收到包的时候，交换机选择最小ID的节点作为root</p><p>每一个节点决定它的链路是否在到根的最短路径上，如果不是就排除它</p><h5 id="具体算法执行过程"><a href="#具体算法执行过程" class="headerlink" title="具体算法执行过程"></a>具体算法执行过程</h5><ol><li><p>最开始，每一个节点声称它自己是节点</p><p>交换机X把（X,0,X）发送给邻居</p></li><li><p>节点更新他们的信息：根是谁，举例根多远</p><p>当收到（Y，d，Z）的时候，检查Y的id是否小于当前root的id，如果是的话就让root=Y</p></li><li><p>节点计算他们的到根的距离</p><p>一般来说+1</p></li><li><p>如果根或者根到节点的最短路径改变了，就把新的三元组消息发送给邻居</p></li></ol><p><img src="/picture/%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95.png"></p><h5 id="鲁棒的生成树算法"><a href="#鲁棒的生成树算法" class="headerlink" title="鲁棒的生成树算法"></a>鲁棒的生成树算法</h5><p>算法必须对于错误作出应对：根节点错误，桥和链路错误</p><p>根节点需要周期性地发送root announcement消息，其他的桥继续转发消息</p><p>这样我们就可以通过超时来检测错误！如果没有定期收到来自跟的消息，那么就超市，所以我就声称自己是根然后进行更新生成树！</p><h4 id="在生成树里面洪泛"><a href="#在生成树里面洪泛" class="headerlink" title="在生成树里面洪泛"></a>在生成树里面洪泛</h4><p>洪泛需要使用下面的规则：</p><ol><li>忽略所有不在生成树里面的接口</li><li>起源的桥发包给所有可以的端口</li><li>当数据包到达一个接收端口时，将它发送到除接收端口以外的所有端口</li></ol><p>洪泛是不是一种对资源的浪费呢？</p><p>是这样的，但我们可以让它辅助很多有效的转发！</p><p>我们收到“没有用“的包的时候，它不一定没有用，因为我们可以从它里面”学习“到一些东西。如果节点A看见了B的分组从某个端口进来了，A就知道可以通过这个端口到达B！！！因为在生成树中只有一条到达B的路径，所以这个很有效</p><h5 id="节点可以学习路由"><a href="#节点可以学习路由" class="headerlink" title="节点可以学习路由"></a>节点可以学习路由</h5><p>每一个桥维护了一个转发表数据库。转发表是可以不断更新的：当一个帧到达端口X，它一定来自和X端口相连的局域网。我们使用源地址来更新转发表，因为端口X所能到达的区域包含这个地址！！！</p><p>转发表的每个表项都有一个定时器，到时之后会自动删除对应表项！</p><p>每次当帧到达的时候，源地址都会在数据库里面检查一下是否有更新</p><h3 id="桥的转发功能总结"><a href="#桥的转发功能总结" class="headerlink" title="桥的转发功能总结"></a>桥的转发功能总结</h3><p>桥维护一个转发表，表项是一个三元组&lt;MAC地址，端口，时间戳&gt;</p><p>对于到达端口X的每一个帧，首先查找转发表，看看是否有目的MAC地址在转发表里的：</p><ul><li>如果没有，转发到除了X的所有端口</li><li>如果目的MAC地址对应端口就是X，就丢弃</li><li>如果目的MAC对应的端口是Y，检查Y是在阻塞态还是转发态，如果是转发态就转发到Y（不在生成树里的就是阻塞态）</li></ul><h3 id="互联不同局域网的设备类型"><a href="#互联不同局域网的设备类型" class="headerlink" title="互联不同局域网的设备类型"></a>互联不同局域网的设备类型</h3><ol><li>集线器（Hubs）：物理层的转发器</li><li>桥：连接局域网（转发和自学习）</li><li>二层交换机：连接主机和局域网（桥的功能加上无碰撞）</li><li>三层交换机（路由器）：还包含了路由功能</li></ol><h4 id="1-集线器"><a href="#1-集线器" class="headerlink" title="1.集线器"></a>1.集线器</h4><p>星型布局活跃的中心元素。</p><p>每一个站点通过两根线连接集线器，用来发送和接收</p><p>集线器是一种转发器，当站点传输的时候，集线器在输出的线路上面单纯重复转发给其它站点</p><p>物理拓扑是星型，但在逻辑上相当于总线。从一个站点接收的包会被其他所有站点接收，如果两个站点同时传输就会导致碰撞！</p><h5 id="共享媒体总线和集线器的区别"><a href="#共享媒体总线和集线器的区别" class="headerlink" title="共享媒体总线和集线器的区别"></a>共享媒体总线和集线器的区别</h5><p><img src="/picture/busvshub.png"></p><h4 id="2-二层交换机"><a href="#2-二层交换机" class="headerlink" title="2.二层交换机"></a>2.二层交换机</h4><p>需要什么样的性质？</p><ul><li>链路层设备：<ul><li>存储转发以太网帧</li><li>检查收到的帧的MAC地址，有选择性的转发到一个或者多个出链路，用CSMA/CD</li></ul></li><li>透明性，主机不知道交换机的存在</li><li>即插即用，自学习</li></ul><p>交换机vs桥</p><ul><li>桥连接不同局域网，有2-4个端口</li><li>交换机连接各种不同的主机和局域网，有很多端口，可以实现无碰撞传输</li></ul><p>为什么要用交换以太网呢？</p><p>站点是专用直接地连到交换机上</p><p>交换机缓存和转发帧</p><p>以太网协议在每个入链路上被使用，但没有碰撞，全双工</p><p>A-A’和B-B‘可以同时发送，但是没有碰撞！</p><p><img src="/picture/switch.png"></p><p>局域网容量加倍：每一个端口/链路形成一个局域网段（无碰撞），有多个站点同时传输</p><h5 id="集线器和二层交换机的区别"><a href="#集线器和二层交换机的区别" class="headerlink" title="集线器和二层交换机的区别"></a>集线器和二层交换机的区别</h5><p><img src="/picture/difhs.png"></p><p>二层交换机的好处：</p><ul><li>从总线或集线器局域网转变成交换机局域网很方便</li><li>站点相对于原始的局域网有相同的能力（假定交换机有足够的能力来跟得上所有站点）</li><li>二层交换机扩充规模很容易</li></ul><h4 id="3-三层交换机"><a href="#3-三层交换机" class="headerlink" title="3.三层交换机"></a>3.三层交换机</h4><p>当站点数目变多的时候，二层交换机显示出了缺点：</p><ul><li>广播有额外开销，比如要往100万个节点的局域网里广播就很麻烦</li><li>缺乏多条路径选择，因为生成树只有唯一路径，如果一条路断了可能影响很多节点</li></ul><p>三层交换机在硬件实现了路由器IP转发的逻辑，互联类似的局域网，就像二层交换机一样</p><h2 id="六-无线网络和移动网络"><a href="#六-无线网络和移动网络" class="headerlink" title="六.无线网络和移动网络"></a>六.无线网络和移动网络</h2><p>无线网络和移动网络在当今非常盛行，用户数量大大超过有线网络！但是面临着两种挑战：</p><ul><li>无线：在无线链路上面交流</li><li>移动：移动用户可能在不同的网络接入点接入，非无线网络也可能要处理移动的问题。基站也要提供接入有线网络的连接</li></ul><p><img src="/picture/wireless.png" alt="无线网络的基础设施"></p><ul><li>基站：用来接入有线网络；用来中继，负责在优先网络和无线主机中传包，例如蜂窝塔，802.11接入点</li><li>无线链路：用来讲移动设备连接到基站，也被用作主干链路，多路访问协议来协调链路访问，不同链路有不同的传播速率和传输距离</li></ul><p><img src="/picture/%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF.png" alt="各种无线链路标准"></p><h3 id="两种操作模式"><a href="#两种操作模式" class="headerlink" title="两种操作模式"></a>两种操作模式</h3><ul><li>基础设施模式：依靠基站把无线网络接入有线网络</li><li>自组织模式（Ad-hoc mode）：无线主机们自动组织成网络</li></ul><h4 id="基础设施模式"><a href="#基础设施模式" class="headerlink" title="基础设施模式"></a>基础设施模式</h4><p>基站把移动设备连接到有线网络，移动设备在不同的区域可能会改变基站</p><h4 id="自组织模式"><a href="#自组织模式" class="headerlink" title="自组织模式"></a>自组织模式</h4><p>不需要基站，节点只可以和链路范围覆盖的其他节点进行传输，节点把它们自己组织成网络</p><h3 id="无线网络分类"><a href="#无线网络分类" class="headerlink" title="无线网络分类"></a>无线网络分类</h3><p><img src="/picture/taxonomy.png" alt="无线网络分类"></p><h3 id="无线链路的特点"><a href="#无线链路的特点" class="headerlink" title="无线链路的特点"></a>无线链路的特点</h3><h4 id="1-信号强度衰减"><a href="#1-信号强度衰减" class="headerlink" title="1.信号强度衰减"></a>1.信号强度衰减</h4><p>由于反射，衍射，吸收地形，湿度等原因，路径上会有信号衰减</p><p><code>Free Space Path Loss叫FSPL</code><br>$$<br>FSPL=(4Πdf/c)^2<br>$$<br><code>d</code>是距离，<code>λ=c/f</code>是波长，<code>f</code>是频率，<code>c</code>是光速</p><h5 id="1-1-SNR和BER"><a href="#1-1-SNR和BER" class="headerlink" title="1-1 SNR和BER"></a>1-1 SNR和BER</h5><p>SNR是信噪比（signal-to-noise ratio），信噪比越大从中提出正确的信号越容易！</p><p>BER是误码率</p><p>给定一个物理链路，我们要提升链路的能力就要提升信噪比，减小误码率</p><p>在不同链路会有不同的信噪比和误码率，根据链路动态调整</p><p><img src="/picture/SNRBER.png"></p><h4 id="2-多路传播"><a href="#2-多路传播" class="headerlink" title="2.多路传播"></a>2.多路传播</h4><p>广播信号由于反射之类的干扰，在不同时间到达终点，导致主机无法判断是否是一个新的packet</p><p>多路效应：信号从一些表面进行反弹，干扰其他信号（自干扰）</p><h4 id="3-相互干扰"><a href="#3-相互干扰" class="headerlink" title="3.相互干扰"></a>3.相互干扰</h4><p>不同的设备共享频率，相互干扰</p><h3 id="IEEE-802-11无线局域网（WIFI）"><a href="#IEEE-802-11无线局域网（WIFI）" class="headerlink" title="IEEE 802.11无线局域网（WIFI）"></a>IEEE 802.11无线局域网（WIFI）</h3><p>single-cell配置和multi-cell配置</p><p><img src="/picture/single.png"></p><p><img src="/picture/multi.png"></p><h4 id="1-802-11架构"><a href="#1-802-11架构" class="headerlink" title="1.802.11架构"></a>1.802.11架构</h4><p>基站：符合MAC和物理层的设备</p><p>接入点（AP）：通过无线媒介提供分发式系统的接入服务</p><p>基础服务集（BSS）：被一个AP协调的cell</p><p>扩展服务集（ESS）：被分发式系统互联的多个BSS。分发式系统可能是一个交换机，一个有线网络，或者无线网络。一个ESS看起来就像一个单独的逻辑上的局域网，路由器提供到因特网的接入</p><p>分发式系统（DS）：一个被用来互联BSS集并且整合局域网以构成ESS的系统</p><p><img src="/picture/poss.png"></p><p>802.11b：2.4GHz-2.485GHz的频段被划分成不同频率的11个信道。AP的管理员选择AP的频段，但是如果邻居AP选择了和我相同的频段，我们可能出现相互干扰。</p><p>主机：必须和AP关联。扫描信道监听包含AP名字和MAC地址的信标帧，然后选择一个AP来关联或许还要身份验证（WIFI密码），连接之后通过DHCP来获得在AP子网下的IP地址</p><h5 id="1-关联的方式"><a href="#1-关联的方式" class="headerlink" title="1.关联的方式"></a>1.关联的方式</h5><p>有两种，分别是被动扫描和主动扫描</p><h6 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h6><ol><li>AP发送信标帧（Beacon frames）</li><li>主机发送关联请求帧（Associaion Request frame）给自己选择的AP</li><li>然后AP发送关联回复帧（Association Response frame）给刚才的主机</li></ol><h6 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h6><ol><li>主机广播探查请求帧（Probe Request frame）</li><li>AP收到后给予探查回复帧（Probe Response frame）</li><li>主机发送关联请求帧</li><li>AP发送关联回复帧</li></ol><p><img src="/picture/%E5%85%B3%E8%81%94.png"></p><h5 id="2-多路访问"><a href="#2-多路访问" class="headerlink" title="2.多路访问"></a>2.多路访问</h5><p>多个无线发送者和接受者可能会造成一些问题（不仅仅是多路访问控制的问题）</p><ul><li>隐藏终端问题</li></ul><p><img src="/picture/yczd.png"></p><ul><li>信号衰减问题</li></ul><p><img src="/picture/xhsj.png"></p><ul><li>暴露终端问题</li></ul><p><img src="/picture/blzd.png"></p><p>我们主要来讨论隐藏终端问题，解决方法：<strong>4帧交换</strong></p><ol><li>源（广播）发送一个发送请求帧（Request to Send,RTS）给目的</li><li>目的用CTS（Clear to Send）回复，发送给所有节点，告诉他们有人要发送帧了！</li><li>在收到CTS之后，源节点开始传送数据</li><li>目的节点用ACK回复，还是发送给所有节点，告诉他们上一个已经发送完了</li></ol><p><img src="/picture/rtscts.png"></p><h5 id="3-媒体访问控制"><a href="#3-媒体访问控制" class="headerlink" title="3.媒体访问控制"></a>3.媒体访问控制</h5><p><img src="/picture/mac.png"></p><h6 id="3种优先级"><a href="#3种优先级" class="headerlink" title="3种优先级"></a>3种优先级</h6><p>帧间距inter frame space</p><ul><li>SIFS(short inter frame space)最短帧间距</li><li>PIFS(point coordination function IFS)点协调控制</li><li>DIFS(distributed coordination function IFS)分布式协调控</li></ul><p>SIFS的使用</p><ul><li>站点在一个SIFS时间间隔后回复ACK</li><li>LLC</li><li>轮询回复</li><li>CTS</li></ul><p>PIFS和DIFS</p><p>PIFS被集中控制器使用，DIFS被使用于异步网络</p><p><img src="/picture/80211.png"></p><h6 id="PCF点协调控制"><a href="#PCF点协调控制" class="headerlink" title="PCF点协调控制"></a>PCF点协调控制</h6><p>通过中心化的轮询控制器来轮询</p><ul><li>使用分配轮询的时候用PIFS</li><li>当它发出轮询和接收响应时，它可以捕获媒介并锁定所有异步通信量</li></ul><p>无线网络由多个具有时效性的站点组成，由点协调器控制</p><ul><li>点协调器轮流轮询站点</li><li>当轮询发出时候，轮询的站点用SIFS回复轮询</li><li>如果点协调器收到回复，那么用PIFS发出另一个轮询</li><li>如果点协调器没有收到回复，它就发出另一个轮询</li><li>重复，直到当前一轮截止</li></ul><p>超级帧：一种时间间隔。在超级帧间隔的第一部分，点协调器对所有轮询站点进行轮询；在剩下的部分允许争夺异步访问。在超级帧的开头，点协调器创建一个避免争夺期，因为回复的站点发出对的帧的大小的变化来辩护这个时期持续的时间；在超级帧的后面，点协调控制器用PIFS来争夺访问，最后通过信标帧来标志下一个循环！</p><p>超级帧： 点协调器不断发布轮询，会封锁所有异步通信量。为了避免这种情况，在超帧时间的前一部分，由点协调器轮询，在超帧时间的后一部分，允许异步通 信量争用接入。</p><p><img src="/picture/%E8%B6%85%E7%BA%A7%E5%B8%A7.png"></p><h6 id="DCF分布式协调控制"><a href="#DCF分布式协调控制" class="headerlink" title="DCF分布式协调控制"></a>DCF分布式协调控制</h6><p>DCF使用CSMA/CA（拥塞避免），站点在传送前感知媒介，不会和正在传输的站点碰撞</p><p>DCF包含了时延，在传输之前等待一个帧间距</p><p><strong>为什么不需要碰撞检测？</strong></p><ol><li>当传输时候因为信号衰减很难收到别人发的信号！</li><li>传输站点不能区分噪声和弱信号！</li><li>不能感觉到所有碰撞，比如发生隐藏终端问题，信号衰减等待</li><li>ACK用起来很好！</li></ol><h6 id="802-11的MAC协议：CSMA-CA"><a href="#802-11的MAC协议：CSMA-CA" class="headerlink" title="802.11的MAC协议：CSMA/CA"></a>802.11的MAC协议：CSMA/CA</h6><p>发送方：</p><ol><li>如果感知到DIFS信道空闲就传输整个帧</li><li>如果信道繁忙，就开始随机时间回退，当信道空闲时候计时器倒计时，当时间到了就传输，如果没有ACK，就增加随机的回退间隔，重复2</li></ol><p>接收方：</p><ol><li>如果帧接收没问题，在SIFS之后返回一个ACK</li></ol><p><strong>碰撞避免</strong></p><p>允许发送方预约信道而不是信号针的随机接入，避免长数据帧的碰撞</p><p>发送方先用CSMA传送很小的RTS给基站</p><p>基站广播CTS来回应RTS</p><p>CTS被所有站点收到，发送方传输数据，其他站点推迟传输</p><p>这样就通过用一个预约分组来预约信道，完全避免了碰撞！</p><p><img src="/picture/%E9%A2%84%E7%BA%A6.png"></p><h5 id="4-802-11帧"><a href="#4-802-11帧" class="headerlink" title="4.802.11帧"></a>4.802.11帧</h5><p><img src="/picture/frame.png"></p><p>为什么要用地址3？</p><p><img src="/picture/why.png"></p><p>需要实现803.11帧到802.3帧的转换，首先传到AP之后，AP要传给路由器R1</p><h5 id="5-移动性：在同一个子网下移动"><a href="#5-移动性：在同一个子网下移动" class="headerlink" title="5.移动性：在同一个子网下移动"></a>5.移动性：在同一个子网下移动</h5><p>H1保持在同样的IP子网，IP地址可能保持不变</p><p>但如果H1从BBS1移动到BBS2的话怎么办？</p><p>依靠自学习，先看H1来自第一个端口，然后又来自第二个端口，就更新了转发表</p><h5 id="6-先进的能力"><a href="#6-先进的能力" class="headerlink" title="6.先进的能力"></a>6.先进的能力</h5><p>速率控制：基站，移动设备根据信噪比来动态调节比特率！</p><p>功率控制：节点会告诉AP，你给我下一个信标帧之前，我先睡一会！你给我信标帧我会被叫醒。</p><h3 id="蜂窝网络"><a href="#蜂窝网络" class="headerlink" title="蜂窝网络"></a>蜂窝网络</h3><p><img src="/picture/cell.png"></p><p>两种技术用来共享移动广播频谱：</p><ul><li>FDMA和TDMA的结合：用频率划分频谱，然后把每个信道划分为时间槽</li><li>利用CDMA</li></ul><h4 id="2G网络架构"><a href="#2G网络架构" class="headerlink" title="2G网络架构"></a>2G网络架构</h4><p><img src="/picture/2G.png"></p><h4 id="3G网络架构"><a href="#3G网络架构" class="headerlink" title="3G网络架构"></a>3G网络架构</h4><p><img src="/picture/3G.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
