<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络笔记网络层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/06/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图中的最长路径"><a href="#有向无环图中的最长路径" class="headerlink" title="有向无环图中的最长路径"></a>有向无环图中的最长路径</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行为一个数字<code>n</code>，表示总点数。之后点的标号为从<code>0</code>到<code>n-1</code>。</p><p>之后的每一行，格式为<code>3</code>个数字，以空格隔开，分别为相连的两个点的编号，它们的边的权值。</p><p>注：输入为有向图。如果出现了<code>“0 1 50”</code>表示点<code>0</code>到点<code>1</code>之间有一条边，权值为<code>50</code>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>点0到其他所有点的最长路径，以空格隔开。注：点0到其他所有点都是可达的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度要求在<strong>O(m+n)</strong></p><p>样例输入输出</p><pre class="line-numbers language-none"><code class="language-none">输入：60 1 10 3 21 2 62 4 12 5 23 4 33 1 44 5 1输出：6 12 2 13 14 </code></pre><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先，看到复杂度是线性时间复杂度，我们想到不太可能用类似<code>Dijkstra</code>，<code>Prime</code>之类的算法，大概是用一个<code>DFS</code>或者<code>BFS</code>框架来完成。</p><p>对于有向无环图，我们会敏锐地发觉它的一些特性：从0经过某些顶点之前，路径上必然会经过另一些顶点！！！如果我们在处理顶点A之前，对它之前的所有顶点的路径进行处理的话，我们就可以依托之前的路径来对顶点A进行处理。这句话怎么听起来这么耳熟？没错，这似乎就是动态规划的具体做法！</p><p>众所周知，动态规划的思路就是<strong>利用前面已经求出的子问题来解决其他的子问题</strong>。我们通过前面经过的顶点来求后面的顶点，与这个思想相符。那么我们怎么判断谁在前谁在后呢？联系算法需要的线性复杂度，我们联想到<code>Topo</code>排序，对顶点进行拓扑序小的在前面，拓扑序大的在后面。那么基本的思路逐渐清晰了。</p><p>先利用拓扑排序对顶点进行排序，这样我在遍历某一个顶点A的时候，从0到A的路径上的所有顶点必然已经被遍历过！那么我们如何找到他前面的顶点呢？做法有两种，第一种是建立一个逆邻接表，这样就可以找到哪一个路径通向点A；第二种做法是在遍历A前面节点X的时候，直接对X的邻居进行处理，这样在遍历到A的时候，A已经被处理完了，A的任务就只变成了对A的邻居进行处理。这两种做法本质上是一样的，但是鉴于省下更多的时间和空间，我采用了第二种方法！</p><p>复杂度分析：<code>topo</code>排序是线性复杂度，后面的<code>DP</code>也是线性复杂度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面我们就可以进行Coding了！代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std; //邻接表节点，存储邻居节点和路径长度struct node {    int v, weight;    node(int _v, int _w) { v = _v; weight = _w; }};//邻接表，二维矩阵vector&lt;vector&lt;node&gt;&gt; table;//topo的本质是DFS，需要visit数组vector&lt;bool&gt; visit;//存储topo序，顶端的topo序更小stack&lt;int&gt; topo;//存储答案vector&lt;int&gt; res; void dfs(int v) {    visit[v] = true;    for (int i = 0; i &lt; table[v].size(); i++) {        if(!visit[table[v][i].v])dfs(table[v][i].v);    }    topo.push(v);//在处理过v后面所有的节点之后，v的节点topo序要小于它后面的所有节点} int main() {    int n;    scanf("%d", &amp;n);//初始化         res = vector&lt;int&gt;(n, 0);    visit = vector&lt;bool&gt;(n, false);    table = vector&lt;vector&lt;node&gt;&gt;(n);    int v1, v2, w;    while (scanf("%d %d %d",&amp;v1,&amp;v2,&amp;w)!=-1) {        table[v1].push_back(node(v2, w));    }     dfs(0);//topo排序     while (!topo.empty()) {        int cur = topo.top();        topo.pop();        for (int i = 0; i &lt; table[cur].size(); i++) {//处理cur的邻居            res[table[cur][i].v] = max(res[table[cur][i].v], res[cur] + table[cur][i].weight);        }    }    for (int i = 1; i &lt; n; i++) {        printf("%d ", res[i]);    }     return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记链路层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="一-直接链路"><a href="#一-直接链路" class="headerlink" title="一.直接链路"></a>一.直接链路</h1><p>主机和路由器都是节点。连接相邻结点的信道叫做链路。</p><p>链路的不同类型：</p><ul><li>有线点对点链路</li><li>有线多址链路（LANs）</li><li>无线链路（WIFI）</li></ul><h1 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二.数据链路层"></a>二.数据链路层</h1><p>二层分组（链路层分组）：帧，封装了网络层数据报</p><p>在相邻节点之间或者同一个局域网中的节点之间传送数据</p><p><img src="/picture/image-20210607210230081.png"></p><h2 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h2><p>在主机，路由器，交换机中实现。</p><p>链路层被实现在适配器中<code>"adaptor"</code>，比如网络接口卡（<code>NIC</code>）。以太网卡，802.11卡。</p><p>实现链路层和物理层，和主机的系统总线相连</p><p>硬件软件和固件的结合体</p><h2 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h2><p>提供了4种初级服务</p><h3 id="1-成帧"><a href="#1-成帧" class="headerlink" title="1.成帧"></a>1.成帧</h3><p>添加头尾封装上层数据报成帧</p><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>把数据报封装在帧中，添加错误检测比特，流控信息等等</p><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>寻找错误，进行流控等等。然后提取数据报交付给上层</p><h3 id="2-链路接入"><a href="#2-链路接入" class="headerlink" title="2.链路接入"></a>2.链路接入</h3><p>协调多路媒体访问，MAC地址被用在帧的头部来确定源和目的主机</p><p>全双工和半双工：接收和发送是否同时进行</p><p>有两种链路：</p><ul><li>点对点链路：专用的成对通信<ul><li>长距离光纤链路</li><li>在以太网交换机和主机之间的点对点链路</li></ul></li><li>广播链路：共享线路和媒介<ul><li>传统的以太网</li><li>802.11无线局域网</li></ul></li></ul><p><img src="/picture/image-20210607212004381.png"></p><h4 id="多路访问控制（MAC）"><a href="#多路访问控制（MAC）" class="headerlink" title="多路访问控制（MAC）"></a>多路访问控制（MAC）</h4><p>环境是一个共享的广播信道，它必须避免多个节点同时传送信息，否则碰撞导致数据错误！所以需要一个分布式的算法来决定哪一个节点可以传输数据，这样多路访问协议就诞生了。</p><p>多路访问协议是一个决定节点如何共享信道的分布式的算法，比如决定节点什么时候可以传输数据。关于信道共享的交流必须用到信道本身来交流（没有带外通道进行协作）</p><h4 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h4><p>这里有三种方式</p><h5 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h5><p>把信道分成不同的片，把这些片分配给节点，让节点单独占用</p><h5 id="轮流"><a href="#轮流" class="headerlink" title="轮流"></a>轮流</h5><p>节点轮流传送数据，但是需要发送更多数据的节点可能会等待较长时间</p><h5 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h5><p>信道不被分割，并且允许碰撞。碰撞之后要进行恢复。</p><h3 id="3-可靠交付"><a href="#3-可靠交付" class="headerlink" title="3.可靠交付"></a>3.可靠交付</h3><p>这种服务很少被用在像光纤这样的低比特错误率的链路，用在无线链路是高比特错误率。</p><p>进行流控：控制收发速率，确保发送者不会发送太快导致接收者的buffer溢出，有两种方法：</p><ul><li>停等协议</li><li>滑动窗口协议</li></ul><h4 id="3-1停等协议"><a href="#3-1停等协议" class="headerlink" title="3-1停等协议"></a>3-1停等协议</h4><p>源主机传输帧，目的主机接收帧并且回复ACK</p><p>源主机在收到ACK之前不发送下一个包，目的主机可以通过不发送ACK来停止流</p><p>这种对于大型帧工作得很好</p><p><img src="/picture/image-20210607224657108.png"></p><h4 id="3-2滑动窗口协议"><a href="#3-2滑动窗口协议" class="headerlink" title="3-2滑动窗口协议"></a>3-2滑动窗口协议</h4><p>允许多个帧同时传送。接收者有一个大小为WIn得buffer（窗口），发送者可以发送最多Win个没有收到ACK的帧。每一个帧都被标号，ACK包含了下一个期待的帧的编号。序号被size域的大小k限制，帧的大小以2的k次方取模。</p><p>有一个问题：如果给定WIn，那么如何设置k？Win&lt;=2^k</p><p><img src="/picture/image-20210607224627065.png"></p><p>下面的图帮助理解滑动窗口</p><p><img src="/picture/image-20210607224804564.png"></p><h5 id="3-2-1后退n帧"><a href="#3-2-1后退n帧" class="headerlink" title="3-2-1后退n帧"></a>3-2-1后退n帧</h5><p>如果出现错误就恢复NAK，错误的帧和后面的所有帧都需要重传</p><h5 id="3-2-2选择性拒绝（选择重传）"><a href="#3-2-2选择性拒绝（选择重传）" class="headerlink" title="3-2-2选择性拒绝（选择重传）"></a>3-2-2选择性拒绝（选择重传）</h5><p>只有被拒绝的错误帧需要重传，接收者需要维护一个足够大的buffer</p><h3 id="4-错误检测和纠正"><a href="#4-错误检测和纠正" class="headerlink" title="4.错误检测和纠正"></a>4.错误检测和纠正</h3><p>处理由信号衰减和噪声导致的错误。接收者检测错误的出现，让信号发送者重传或者直接丢弃帧</p><p><img src="/picture/image-20210607225210550.png"></p><p>EDC是错误检测纠正码（冗余码），D是被错误检查保护的数据（包括头）</p><p>注意错误检测不是百分百可靠！比较大的EDC能更好的检测和纠正错误</p><h4 id="4-1奇偶校验法"><a href="#4-1奇偶校验法" class="headerlink" title="4-1奇偶校验法"></a>4-1奇偶校验法</h4><p>单比特奇偶校验：只能检测一位错误</p><p><img src="/picture/image-20210607225453805.png"></p><p>二维奇偶校验：能够检测和纠正单比特错</p><p><img src="/picture/image-20210607225658684.png"></p><h4 id="4-2CRC循环冗余码"><a href="#4-2CRC循环冗余码" class="headerlink" title="4-2CRC循环冗余码"></a>4-2CRC循环冗余码</h4><p>CRC被广泛运用硬件实现。数据部分D是二进制数字，有d位。选择一个<code>r+1</code>位的模式串G（生成多项式）<br>$$<br>𝐷∗2^𝑟=𝑎∗𝐺⊕𝑅, so 𝐷∗2^𝑟⊕R=a*G<br>$$<br>发送方发送左侧的<code>𝐷∗2^𝑟⊕R</code>代表<code>&lt;D,R&gt;</code></p><p>接收方当收到<code>&lt;D,R&gt;</code>的时候，如果被G整除就没错，否则就有错</p><p>限制：只可以检测出少于r+1位的突发错误</p><p><img src="/picture/image-20210607230618063.png"></p><h1 id="三-不同类型的局域网"><a href="#三-不同类型的局域网" class="headerlink" title="三.不同类型的局域网"></a>三.不同类型的局域网</h1><p>局域网有不同的拓扑</p><p><img src="/picture/image-20210607205650526.png"></p><h2 id="1-令牌环Token-Ring"><a href="#1-令牌环Token-Ring" class="headerlink" title="1.令牌环Token Ring"></a>1.令牌环Token Ring</h2><p>令牌环是一种局域网协议（IEEE802.5）</p><p>从IBM的商业的令牌环开始发展。因为IBM，令牌环获得了广泛的接受，但是从来没有达到以太网的流行程度</p><h3 id="环的操作"><a href="#环的操作" class="headerlink" title="环的操作"></a>环的操作</h3><p>每一个转发器（repeater）通过单向的传输链路连接另外两个，转发器扮演连接点的角色。</p><p><img src="/picture/image-20210607202641735.png"></p><p>数据一个比特一个比特地从一个转发器到另一个转发器传输。</p><ul><li>转发器重新生成和重传每一个比特</li><li>转发器执行数据插入，数据接收，数据删除的功能</li></ul><p>帧再进行一个循环的传递之后被发送器移除</p><h4 id="不同的状态"><a href="#不同的状态" class="headerlink" title="不同的状态"></a>不同的状态</h4><p><img src="/picture/image-20210607203827632.png"></p><h5 id="侦听状态"><a href="#侦听状态" class="headerlink" title="侦听状态"></a>侦听状态</h5><ul><li>扫描通过的比特流的模式：<ul><li>相连的站点的地址和目的站点的地址</li><li>令牌的传输权限</li></ul></li><li>复制输入位，发送给相连的站点<ul><li>如果目的地址匹配</li><li>再传发每一个比特</li></ul></li><li>当经过的的时候修改比特<ul><li>比如，表示数据包已经被复制（ACK）</li><li>或者做一个保留</li></ul></li></ul><h5 id="传输状态"><a href="#传输状态" class="headerlink" title="传输状态"></a>传输状态</h5><ul><li>回收帧，然后传回站点（为了ACK）</li><li>缓存别人的帧等候重传</li></ul><h5 id="路过的状态"><a href="#路过的状态" class="headerlink" title="路过的状态"></a>路过的状态</h5><ul><li>什么也不做</li></ul><h3 id="802-5MAC协议"><a href="#802-5MAC协议" class="headerlink" title="802.5MAC协议"></a>802.5MAC协议</h3><p>一个小的帧（令牌）在等候的时候循环，站点等待令牌</p><p>改变令牌的一个bit让它变成SOF（Start of Frame），然后再后面添加剩下的数据帧的内容</p><p>帧进行一个环形的旅行，然后被某一个传输站点吸收。然后站台当传输结束的时候插入新令牌</p><p>轻负载的时候有点效率底下，高度负载的时候，进行轮询</p><p><img src="/picture/image-20210607204827237.png"></p><h4 id="802-5的物理层"><a href="#802-5的物理层" class="headerlink" title="802.5的物理层"></a>802.5的物理层</h4><p><img src="/picture/image-20210607205538538.png"></p><h2 id="2-以太网Ethernet"><a href="#2-以太网Ethernet" class="headerlink" title="2.以太网Ethernet"></a>2.以太网Ethernet</h2><p>以太网是一种主导有线局域网的技术，有如下的好处：</p><ul><li>NIC网卡比较便宜</li><li>首先被广泛运用于局域网技术</li><li>比令牌局域网和ATM简单廉价</li><li>速度比较不错</li></ul><h3 id="以太网的物理拓扑"><a href="#以太网的物理拓扑" class="headerlink" title="以太网的物理拓扑"></a>以太网的物理拓扑</h3><h4 id="总线：在90年代中期很流行"><a href="#总线：在90年代中期很流行" class="headerlink" title="总线：在90年代中期很流行"></a>总线：在90年代中期很流行</h4><p>所有节点在同一个碰撞域中，可以互相碰撞</p><h4 id="星型拓扑：现在比较盛行"><a href="#星型拓扑：现在比较盛行" class="headerlink" title="星型拓扑：现在比较盛行"></a>星型拓扑：现在比较盛行</h4><p>每一个节点运行一个分离的以太网协议，不会相互碰撞（一般用交换机作为星型中心）</p><p><img src="/picture/image-20210607141806849.png"></p><p>下面说说他们的比较；广播vs交换以太网</p><p>总线拓扑是一种广播技术</p><ul><li>主机之间共享信道</li><li>每个包被所有相连的主机收到</li><li>通过CSMA/CD来进行媒体访问控制</li></ul><p>现代的以太网是交换以太网</p><ul><li>链路是交换机之间或者交换机和主机之间的</li><li>不需要共享信道-&gt;不用CSMA/CD</li><li>依靠自学习和生成树算法来路由！！</li></ul><h3 id="以太网的发展演变"><a href="#以太网的发展演变" class="headerlink" title="以太网的发展演变"></a>以太网的发展演变</h3><p>几乎除了帧的格式以外的所有东西都变了</p><ul><li>从共享媒介的线缆变成专用链路！</li></ul><ul><li>速度从3Mbps变成100Gbps！</li></ul><ul><li>从电子信号变成光信号！</li></ul><p>我们从中学到什么？正确的方法（比如以太网）可以经受得住很多改变，并且在保持方法的时候要更新技术！（后向兼容）</p><h3 id="以太网：不可靠，无连接"><a href="#以太网：不可靠，无连接" class="headerlink" title="以太网：不可靠，无连接"></a>以太网：不可靠，无连接</h3><p>无连接是说在收发的NIC之间没有握手的过程</p><p>不可靠是说接收者的NIC不给发送者的NIC发送确认消息，这样只有更上层的协议有可靠传输协议（TCP）才可以让丢掉的包得到恢复，否则抛弃的包就丢了！</p><h3 id="以太网帧的格式"><a href="#以太网帧的格式" class="headerlink" title="以太网帧的格式"></a>以太网帧的格式</h3><p>前导码Preamble：有七个字节，为了时钟同步，有一个字节指出帧的开始！</p><p>MAC地址Addresses：6字节，一共48bit</p><p>类型Type：2字节，填入上层协议，比如IP</p><p>数据负载Data payload：最大1500字节，最小46字节</p><p>CRC循环冗余码：4字节，一共32bit，进行错误检测</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>MAC地址是一个和网络适配器有关的数值地址</p><p>有48bit的名空间，比如16进制的00-15-C5-49-04-A9</p><p>当适配器生产时候就有一个独一无二的硬编码MAC地址</p><h5 id="MAC地址的分配"><a href="#MAC地址的分配" class="headerlink" title="MAC地址的分配"></a>MAC地址的分配</h5><p>分为不同的块，在MAC地址的前3个字节，被分配给不同的厂家，下面的3个字节由厂家来分配给每一个适配器</p><h3 id="成帧Framing-frames"><a href="#成帧Framing-frames" class="headerlink" title="成帧Framing frames"></a>成帧Framing frames</h3><p>物理层把bit放入链路，但是两个联通在相同物理媒介的主机需要交换帧，这个服务由链路层提供，由网络适配器来实现！</p><p>那么有一个问题：链路层如何判断每个帧的起止位置呢？</p><ol><li><p>简单的方法：比特计数，在帧的开始填入后面所跟的数据的大小，然后接受者根据这个值来解析！有一个缺点就是，如果这个计数的数值错了，将导致后面的帧全部错误！</p></li><li><p>哨兵位：用哨兵来标记帧的起止位置，<code>01111110</code>表示开始，<code>01111111</code>表示结束。但是有一个问题，如果在数据里面有哨兵怎么办？问题的解决办法是比特填充，如果在内容里面遇到5个1就在后面插入一个0，然后接收方每遇到5个1就拿掉后面的1个0！</p><p><img src="/picture/image-20210607145115984.png"></p></li></ol><p>举个例子，如果接收者看见了5个1：后面如果是0，那么就移走它继续解析；如果后面是1的话再看下一位，下一位是0，说明是帧的开始，否则是帧的结束！</p><h3 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h3><p><img src="/picture/image-20210607145201877.png"></p><h4 id="802-3的物理层"><a href="#802-3的物理层" class="headerlink" title="802.3的物理层"></a>802.3的物理层</h4><p>有许多不同的标准：</p><ul><li><p>类似的MAC协议和帧格式</p></li><li><p>不同的速率：2Mbps，10Mbps，100Mbps，1Gbps，10Gbps</p></li><li><p>不同的物理媒介：线缆，光纤</p><p><img src="/picture/image-20210607145639218.png"></p></li></ul><h1 id="四-媒体访问控制（MAC）"><a href="#四-媒体访问控制（MAC）" class="headerlink" title="四.媒体访问控制（MAC）"></a>四.媒体访问控制（MAC）</h1><p> 多路访问链路的性质：</p><ul><li>单一的共享广播信道</li><li>两个或以上的节点同时发送数据就会相互干扰</li><li>碰撞：节点同时接收两个或者更多信号</li></ul><h2 id="多路访问协议："><a href="#多路访问协议：" class="headerlink" title="多路访问协议："></a>多路访问协议：</h2><ul><li>决定节点如何共享信道的分布式算法，比如决定节点什么时候可以传输</li><li>关于信道共享的规划需要用到信道本身</li></ul><p>一个理想的多路访问协议是下面这样，给定一个广播信道的速率<code>R bps</code>，我们想要</p><ol><li>一个节点发送时，速率可以达到R</li><li>M个节点发送时，每个节点速率可达到R/ M</li><li>纯粹的分布式（去中心化）<ol><li>不需要特殊节点来协调传输</li><li>不需要同步时钟</li></ol></li><li>尽可能简单！</li></ol><h3 id="1-信道划分"><a href="#1-信道划分" class="headerlink" title="1.信道划分"></a>1.信道划分</h3><h4 id="1-1时分多路复用time-division-multiple-access"><a href="#1-1时分多路复用time-division-multiple-access" class="headerlink" title="1-1时分多路复用time division multiple access"></a>1-1时分多路复用time division multiple access</h4><p>把时间切分成等大的时间片，分为不同的轮次。每个站点得到固定大小的时间片（slot），如果轮到某个节点的时间片了，但是节点没有发送，那么这个时间片空闲！</p><p>可以达到的目标234</p><p>例如下面：6个站点，134要发包，256空闲</p><p><img src="/picture/TDMA.png"></p><h4 id="1-2频分多路复用frequence-division-muliple-access"><a href="#1-2频分多路复用frequence-division-muliple-access" class="headerlink" title="1-2频分多路复用frequence division muliple access"></a>1-2频分多路复用frequence division muliple access</h4><p>把信道划分为不同的频段，每个站点分配固定的频段，没有用到的频段空闲！FDMA和TDMA类似</p><h4 id="1-3码分多址复用（CDMA）"><a href="#1-3码分多址复用（CDMA）" class="headerlink" title="1-3码分多址复用（CDMA）"></a>1-3码分多址复用（CDMA）</h4><p>多用于无线广播网络，例如蜂窝网，卫星等等。</p><p>所有的节点共享相同的频率，但是每个节点有自己的chipping序号来编码数据</p><p>编码求原始数据 X chipping序号；解码求原始数据和chipping序号的内积</p><p>S1(D1XS1+D2XS2+D2XS3)/(|S1|^2)</p><p>需要code是正交的，多个节点可以以最小的干扰同时传输</p><p>CDMA计算比较复杂</p><p><img src="/picture/CDMA.png"></p><h3 id="2-轮流"><a href="#2-轮流" class="headerlink" title="2.轮流"></a>2.轮流</h3><h4 id="2-1轮询Polling"><a href="#2-1轮询Polling" class="headerlink" title="2-1轮询Polling"></a>2-1轮询Polling</h4><p>主节点邀请从节点轮流传输，傻瓜式从节点设备，比如蓝牙</p><p>问题：产生轮询开销，时延，master出问题所有都出问题，不是完全的分布式</p><p><img src="/picture/%E8%BD%AE%E8%AF%A2.png"></p><p>2-2令牌传递</p><p>控制令牌按照顺序从一个节点发送到下一个节点</p><p>问题：令牌的额外开销，时延，单个节点出错导致令牌丢失</p><h3 id="3-随机访问"><a href="#3-随机访问" class="headerlink" title="3.随机访问"></a>3.随机访问</h3><p>当节点有分组要发送的时候，以全速R进行发送，节点之间没有提前协调！如果多个节点同时传输就造成<strong>碰撞</strong></p><p>随机访问MAC协议指定如何检测和避免碰撞，如何从碰撞中恢复</p><p>随机访问多路媒体访问控制协议有：</p><ul><li>ALOHA，slotted ALOHA</li><li>CSMA，CSMA/CD，CSMA/CA</li></ul><h4 id="3-1ALOHA"><a href="#3-1ALOHA" class="headerlink" title="3-1ALOHA"></a>3-1ALOHA</h4><p>Additive Link On-line HAwaii system，被夏威夷大学设计</p><p>对于发送方：</p><ol><li>如果有帧要发就发</li><li>如果得到ACK就继续，否则以概率p重传，或者以1-p的概率等待</li><li>如果重复重传还没有ACK就放弃</li></ol><p>对于接收方：</p><ol><li>检查帧是否有问题</li><li>如果帧没问题，并且地址正确就发送ACK</li></ol><p>帧有可能被噪声和碰撞毁坏，有可能是另一个站点同时在发送，帧的任何一种重叠都会造成碰撞</p><p><img src="/picture/ALOHA.png"></p><h4 id="3-2时隙ALOHA"><a href="#3-2时隙ALOHA" class="headerlink" title="3-2时隙ALOHA"></a>3-2时隙ALOHA</h4><p>所有的帧大小相同，每一个时隙等于帧的传输时间。节点是同步的，需要一个中心时钟来同步时间。从一个时隙起点开始传输。帧要么不冲突，要么就完全冲突。</p><p>具体做法：节点如果有帧要传输，要在下一个时隙开始传输，如果没有碰撞节点下一个时隙就继续传输；如果有碰撞就每个时隙以p的概率重传</p><p><img src="/picture/slotALOHA.png"></p><h4 id="3-4CSMA载波侦听多路访问"><a href="#3-4CSMA载波侦听多路访问" class="headerlink" title="3-4CSMA载波侦听多路访问"></a>3-4CSMA载波侦听多路访问</h4><p>在传输之前先侦听，如果信道空闲就发送，否则停下来等待再发送。类比到人类就是在别人讲话时候不要打断别人。但是不可以消除所有碰撞，因为有传播时延！！！</p><p><img src="/picture/csma%E7%A2%B0%E6%92%9E.png"></p><h5 id="3-4-1-非持续CSMA"><a href="#3-4-1-非持续CSMA" class="headerlink" title="3-4-1 非持续CSMA"></a>3-4-1 非持续CSMA</h5><ol><li>站点要传输的时候就监听，如果空闲就传输，否则转到2</li><li>如果繁忙，等待一个随机的时间，转到1</li></ol><p>随机时间减小了碰撞的可能性，但是信道空间会被浪费，因为在传输完当前的包之后可能会等待</p><h5 id="3-4-2-1-坚持CSMA"><a href="#3-4-2-1-坚持CSMA" class="headerlink" title="3-4-2 1-坚持CSMA"></a>3-4-2 1-坚持CSMA</h5><p>为了避免等待信道时间造成的浪费，采用1坚持</p><ol><li>站点希望传输的时候监听，如果空闲就传输，否则转到2</li><li>如果繁忙就一直监听到空闲，空闲时立刻重传</li></ol><p>这是一种比较自私的做法，如果多个站点同时监听等待，肯定会造成碰撞</p><h5 id="3-4-3-p-坚持CSMA"><a href="#3-4-3-p-坚持CSMA" class="headerlink" title="3-4-3 p-坚持CSMA"></a>3-4-3 p-坚持CSMA</h5><p>一个折中的办法是p坚持CSMA，像非持续CSMA一样尽量减少碰撞，像1持续CSMA那样尽量减少等待时间</p><ol><li>如果监听信道空闲，以概率p的概率发送，以1-p的概率延迟一个时间单元（时间单元等于传播时延的最大值）</li><li>如果信道繁忙，监听知道空闲，然后转到1</li><li>延迟了一个时间单元之后，转到1</li></ol><p>那么p的值最好取多少呢？</p><p>我们p值的目标是避免在高负载的情况下的不稳定性</p><p>如果N个站点等候发送，理论上最好的值是1/N；如果是高负载的话，p是很小的，从而站点等候时间变长，造成很长时间的延迟！</p><h5 id="3-4-4比较！"><a href="#3-4-4比较！" class="headerlink" title="3-4-4比较！"></a>3-4-4比较！</h5><p>下面是不同类型CSMA的比较</p><p><img src="/picture/dCSMA.png"></p><h4 id="3-5-CSMA-CD-collision-detection"><a href="#3-5-CSMA-CD-collision-detection" class="headerlink" title="3-5 CSMA/CD(collision detection)"></a>3-5 CSMA/CD(collision detection)</h4><p>在使用CSMA的话，碰撞在传输期间仍然会发生，所以CSMA/CD碰撞传输一旦被检测到就会中断。具体做法如下：</p><ol><li>站点在传输的时候侦听，如果空闲就传输，否则转2</li><li>如果繁忙，持续侦听直到空闲。然后立刻传输</li><li>如果检测到碰撞，发送拥塞信号然后终止传输</li><li>在拥塞之后，等待一个随机的时间然后转到1</li></ol><p>下面是碰撞的发生</p><p><img src="/picture/CSMAcd.png"></p><h5 id="帧的最小长度"><a href="#帧的最小长度" class="headerlink" title="帧的最小长度"></a>帧的最小长度</h5><p>为了能够检测出碰撞，我们需要限制最小的帧的长度，否则有可能检测不到碰撞。</p><p>如下图，我们假设信道长度是L，传播的速度是V，带宽是B，帧的大小是size，那么从一端到另一端传播时延是<code>L/V</code>，如果在主机2即将传播到4的时候（t=L/V），4发送了帧，这样从主机4发送的帧到达主机2的时间t=2L/V，这样只有当传输时间大于2L/V时才可以检测到碰撞，也就是<code>size/B&gt;2L/V</code>！</p><p><img src="/picture/%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E.png"></p><h4 id="总结-随机访问的三个重要思想"><a href="#总结-随机访问的三个重要思想" class="headerlink" title="总结.随机访问的三个重要思想"></a>总结.随机访问的三个重要思想</h4><h5 id="载波侦听"><a href="#载波侦听" class="headerlink" title="载波侦听"></a>载波侦听</h5><ul><li>在讲话之前先侦听，不要打扰其他人讲话</li><li>检测是否已经有人在说话了</li><li>等到别人说完</li></ul><h5 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h5><ul><li>有别人同时说话就停下来，但是要确保所有人都知道碰撞了（最小帧长度的限制）</li><li>了解什么时候两个节点立刻传输</li><li>通过检测数据是否混乱来检测碰撞</li></ul><h5 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h5><ul><li>不要立刻重传</li><li>等一个随机时间再重传</li></ul><p>应该等待多久时间？</p><p>IEEE802.3使用1持续的CSMA，采用二进制指数退避的方式</p><ol><li>在前十次尝试发送中，每一次随机延迟的时间加倍，比如第一次重传从1 2里面选，第二次重传从1 2 3 4里面选….</li><li>超过十次重传的话，就保持第十次的最大时间不变，从中选择一个时间重传</li><li>超过16次重传说明信道过于繁忙，就会放弃，并且报告错误！</li></ol><p>1持续的二进制指数退避算法在很大范围的负载内表现得不错：低负载的时候保证了效率，高负载的时候保证了稳定性</p><h4 id="以太网CSMA-CD算法"><a href="#以太网CSMA-CD算法" class="headerlink" title="以太网CSMA/CD算法"></a>以太网CSMA/CD算法</h4><p>下面是以太网CSMA/CD算法的描述：</p><p><img src="/picture/ethernetcsmacd.png"></p><p>流程图</p><p><img src="/picture/cdmacdliuchengtu.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
