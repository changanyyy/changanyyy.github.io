<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT6-828-note-lab2</title>
      <link href="/2021/07/19/MIT6-828-note-lab2/"/>
      <url>/2021/07/19/MIT6-828-note-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="一-开篇"><a href="#一-开篇" class="headerlink" title="一.开篇"></a>一.开篇</h2><p><code>Lab2</code>的代码量要明显多于<code>Lab1</code>，可以说是难度层层递进，这个实验主要是开启分页机制，打开虚拟地址机制。这个正是我在操作系统课上没有锻炼到的地方！话不多说，我的思考过程在下面。</p><h2 id="二-Lab2"><a href="#二-Lab2" class="headerlink" title="二.Lab2"></a>二.Lab2</h2><h3 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h3><h4 id="1-1怎么开的保护模式？"><a href="#1-1怎么开的保护模式？" class="headerlink" title="1-1怎么开的保护模式？"></a>1-1怎么开的保护模式？</h4><p>我们在合并了<code>Lab1</code>之后，先来回顾一下操作系统启动的过程。</p><p>我们从<code>Kernel</code>开始，首先进入<code>entry.S</code>，然后把一个简易的页表加载上<code>cr3</code>去，这个页表的作用是把内存的<code>[KERNBASE, KERNBASE+4MB)</code>和<code>[0, 4MB)</code>都映射到物理地址<code>[0, 4MB)</code>上去！为什么要把虚拟地址<code>[0, 4MB)</code>也映射上去呢？原因是在我开启分页之后，就从实地址模式变成了保护模式，<code>CPU</code>解析地址的方式就变化了。而我们下面还有两行汇编指令的地址位于低地址，而此时的<code>EIP</code>仍然位于低地址部分！这样开启分页之后，才可以获取到正确的指令！然后通过<code>jmp</code>指令跳转到虚拟地址<code>0xf0000000</code>地址的位置！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​```assembly</span><br><span class="line">mov$relocated, %eax</span><br><span class="line">jmp*%eax</span><br><span class="line">​```</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2设置简易的栈"><a href="#1-2设置简易的栈" class="headerlink" title="1-2设置简易的栈"></a>1-2设置简易的栈</h4><p>下面<code>relocated</code>的作用是初始化一下栈区，从下面的代码可以看出，栈区的大小是<code>KSTKSIZE</code>，栈区的栈顶位于高地址，即<code>bootstacktop</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.p2alignPGSHIFT# force page alignment</span><br><span class="line">.globlbootstack</span><br><span class="line">bootstack:</span><br><span class="line">.spaceKSTKSIZE</span><br><span class="line">.globlbootstacktop   </span><br><span class="line">bootstacktop:</span><br></pre></td></tr></tbody></table></figure><p>随即把栈顶指针赋值给<code>esp</code>，调用<code>i386_init</code>函数进行进一步初始化！</p><h4 id="1-3初始化函数"><a href="#1-3初始化函数" class="headerlink" title="1-3初始化函数"></a>1-3初始化函数</h4><p>进入初始化函数，我们看见第一件事情就是初始化<code>.bss</code>段，初始化为0，因为在<code>ELF</code>文件里面，这个段只标出了大小，并不分配空间。</p><p>然后进行一些显示，输入，输出等初始化活动，最后进入<code>mem_init</code>，这个就是本次实验的核心函数！</p><h3 id="2-开始coding"><a href="#2-开始coding" class="headerlink" title="2.开始coding"></a>2.开始coding</h3><h4 id="2-1进入内存初始化！"><a href="#2-1进入内存初始化！" class="headerlink" title="2-1进入内存初始化！"></a>2-1进入内存初始化！</h4><p>进入内存初始化函数之后，我们先检测以下硬件提供的内存，这个工作由<code>i386_detect_memory</code>函数来完成。</p><h4 id="2-2为必要的DS分配内存"><a href="#2-2为必要的DS分配内存" class="headerlink" title="2-2为必要的DS分配内存"></a>2-2为必要的DS分配内存</h4><p>继续往下看，看见是给<code>kern_pgdir</code>变量赋值，我们可以看见它的定义是一个全局变量，表示的是页目录的首地址！我们可以知道，页目录所对应逻辑地址中的10比特，那么一共有页目录<code>2^10=1024</code>个！而一个页目录项的大小是4字节，所以一个页目录占用的大小刚好是一个页面的大小！所以我们用<code>boot_alloc</code>函数来对页目录进行分配空间（后面会提到这个函数具体干啥的）。分配完之后，还要清零。</p><p>下面一步是分配一个<code>pages</code>数组，每一项对应一个物理页框，我们可以得知一共有<code>npages</code>个物理页框，所以代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">pages=(struct PageInfo *)boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>现在既然关于页面和页目录的数据结构分配完了，我们就对这些内存进行初始化！</p><h4 id="2-3初始化分页"><a href="#2-3初始化分页" class="headerlink" title="2-3初始化分页"></a>2-3初始化分页</h4><p>对于<code>page_init</code>函数，我们要做的是把已经分配出去的页框和空闲页框分类，空闲页框用一个链表串起来！</p><p>在注释里已经提示我们哪里是可以分配，哪里是不可以分配的</p><ol><li> Mark physical page 0 as in use. This way we preserve the real-mode IDT and BIOS structures in case we ever need them.  (Currently we don’t, but…)</li><li>The rest of base memory, <code>[PGSIZE, npages_basemem * PGSIZE)</code> is free.</li><li>Then comes the IO hole <code>[IOPHYSMEM, EXTPHYSMEM)</code>, which must never be allocated.</li><li>Then extended memory <code>[EXTPHYSMEM, ...)</code>.Some of it is in use, some is free. Where is the kernel in physical memory?  Which pages are already in use for page tables and other data structures?</li></ol><p>我们如何理解呢？首先，0号物理页已经被<code>BIOS</code>和引导程序之类的代码占领了（以后我们还要用的），所以0号页面必然不可能是空闲的。从1号物理页面到<code>base_memory</code>的末尾，都是空闲的（也就是图片对应的<code>Low Memory</code>），可以从检测函数的输出看出一共有<code>640KB</code>，然后剩下的就是<code>ext_memory</code>，就很多了。</p><p><code>IOPHYSMEM=0x000A0000，EXTPHYSMEM=0x00100000</code>，这两者中间的是关于<code>BIOS</code>和一些显示有关的区域，不可以被分配！从<code>0x100000</code>开始的部分，就是我们自由分配的部分，有的是空闲有的却不是，但是根据我们刚开始用<code>boot_alloc</code>函数分配的规则来看，我们是按照顺序分配的，所以在<code>boot_alloc(0)</code>之前（<code>boot_alloc(0)</code>返回值是第一个以页为对齐标准的空闲的物理内存的地址！）所以在<code>EXTPHYSMEM</code>和<code>boot_alloc(0)</code>之间的内存区域也不是空闲的，而且是系统必要的数据，比如页面结构<code>PageInfo</code>，页目录，内核代码！</p><p><img src="/picture/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png" alt="物理内存"></p><p>根据上面的提示，我们对物理内存进行了庖丁解牛。于是，我写出了如下优美的代码（x）：</p><p>需要注意的是空闲页面链表使用的是头插法！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">page_free_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) {</span><br><span class="line"><span class="keyword">if</span>(</span><br><span class="line">i==<span class="number">0</span> </span><br><span class="line">||</span><br><span class="line">(</span><br><span class="line">page2pa(&amp;pages[i]) &gt;= IOPHYSMEM </span><br><span class="line">&amp;&amp; </span><br><span class="line">page2pa(&amp;pages[i]) &lt; EXTPHYSMEM</span><br><span class="line">) </span><br><span class="line">||</span><br><span class="line">(</span><br><span class="line">page2pa(&amp;pages[i]) &gt;= EXTPHYSMEM </span><br><span class="line">&amp;&amp;</span><br><span class="line">page2kva(&amp;pages[i]) &lt; boot_alloc(<span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">){</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line"><span class="comment">//cprintf("pagefree %d",i);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4关于物理页的操作"><a href="#2-4关于物理页的操作" class="headerlink" title="2-4关于物理页的操作"></a>2-4关于物理页的操作</h4><h5 id="2-4-1-page-alloc"><a href="#2-4-1-page-alloc" class="headerlink" title="2-4-1 page_alloc"></a>2-4-1 page_alloc</h5><p>这个函数就是为了分配一个物理页，从今往后代替<code>boot_alloc</code>函数。</p><p>我们已经在<code>page_init</code>函数里面初始化了空闲物理页链表，这就说明我们如果要分配一个物理页面，就要在空闲页面链表里面找。当链表头是<code>NULL</code>的时候，就说明页面分配完了。还有如果置零标志位为1，那么要初始清零！</p><p>分配物理页的时候并不需要给<code>ref+1</code>，因为它还没有和一个虚拟页面进行关联！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with '\0' bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//cprintf("Entry page alloc\n");</span></span><br><span class="line"><span class="comment">//out of memory</span></span><br><span class="line"><span class="keyword">if</span>(page_free_list == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">ret</span> =</span> page_free_list;</span><br><span class="line">page_free_list = page_free_list -&gt; pp_link;</span><br><span class="line">ret -&gt; pp_link = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO){</span><br><span class="line"><span class="built_in">memset</span>(page2kva(ret), <span class="string">'\0'</span>, PGSIZE);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-4-2-page-free"><a href="#2-4-2-page-free" class="headerlink" title="2-4-2 page_free"></a>2-4-2 page_free</h5><p>这个函数用来把物理页框归还到空闲页框链表中。使用头插法！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line"><span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"><span class="keyword">if</span>(pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link != <span class="literal">NULL</span>)</span><br><span class="line">panic(<span class="string">"page_free: pp is not a page in use\n"</span>);</span><br><span class="line">pp-&gt;pp_link = page_free_list;</span><br><span class="line">page_free_list = pp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}.</span><br></pre></td></tr></tbody></table></figure><h5 id="2-4-3-page-decref"><a href="#2-4-3-page-decref" class="headerlink" title="2-4-3 page_decref"></a>2-4-3 page_decref</h5><p>这个函数用来在删除映射过程中，衰减页框的引用位，当没有被引用时，就释放这个页框！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Decrement the reference count on a page,</span></span><br><span class="line"><span class="comment">// freeing it if there are no more refs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_decref</span><span class="params">(struct PageInfo* pp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (--pp-&gt;pp_ref == <span class="number">0</span>)</span><br><span class="line">page_free(pp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-5关于映射"><a href="#2-5关于映射" class="headerlink" title="2-5关于映射"></a>2-5关于映射</h4><h5 id="2-5-1-page-walk"><a href="#2-5-1-page-walk" class="headerlink" title="2-5-1 page_walk"></a>2-5-1 page_walk</h5><p>这个函数刚开始我没有理解，后来在一遍遍反复阅读中我知道了它的作用：返回值是虚拟地址<code>va</code>对应的页表项的地址！（虚拟地址）</p><p>因为这个虚拟地址对应的页表页可能还没有用到，所以就没有被映射，所以需要对它分配一个物理页框，同时让页目录表项填写这个物理页框的物理地址，然后把物理页框中对应页表项的地址作为返回值。</p><p>那么如何判断页表项对应的物理页框是否存在呢，那就是通过<code>present</code>位来进行判断！当对应页目录项的存在位为0，说明对应页目录表项还不存在。这时再根据<code>create</code>位来确认是否要创建新的表项。</p><p>如果存在的话，那就直接返回对应的页表项地址即可！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given 'pgdir', a pointer to a page directory, pgdir_walk returns</span></span><br><span class="line"><span class="comment">// a pointer to the page table entry (PTE) for linear address 'va'.</span></span><br><span class="line"><span class="comment">// This requires walking the two-level page table structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The relevant page table page might not exist yet.</span></span><br><span class="line"><span class="comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span></span><br><span class="line"><span class="comment">//    - If the allocation fails, pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">//    - Otherwise, the new page's reference count is incremented,</span></span><br><span class="line"><span class="comment">//the page is cleared,</span></span><br><span class="line"><span class="comment">//and pgdir_walk returns a pointer into the new page table page.</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_walk</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">int</span> pde_idx = PDX(va);</span><br><span class="line"><span class="keyword">int</span> pte_idx = PTX(va);</span><br><span class="line"><span class="keyword">pte_t</span> *ptep = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> present = pgdir[pde_idx] &amp; PTE_P;</span><br><span class="line"><span class="keyword">if</span>(!present &amp;&amp; create == <span class="number">0</span>){</span><br><span class="line"><span class="comment">//cprintf("ptep ");</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!present &amp;&amp; create == <span class="number">1</span>){</span><br><span class="line">struct PageInfo* pg = page_alloc(ALLOC_ZERO);</span><br><span class="line"><span class="comment">//cprintf("ptep ");</span></span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">pg-&gt;pp_ref++;</span><br><span class="line">ptep = (<span class="keyword">pte_t</span> *) KADDR(page2pa(pg));</span><br><span class="line"><span class="comment">//cprintf("ptep = %x\n", ptep);</span></span><br><span class="line">pgdir[PDX(va)] = page2pa(pg) | PTE_W | PTE_U | PTE_P;</span><br><span class="line"><span class="keyword">return</span> &amp;ptep[PTX(va)];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">ptep = (<span class="keyword">pte_t</span> *)KADDR(PTE_ADDR(pgdir[pde_idx])); </span><br><span class="line"><span class="comment">//cprintf("ptep = %x\n", ptep);</span></span><br><span class="line"><span class="keyword">return</span> &amp;ptep[PTX(va)];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-5-2-page-insert"><a href="#2-5-2-page-insert" class="headerlink" title="2-5-2 page_insert"></a>2-5-2 page_insert</h5><p>这个函数用来进行一个映射，给定页目录表项，给定物理页框（当然是<code>page_alloc</code>分配出来的），还有保护位的参数。我们需要做的是把虚拟地址对应的页面映射到物理页框上！</p><p>我们首先要做的就是先获取对应页表项的地址，然后看看是否已经映射了，如果这片虚拟地址已经映射在同一个物理页框上，那么就不可以<code>remove</code>掉，因为一旦<code>remove</code>掉就可能分配不到同一个页框！！！（因为如果有多个进程占用页框）但是可能需要更改标志位，所以先把标志位清零再更改标志位。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *ptep = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ptep == <span class="literal">NULL</span>)<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"><span class="keyword">if</span>((*ptep) &amp; PTE_P){</span><br><span class="line"><span class="keyword">if</span>(PTE_ADDR(*ptep)==page2pa(pp)){</span><br><span class="line">*ptep &amp;= ~<span class="number">0xffe</span>;</span><br><span class="line">*ptep |= perm | PTE_P;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">page_remove(pgdir, va);</span><br><span class="line">}</span><br><span class="line">*ptep = page2pa(pp) | perm | PTE_P;</span><br><span class="line">pp -&gt; pp_ref++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-5-3-page-lookup"><a href="#2-5-3-page-lookup" class="headerlink" title="2-5-3 page_lookup"></a>2-5-3 page_lookup</h5><p>这个函数是用来查找对应虚拟地址是否已经映射到对应的物理页框中去，如果已经映射返回对应的<code>PageInfo</code>结构，否则返回<code>NULL</code>，并且把<code>pte</code>存入<code>pte_store</code>中去。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span>* ptep = pgdir_walk(pgdir, (<span class="keyword">void</span> *)va, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ptep == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(pte_store)*pte_store = ptep;</span><br><span class="line"><span class="comment">//cprintf("%x\n", PTE_ADDR(*ptep));</span></span><br><span class="line"><span class="keyword">if</span>(!((*ptep) &amp; PTE_P))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> pa2page(PTE_ADDR(*ptep));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-5-4-page-remove"><a href="#2-5-4-page-remove" class="headerlink" title="2-5-4 page_remove"></a>2-5-4 page_remove</h5><p>这个函数是移去映射，先关闭<code>va</code>对应的<code>tlb</code>，再对对应的<code>PTE</code>清零！最后别忘了减小<code>ref</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line">tlb_invalidate(pgdir,va);</span><br><span class="line"><span class="keyword">pte_t</span> *ptep = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pg</span> =</span> page_lookup(pgdir, va, &amp;ptep);</span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">*ptep = <span class="number">0</span>;</span><br><span class="line">page_decref(pg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-5-5-boot-map-region"><a href="#2-5-5-boot-map-region" class="headerlink" title="2-5-5 boot_map_region"></a>2-5-5 boot_map_region</h5><p>映射函数，把<code>[va, va + size)</code>对应的虚拟内存映射到<code>[pa, pa + size)</code>物理内存上。我最开始采用的方法是对内存直接比较，但是会出bug，后来改成按照页面的个数进行映射，这样就不会出现问题（并且<code>va</code>，<code>pa</code>，<code>size</code>都是按照页面大小对齐的）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static'' mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">int</span> pgn = size / PGSIZE;</span><br><span class="line"><span class="keyword">pte_t</span> *ptep;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pgn; i++){</span><br><span class="line">ptep = pgdir_walk(pgdir, (<span class="keyword">void</span> *)va, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!ptep){</span><br><span class="line"><span class="comment">//cprintf("success map\n");</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">*ptep = pa | perm | PTE_P;</span><br><span class="line">va += PGSIZE; </span><br><span class="line">pa += PGSIZE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//cprintf("success map\n");</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-6虚拟空间映射"><a href="#2-6虚拟空间映射" class="headerlink" title="2-6虚拟空间映射"></a>2-6虚拟空间映射</h4><p>下面在<code>mem_init</code>里面，我们映射了三个不同的区域。</p><p>先映射页目录，对于应用程序的内核和用户空间，都是只读的权限，所以是<code>PTE_U</code>（这段代码是给出来的，并不是自己写的）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br></pre></td></tr></tbody></table></figure><p>映射页框数据结构<code>PageInfo</code>，把虚拟地址空间<code>UPAGES</code>映射到<code>pages</code>所在数组的地址空间，这样<code>kernel</code>可以通过内核空间对它可以修改。但是用户却不可以通过用户进行修改，只能读！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UPAGES, PTSIZE, (<span class="keyword">physaddr_t</span>)PADDR(pages), PTE_U | PTE_P);</span><br></pre></td></tr></tbody></table></figure><p>下面是映射内核栈，让<code>KSTACKTOP-KSTKSIZE</code>以下的地区不被映射，这样如果栈区越界就会报错，所以如下面的代码。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br></pre></td></tr></tbody></table></figure><p>最后映射<code>KERNBASE</code>之后的所有虚拟空间！，映射到物理内存最低位</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W | PTE_P);</span><br></pre></td></tr></tbody></table></figure><h2 id="三-下面回答几个问题："><a href="#三-下面回答几个问题：" class="headerlink" title="三.下面回答几个问题："></a>三.下面回答几个问题：</h2><p>1.<strong>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code>?</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x<span class="comment">;</span></span><br><span class="line">char* value = return_a_pointer()<span class="comment">;</span></span><br><span class="line">*value = <span class="number">10</span><span class="comment">;</span></span><br><span class="line"><span class="attribute">x</span> = (mystery_t) value<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><p>答：</p><p>2.填下面的表：</p><table><thead><tr><th>Entry</th><th>Base Virtual Address</th><th>Points to (logically):</th></tr></thead><tbody><tr><td>1023</td><td>0xffc00000</td><td>Page Table for [252MB,256MB) of phys memory</td></tr><tr><td>1022</td><td>0xff800000</td><td>Page Table for [248MB,252MB) of phys memory</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>960</td><td>0xf0000000</td><td>Page Table for [0MB,4MB) of phys memory</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>2</td><td>0x00800000</td><td>Page Table for [8MB,12MB) of phys memory</td></tr><tr><td>1</td><td>0x00400000</td><td>Page Table for [4MB,8MB) of phys memory</td></tr><tr><td>0</td><td>0x00000000</td><td>Page Table for [0MB,4MB) of phys memory</td></tr></tbody></table><p>3.<strong>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</strong></p><p>答：由于页表可以设置权限（参见附录），如果<code>PTE_U</code>位为0的话，用户就无法读写内核代码</p><p>4.<strong>What is the maximum amount of physical memory that this operating system can support? Why?</strong></p><p>我们从<code>memorylayout.h</code>可以看见，<code>pages</code>数组最大有<code>PTSIZE byte</code>的大小，也就是<code>1024 * 4096 byte</code>，那么一个<code>struct PageInfo</code>结构占用了<code>(32+16)= 48bit</code>，一共<code>8byte</code>，那么可以有512K个<code>struct PageInfo</code>元素（一个元素对应页面），每个页面占用<code>4KB</code>，所以一共是<code>512K * 4KB = 2GB</code>的大小！</p><p>5.<strong>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</strong></p><p>我们的额外负载有<code>pages</code>数组，还有页目录，页表</p><p>当达到最大的物理内存的话，所有的页目录页表和<code>pages</code>数组都在工作。</p><p>页目录占用空间<code>4KB</code>，页表占用<code>1024*4KB=4096KB</code>，<code>pages</code>占用<code>4KB*1024=4MB</code>，加起来大约<code>8MB</code></p><p><img src="/picture/szo.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> {</span></span><br><span class="line"><span class="comment">// Next page on the free list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line"><span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line"><span class="comment">// Pages allocated at boot time using pmap.c's</span></span><br><span class="line"><span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> pp_ref;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>6.<strong>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</strong></p><p>答：上面的回顾里面已经解释过了，<code>jmp</code>指令完成了到高地址的跳转。</p><h2 id="三-附录"><a href="#三-附录" class="headerlink" title="三.附录"></a>三.附录</h2><h3 id="1-页目录项和页表项"><a href="#1-页目录项和页表项" class="headerlink" title="1.页目录项和页表项"></a>1.页目录项和页表项</h3><p><img src="/picture/pdepte.png"></p><p>上图就是页目录项和页表项的格式。可以看出，由于页表或者页的物理地址都是4KB对齐的（低12位全是零），所以上图中只保留了物理基地址的高20位（bit[31:12]）。低12位可以安排其他用途。</p><p>【P】：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。<br>【R/W】：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。<br>【U/S】：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。<br>【PWT】：Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉），此标志被忽略。对于我们的实验，此位清零。<br>【PCD】：Page级的Cache Disable标志位。为1时，物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时，此标志被忽略。对于我们的实验，此位清零。<br>【A】：访问位。该位由处理器固件设置，用来指示此表项所指向的页是否已被访问（读或写），一旦置位，处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率。<br>【D】：脏位。该位由处理器固件设置，用来指示此表项所指向的页是否写过数据。<br>【PS】：Page Size位。为0时，页的大小是4KB；为1时，页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled).<br>【G】：全局位。如果页是全局的，那么它将在高速缓存中一直保存。当CR4.PGE=1时，可以设置此位为1，指示Page是全局Page，在CR3被更新时，TLB内的全局Page不会被刷新。<br>【AVL】：被处理器忽略，软件可以使用。</p><h2 id="四-reference"><a href="#四-reference" class="headerlink" title="四.reference"></a>四.reference</h2><p>1.<a href="https://www.jianshu.com/p/3be92c8228b6">6.828 操作系统 lab2 实验报告 - 简书 (jianshu.com)</a></p><p>2.<a href="https://www.cnblogs.com/nullecho/p/10266467.html">页目录项和页表项 - 山城炮灰 - 博客园 (cnblogs.com)</a></p><p>3.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828操作系统笔记Lab1</title>
      <link href="/2021/07/12/MIT6-828-note-lab1/"/>
      <url>/2021/07/12/MIT6-828-note-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="一-起因"><a href="#一-起因" class="headerlink" title="一.起因"></a>一.起因</h2><p>本学期上完了操作系统课程，感觉OS真的是一门很高级的学问，涉及了计算机最底层的东西，私以为要盖好上层建筑，就必须把基本功打好，这是内功。在学长的推荐下，我决定做一下6.828的实验！在经过一学期的英文文档阅读之后，看见英文的东西已经不打怵了，说不上进步多大，但肯定是有进步的！</p><p>下面附上课程网站：<code>[6.828 / Fall 2018 (mit.edu)](https://pdos.csail.mit.edu/6.828/2018/schedule.html)</code></p><h2 id="二-Lab1"><a href="#二-Lab1" class="headerlink" title="二.Lab1"></a>二.Lab1</h2><figure class="highlight mercury"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- <span class="number">0</span>xFFFFFFFF (<span class="number">4</span>GB)</span><br><span class="line">|      <span class="number">32</span>-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line"><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span></span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x00100000 (<span class="number">1</span>MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x000F0000 (<span class="number">960</span>KB)</span><br><span class="line">|  <span class="number">16</span>-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x000C0000 (<span class="number">768</span>KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x000A0000 (<span class="number">640</span>KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x00000000</span><br></pre></td></tr></tbody></table></figure><h3 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1.BIOS"></a>1.BIOS</h3><h4 id="1-1-BIOS的基本功能"><a href="#1-1-BIOS的基本功能" class="headerlink" title="1-1 BIOS的基本功能"></a>1-1 BIOS的基本功能</h4><p>在我们给计算机加电之后，CPU第一个执行的指令就是BIOS的指令，从GDB里面我们可以看出，就是下面这一行，这时<code>CS=0xf000</code>并且<code>IP=0xfff0</code>，所以现在这个指令在地址<code>0xffff0</code>处。我们可以看出来，在实地址模式下，几乎已经达到了寻址空间的尽头，后面为数不多的空间不够存放几条指令了。实际上，真正的<code>BIOS</code>的真正代码在更低地址处。所以我们需要通过下面的指令跳转到相应位置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></tbody></table></figure><p><code>ljmp</code>的意思是长跳转，，也就是说跳转到<code>0xfe05b</code>地址处，可以看出，确实是在第一条指令的前面！</p><p>后面<code>BIOS</code>完成自己后续任务，包括设置中断描述符表和初始化各种设备，比如<code>VGA</code>。在做完这些工作之后，<code>BIOS</code>寻找可引导的设备，当它发现可引导的磁盘时，<code>BIOS</code>从磁盘读出<code>bootloader</code>然后把控制权交给它！</p><p>我总结了一下：<code>BIOS</code>起到一个最原始的引导的作用，主要功能是检查硬件，加载bootloader，然后把控制权交给<code>bootloader</code>。而对于设置中断描述符表之类的事情，其实并不是<code>BIOS</code>必须要做的事情，算是拓展功能。而且因为跟硬件的初始化相关，所以BIOS是硬件厂商来制定比较好，也就是说，如果足够精简的BIOS甚至可以把所有的任务都交给bootloader。BIOS相对于用户来说是透明的，而bootloader才是真正操作系统的一部分。而BIOS的具体内容是什么，其实并不在操作系统的范围内。（其实<code>bootloader</code>也不算）。</p><h4 id="1-2-知识补充"><a href="#1-2-知识补充" class="headerlink" title="1-2 知识补充"></a>1-2 知识补充</h4><h5 id="1-2-1-地址卷绕"><a href="#1-2-1-地址卷绕" class="headerlink" title="1-2-1 地址卷绕"></a>1-2-1 地址卷绕</h5><p>用两个 16 位的寄存器左移相加来得到 20 位的内存地址这里还是有问题。那就是两个 16 位数相加所得的最大结果是超过 20 位的。例如段基址 0xffff 左移变成 0xffff0 和偏移量 0xffff 相加得到 0x10ffef 这个内存地址是“溢出”的，怎么办？这里 CPU 被设计出来一个“卷绕”机制，当内存地址超过 20 位则绕回来。举个例子你拿 0x100001 来寻址，我就拿你当作 0x00001 。你超出终点我就把你绕回起点。</p><h5 id="1-2-2-A20总线"><a href="#1-2-2-A20总线" class="headerlink" title="1-2-2 A20总线"></a>1-2-2 A20总线</h5><p>现代的 x86 计算机，无论你是 32 位的还是 64 位的，在开机的那一刻 CPU 都是以模拟 16 位模式运行的，地址卷绕机制也是有效的，所以无论你的电脑内存有多大，开机的时候 CPU 的寻址能力只有 1MB，就好像回到 8086 时代一样。那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。</p><h3 id="2-BootLoader"><a href="#2-BootLoader" class="headerlink" title="2.BootLoader"></a>2.BootLoader</h3><p><code>BootLoader</code>完成以下的几种任务：</p><ol><li><code>BootLoader</code>先把CPU从实地址模式转换成32位的保护模式，因为只有运行在保护模式的软件才可以访问超过<code>1MB</code>的地址空间！</li><li>下一步，它把操作系统内核读入内存中，最后把控制权交给内核！</li></ol><p>通过查看反汇编的<code>obj/boot/boot.asm</code>，我们可以看出，<code>bootloader</code>的第一行代码被<code>BIOS</code>存放在地址为<code>0x7c00</code>的位置，通过<code>jmp</code>指令设置<code>CS:IP</code>为<code>0000:7c00</code>，把控制权交给它</p><h4 id="2-1-boot-S分析"><a href="#2-1-boot-S分析" class="headerlink" title="2-1 boot.S分析"></a>2-1 <code>boot.S</code>分析</h4><p>下面进入bootloader的实体了，它做了如下工作：</p><ol><li><p>关闭中断，CPU不再响应中断，它的作用是保证引导程序能够顺利地执行。然后清除eflags里面的DF，作用是在字串操作中让变址寄存器SI和DI的地址指针自动增加，字符串处理从前向后</p></li><li><p>下一步初始化重要的段寄存器，比如ds，es，ss，异或操作让他们全部为0</p></li><li><p>然后开启A20地址线。为了后向兼容早期的PC机，20号物理地址线绑定在低地址，所以高于1MB的地址默认是0，这个作用就是撤销这个，开启所有地址线</p><ul><li>其中seta20.1的作用是在64号端口写入0xd1，说明我要向键盘控制器的P2端口写数据了。</li><li>写数据的方法是把数据通过键盘控制器的60号端口写进去，写入的数据是0xdf，这样打开了A20 gate</li></ul></li><li><p>下面要做的是从实地址模式到保护模式的转换</p><ul><li>首先准备gdt（全局描述符表），上面是带有宏的代码，翻译出来就是底下的代码</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#翻译之前</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff) # data seg</span><br><span class="line"></span><br><span class="line">#翻译出来之后  </span><br><span class="line">gdt:</span><br><span class="line">  .word 0, 0;</span><br><span class="line">  .byte 0, 0, 0, 0                             # 空</span><br><span class="line">  .word 0xffff, 0x0000;</span><br><span class="line">  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段</span><br><span class="line">  .word 0xffff, 0x0000;</span><br><span class="line">  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段</span><br></pre></td></tr></tbody></table></figure><p>我们可以看出来DB=1表示的是地址和操作数是32位，G等于1表示20位的段limit的粒度是4KB，最大长度是4GB，所以根据上面的代码来看，limit都是0xfffff，说明32位寻址，段长度是0xfffff=2^20，根据粒度等于4KB，所以段界限为4GB，也就是全部地址空间！</p><p>E为1是代码段，为0是数据段，这样即使RW位都相同，但是因为E不同，代码段是只可读，而数据段是可读写</p><ul><li>下面正式进入保护模式，下面这段代码正好对应了<code>gdtr</code>的48位，高32位是gdt的首地址，而低16位是gdt的长度！（长度可以看出来有多少个全局描述符表项）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdtdesc:</span><br><span class="line">  .word   (gdtdesc - gdt - 1)             # 16 位的 gdt 大小sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # 32 位的 gdt 所在物理地址</span><br></pre></td></tr></tbody></table></figure><p>其中<code>lgdt</code>指令把<code>gdtdesc</code>的值加载到<code>gdtr</code>里面！</p><ul><li><p>下面一步是打开保护模式的“开关”，x86的控制寄存器有<code>CR0</code>,<code>CR1</code>,<code>CR2</code>,<code>CR3</code>这四个，保护模式的开关再<code>CR0</code>上面</p><p>下面这个代码的意思是把CR0的PE位设置为1，开启保护模式！</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></tbody></table></figure></li><li><p>开启保护模式之后，使用长跳转语句，跳转到内核的数据段，这时候寻址方式变成“段基址+段内偏移量”，此时基址寄存器里面的内容是gdt的索引，经过CPU的MMU翻译之后，跳转到相应位置。其中有一些需要解释的地方：为什么<code>PROT_MODE_DSEG</code>的值是0x10呢，因为段基址的高13位代表GDT的下标，所以这样表示下标为2，刚好是内核数据段的下标！查找GDT表之后，我们知道基地址为0，所以后面的段内偏移量就是<code>$protcseg</code>，直接跳转到32位的<code>protcseg</code>函数部分</p></li><li><p>最后设置各个段寄存器，设置栈指针为0x7c00，然后调用<code>bootmain</code>！</p></li></ol><h4 id="2-2-bootmain-c分析"><a href="#2-2-bootmain-c分析" class="headerlink" title="2-2 bootmain.c分析"></a>2-2 <code>bootmain.c</code>分析</h4><p>我们进入<code>bootmain.c</code>的时候，通过反汇编的代码我们可以看出<code>ph</code>被存入了<code>ebx</code>寄存器中，而<code>eph</code>存入了<code>esi</code>寄存器里。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   7d3a:a1 1c 00 01 00       mov    0x1001c,%eax</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   7d3f:0f b7 35 2c 00 01 00 movzwl 0x1002c,%esi</span><br><span class="line">ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   7d46:8d 98 00 00 01 00    lea    0x10000(%eax),%ebx</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   7d4c:c1 e6 05             shl    $0x5,%esi</span><br><span class="line">   7d4f:01 de                add    %ebx,%esi</span><br></pre></td></tr></tbody></table></figure><p>首先分析等待磁盘操作<code>waitdisk</code>，下面的操作就是去读<code>0x1fc</code>端口的<code>bit6</code>和<code>bit7</code>，当<code>bit6=1</code>并且<code>bit7=0</code>的时候，就代表磁盘空闲。其中<code>bit6</code>等于1表示驱动器就绪，<code>bit7</code>空闲表示控制器空闲！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// wait for disk reaady</span></span><br><span class="line"><span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line"><span class="comment">/* do nothing */</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后说一下<code>readseg</code>函数，先等待磁盘空闲，就可以读磁盘了。为什么要把offset写入这些端口呢？</p><p>IDE定义了8个寄存器操作硬盘。PC 体系结构将第一个硬盘控制器映射到端口 1F0-1F7 处，而第二个硬盘控制器则被映射到端口 170-177 处。out函数主要是是把扇区计数、扇区LBA地址等信息输出到端口1F2-1F6，然后将0x20命令写到1F7，表示要进行读扇区的操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// wait for disk to be ready</span></span><br><span class="line">waitdisk();</span><br><span class="line"></span><br><span class="line">outb(<span class="number">0x1F2</span>, <span class="number">1</span>);<span class="comment">// count = 1</span></span><br><span class="line">outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);<span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for disk to be ready</span></span><br><span class="line">waitdisk();</span><br><span class="line"></span><br><span class="line"><span class="comment">// read a sector</span></span><br><span class="line">insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>但是有一个问题，上面的代码里有一个<code>insl</code>函数，这个是什么呢？</p><p>看它的实现是一个内联汇编</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">insl</span><span class="params">(<span class="keyword">uint32_t</span> port, <span class="keyword">void</span> *addr, <span class="keyword">int</span> cnt)</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="string">"cld;"</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="string">"repne; insl;"</span></span></span></span><br><span class="line"><span class="params"><span class="function">            : <span class="string">"=D"</span> (addr), <span class="string">"=c"</span> (cnt)</span></span></span><br><span class="line"><span class="params"><span class="function">            : <span class="string">"d"</span> (port), <span class="string">"0"</span> (addr), <span class="string">"1"</span> (cnt)</span></span></span><br><span class="line"><span class="params"><span class="function">            : <span class="string">"memory"</span>, <span class="string">"cc"</span>)</span></span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>我去<code>StackOverflow</code>搜到了相应的解释：</p><blockquote><p>That function will read <code>cnt</code> <code>dwords</code> from the input port specified by <code>port</code> into the supplied output array <code>addr</code>.</p></blockquote><p>大概意思就是说，从<code>port</code>端口里面读出<code>cnt</code>个<code>dword</code>（4字节），读入到特定的内存地址上去。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read a sector</span></span><br><span class="line">insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure><p>可以看出来，因为一个<code>dword</code>是4字节，所以后面的<code>cnt</code>就是<code>SECTSIZE/4</code></p><p>跟踪<code>for</code>循环语句，我们从<code>asm</code>代码可以看出，下面这段代码是跟循环有关，首先用<code>cmp</code>指令比较<code>ph</code>和<code>eph</code>的大小，如果<code>ph</code>大于等于<code>eph</code>的话，就跳出循环，跳到入口函数。否则继续执行，给<code>readseg</code>的参数入栈，中间会进行一些<code>ph</code>自增的操作，最后跳回比较操作！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (; ph &lt; eph; ph++)</span><br><span class="line">   7d51:39 f3                cmp    %esi,%ebx</span><br><span class="line">   7d53:73 16                jae    7d6b &lt;bootmain+0x56&gt;</span><br><span class="line">readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   7d55:ff 73 04             pushl  0x4(%ebx)</span><br><span class="line">   7d58:ff 73 14             pushl  0x14(%ebx)</span><br><span class="line">for (; ph &lt; eph; ph++)</span><br><span class="line">   7d5b:83 c3 20             add    $0x20,%ebx</span><br><span class="line">readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   7d5e:ff 73 ec             pushl  -0x14(%ebx)</span><br><span class="line">   7d61:e8 76 ff ff ff       call   7cdc &lt;readseg&gt;</span><br><span class="line">for (; ph &lt; eph; ph++)</span><br><span class="line">   7d66:83 c4 0c             add    $0xc,%esp</span><br><span class="line">   7d69:eb e6                jmp    7d51 &lt;bootmain+0x3c&gt;</span><br><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">   7d6b:ff 15 18 00 01 00    call   *0x10018</span><br></pre></td></tr></tbody></table></figure><p>具体的源代码就不放出来了，有兴趣请去网上找资源</p><h4 id="2-3-回答问题"><a href="#2-3-回答问题" class="headerlink" title="2-3 回答问题"></a>2-3 回答问题</h4><p>回答下列问题：</p><ol><li><p>问：处理器在哪一个点开始执行32位的代码？实际上是什么造成了16位到32位的转换？</p><p>回答：处理器从<code>boot.S</code>的<code>.code32</code>伪指令开始执行32位代码，在这之前处理器还处于16位的实模式，而打开了cr0的PE位之后，开启了保护模式，从16位变成32位</p></li><li><p>问：bootloader执行的最后一个指令是什么？kernel第一个被加载的指令是什么？</p><p>下面是<code>bootloader</code>的最后一条指令，对应的c语言代码就是跳转到<code>Kernel</code>的入口处！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">7d6b:ff 15 18 00 01 00    call   *0x10018</span><br></pre></td></tr></tbody></table></figure><p>而下面这段是<code>kernel</code>的第一条指令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x10000c:movw   $0x1234,0x472   </span><br></pre></td></tr></tbody></table></figure></li><li><p>问：内核的第一条指令地址在哪里？</p><p>回答：根据GDB调试，地址在<code>0x10000c</code>处</p></li><li><p><code>bootloader</code>如何知道它要从磁盘里读多少扇区？从哪里找到这些信息的？</p><p>回答：可以从<code>bootmain.c</code>的源代码看出，它的所有信息都是从ELF头里面读出来的！首先找到程序头表的位置，然后找到程序头表里有多少条目。根据程序头表条目给出的信息，把kernel的相应内容从磁盘读入内存！</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line"><span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line"><span class="comment">// as the physical address)</span></span><br><span class="line">readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></tbody></table></figure><h4 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h4><p>问：修改链接地址并且观察<code>bootloader</code>的运行情况</p><p>答：我先把链接地址从<code>0x7c00</code>改成了<code>0x8c00</code>，然后用<code>gdb</code>来看看发生了什么问题。我在上述这两个地址处都设置了断点，然后按c继续运行，这时我可以看见，仍然在<code>0x7c00</code>处执行第一条指令<code>cli</code>，这让我很疑惑。但是在查阅相关资料之后，发现这是<code>BIOS</code>在捣鬼，实际上不管链接地址是加载到哪里的，<code>BIOS</code>是固定会把<code>bootloader</code>加载到<code>0x7c00</code>的位置，这样也就不难解释为什么还是从<code>0x7c00</code>开始执行代码了。但是我再一次按c继续执行，发现了报错！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:ljmp   $0x8,$0x8c32</span><br></pre></td></tr></tbody></table></figure><p>也就是说，在<code>ljmp $PROT_MODE_CSEG, $protcseg</code>这句汇编语句出现了错误，这是因为，链接器在链接的时候是根据<code>protcseg</code>相对于第一条指令的相对地址来确定链接地址的，所以确定地址为<code>0x8c32</code>，而实际上加载到的真实地址还是<code>0x7c32</code>！（其实包括前面的<code>lgdt</code>也出错了！）</p><h4 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h4><p>问：查看<code>bootloader</code>把内核加载前后<code>kernel</code>入口处的内存地址，看看为什么有这样的不同</p><p>回答：从下面这段<code>gdb</code>调试的代码可以看出，在<code>bootloader</code>加载<code>kernel</code>之前，这段内存都是0，在加载之后，内存中有了相应的内容，我对比<code>kernel.asm</code>看一看，它们刚好对应</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0:ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb) b *0x7d6b</span><br><span class="line">Breakpoint 1 at 0x7d6b</span><br><span class="line">(gdb) x/10x 0x10000c</span><br><span class="line">0x10000c:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x10001c:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x10002c:0x000000000x00000000</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x7d6b:call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007d6b in ?? ()</span><br><span class="line">(gdb) x/10x 0x10000c</span><br><span class="line">0x10000c:0x7205c7660x340000040x2000b8120x220f0011</span><br><span class="line">0x10001c:0xc0200fd80x0100010d0xc0220f800x10002fb8</span><br><span class="line">0x10002c:0xbde0fff00x00000000</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure><h3 id="3-Kernel"><a href="#3-Kernel" class="headerlink" title="3.Kernel"></a>3.Kernel</h3><p>下面开始分析<code>Kernel</code>了。</p><h4 id="3-1有关分页"><a href="#3-1有关分页" class="headerlink" title="3-1有关分页"></a>3-1有关分页</h4><h5 id="练习七"><a href="#练习七" class="headerlink" title="练习七"></a>练习七</h5><p>要求首先看看关于地址映射的问题，我先在<code>mov %eax, %cr0</code>所在位置设置了断点，运行到这里。然后检查了两段地址的内存，刚开始是不一样，然后执行完这句指令，发现两块内存是一样的了！这很神奇！这是因为在开启PE位之后，开启了虚拟内存模式，把虚拟内存空间高地址的内存映射到对应的物理内存上，所以他们的内容是一样的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x100025</span><br><span class="line">Breakpoint 2 at 0x100025</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x100025:mov    %eax,%cr0</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00100025 in ?? ()</span><br><span class="line">(gdb) x/8x 0x100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/8x 0x100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果开启PE失败的话，那么下面两句就会出现问题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov$relocated, %eax</span><br><span class="line">f0100028:b8 2f 00 10 f0       mov    $0xf010002f,%eax</span><br><span class="line">jmp*%eax</span><br><span class="line">f010002d:ff e0                jmp    *%eax</span><br></pre></td></tr></tbody></table></figure><p>其实我们在阅读源代码的时候会注意到注释上给了一点问题</p><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Now paging is enabled, but we're still running at a low EIP</span><br><span class="line"># (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="line"># C code.</span><br></pre></td></tr></tbody></table></figure></blockquote><p>问的是为什么开启分页之后，用原来的<code>EIP</code>还能继续运行，我们需要注意，<strong>我们是将两个范围的虚拟地址映射到物理地址上，而不仅仅是高地址！</strong>这也是这么做的目的！</p><p>既然提到了有关分页的操作，我们不得不分析一下代码了</p><ol><li>在开启分页之前，我们要把页目录的地址存入<code>cr3</code>，注意：我们要加载的是页目录表的<strong>物理地址</strong>，这是因为到时候直接从<code>cr3</code>中取出地址来寻找页目录表，不经过地址转换，所以不能是虚拟地址！（虚拟地址转换需要借助<code>cr3</code>，不能够因果倒置！）</li><li>然后把<code>cr0</code>的<code>PG</code>位打开</li><li>然后跳转到高地址！（变成<code>high EIP</code>）</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">movl$(RELOC(entry_pgdir)), %eax</span><br><span class="line">movl%eax, %cr3</span><br><span class="line"># Turn on paging.</span><br><span class="line">movl%cr0, %eax</span><br><span class="line">orl$(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">movl%eax, %cr0</span><br><span class="line"></span><br><span class="line"># Now paging is enabled, but we're still running at a low EIP</span><br><span class="line"># (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="line"># C code.</span><br><span class="line">mov$relocated, %eax</span><br><span class="line">jmp*%eax</span><br></pre></td></tr></tbody></table></figure><p>那么，我们就知道了如果没有映射成功的话，打开<code>cr0</code>的<code>PG</code>位之后的下两条指令就会出错，因为<code>relocated</code>是高地址，如果没有映射的话，跳转到那里就会报错！</p><p>我们来测试一下，注释掉设置<code>cr0</code>的操作，可见那个地址的内存全是0，系统崩溃掉了！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x100025</span><br><span class="line">Breakpoint 1 at 0x100025</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x100025:mov    $0xf010002c,%eax</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00100025 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10002a:jmp    *%eax</span><br><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf010002c &lt;relocated&gt;:add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74movl$0x0,%ebp# nuke frame pointer</span><br><span class="line">(gdb) </span><br><span class="line">Remote connection closed</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>还有关于<code>entry_pgdir</code>这个东西的一些讨论，我们可以从<code>entrypgdir.c</code>里面看出来，<code>Jos</code>利用的是二级页表操作，也就是说，把逻辑地址分为页目录10位，页表号10位，页内偏移量12位这三个部分，而我们只需要映射两个部分的虚拟内存！所以页目录设置为下面这样！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="keyword">pde_t</span> entry_pgdir[NPDENTRIES] = {</span><br><span class="line"><span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB)</span></span><br><span class="line">[<span class="number">0</span>]</span><br><span class="line">= ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line"><span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></span><br><span class="line">[KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">= ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>页表在下面这样的格式。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="keyword">pte_t</span> entry_pgtable[NPTENTRIES] = {</span><br><span class="line"><span class="number">0x000000</span> | PTE_P | PTE_W,</span><br><span class="line"><span class="number">0x001000</span> | PTE_P | PTE_W,</span><br><span class="line"><span class="number">0x002000</span> | PTE_P | PTE_W,</span><br><span class="line"> ......   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2有关格式化输出"><a href="#3-2有关格式化输出" class="headerlink" title="3-2有关格式化输出"></a>3-2有关格式化输出</h4><p>我们在进行下几步之前，先阅读一下源代码。</p><p>在阅读过程中有几个宏让我感到很疑惑，就是下面这几个，经过查阅引用[5]我得知这几个宏跟格式化输出函数的可变参数有关！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap, last) __builtin_va_start(ap, last)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap, type) __builtin_va_arg(ap, type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(ap) __builtin_va_end(ap)</span></span><br></pre></td></tr></tbody></table></figure><p>我们需要修改的一个地方就是打印8进制数字，理解了代码之后不难写出这个</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (unsigned) octal</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">num = getuint(&amp;ap,lflag);</span><br><span class="line">base = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">goto</span> number;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><p>下面回答几个问题：</p><ol><li><p>问：Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</p><p>答：<code>printf.c</code>里面的<code>putch</code>调用了<code>console.c</code>里面的<code>cputchar</code>函数，同时<code>vcprintf</code>调用了<code>putch</code>函数，<code>cprintf</code>调用了<code>vcprintf</code>函数</p><p>总结下来调用关系就是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cprintf-&gt;vcprintf-----&gt;putch-&gt;cputchar(consule.c)</span><br><span class="line">      |</span><br><span class="line">      +--&gt;vprintfmt(ptintfmt.c)</span><br></pre></td></tr></tbody></table></figure></li><li><p>问：explain the following from <code>console.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) {</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line"><span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">crt_pos -= CRT_COLS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>答：这段代码的目的是：当屏幕已经装满了字符，再次输入的时候，让屏幕向上回滚一行，也就是说把内存里面的内容向前移动80个字符的大小，然后最后一行用黑色填满</p></li><li><p>```c<br>int x = 1, y = 3, z = 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   问1：上面这段代码里，<span class="code">`fmt`</span>指代什么？<span class="code">`ap`</span>指代什么？</span><br><span class="line"></span><br><span class="line">   答：<span class="code">`fmt`</span>是字符串<span class="code">`"x %d, y %x, z %d\n"`</span>的首地址，根据上面的解释<span class="code">`ap`</span>是后面参数的首地址</span><br><span class="line"></span><br><span class="line">   问2：列出调用过程</span><br><span class="line"></span><br><span class="line">   答：</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">`cprintf`</span>首先调用<span class="code">`vcprintf`</span>，参数<span class="code">`fmt`</span>的值为格式化字符串的地址，参数<span class="code">`ap`</span>指向变量<span class="code">`x`</span>的地址。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`vcprintf`</span>调用<span class="code">`vprintfmt`</span>，<span class="code">`vprintfmt`</span>函数中多次调用<span class="code">`va_arg`</span>和<span class="code">`putch`</span>，<span class="code">`putch`</span>调用<span class="code">`cputchar`</span>，而<span class="code">`cputchar`</span>调用<span class="code">`cons_putc`</span>，<span class="code">`putch`</span>的字符参数传给<span class="code">`cons_putc`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`'x'`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符空格</span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`va_arg`</span>，<span class="code">`lflag=0`</span>，调用前<span class="code">`ap`</span>指向<span class="code">`x`</span>，调用后<span class="code">`ap`</span>指向<span class="code">`y`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数是字符<span class="code">`'1'`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`','`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符空格</span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`'y'`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符空格</span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`va_arg`</span>，<span class="code">`lflag=0`</span>，调用前<span class="code">`ap`</span>指向<span class="code">`y`</span>，调用后<span class="code">`ap`</span>指向<span class="code">`z`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`'3'`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`','`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符空格</span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`'z'`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符空格</span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`va_arg`</span>，<span class="code">`lflag=0`</span>，调用前<span class="code">`ap`</span>指向<span class="code">`z`</span>，调用后<span class="code">`ap`</span>指向<span class="code">`z`</span>后面一块内存</span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`'4'`</span></span><br><span class="line"><span class="bullet">   -</span> 调用<span class="code">`cons_putc`</span>，参数为字符<span class="code">`'\n'`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 运行下面程序，看看运行结果</span><br><span class="line"></span><br><span class="line">   <span class="code">```c</span></span><br><span class="line"><span class="code">       unsigned int i = 0x00646c72;</span></span><br><span class="line"><span class="code">       cprintf("H%x Wo%s", 57616, &amp;i);</span></span><br><span class="line"><span class="code">   //结果：</span></span><br><span class="line"><span class="code">   //He110 World</span></span><br></pre></td></tr></tbody></table></figure><p>原因如下：10进制57616的16进制表示是E110，而<code>i</code>所在内存将被解读成一个字符串，根据小端法，依次输出0x72，0x6c，0x64表示<code>ASCII</code>码所表示的字符，分别是r，l，d这三个字符！</p><p>综上，我们得到输出结果<code>He110 World</code></p></li><li><p>执行下面代码会把y输出成什么呢？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">"x=%d y=%d"</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><p>实际上输出参数3后面的内存地址所指向的4字节值（按照小端法读取）</p><p>经过测试，实际上输出的是整数1600，具体的过程如何呢？</p><p>在下面这段代码里面，我们发现在把3入栈之前，先把<code>esp</code>加8，那么我们可以知道，y所输出的值就是<code>esp</code>加8之后的所指向的内存，继续往回看，在调用<code>test_backtrace(5)</code>的时候，并没有把5压栈，而是直接把<code>esp</code>所指向的内存的值改成了5，所以我们需要继续向上找。可以看出<code>cprintf</code>有两个参数，所以<code>esp</code>加8应该跳到这两个参数之上的那个参数，我们发现在<code>0xf01000d4</code>这里还有一个给<code>esp</code>加8的操作，所以再回溯两个<code>push</code>操作，我们注意到这一行<code>f01000c6:    50                       push   %eax</code>，没错，这个<code>eax</code>就是显示出来的y的值！根据上面的<code>sub</code>指令，我们算出来<code>eax</code>的值就是十进制的1600！！！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">f01000b8:c7 c2 <span class="number">60</span> <span class="number">30</span> <span class="number">11</span> f0    mov    $<span class="number">0xf0113060</span>,%edx</span><br><span class="line">f01000be:c7 c0 a0 <span class="number">36</span> <span class="number">11</span> f0    mov    $<span class="number">0xf01136a0</span>,%eax</span><br><span class="line">f01000c4:<span class="number">29</span> d0                sub    %edx,%eax</span><br><span class="line">f01000c6:<span class="number">50</span>                   push   %eax</span><br><span class="line">f01000c7:<span class="number">6</span>a <span class="number">00</span>                push   $<span class="number">0x0</span></span><br><span class="line">f01000c9:<span class="number">52</span>                   push   %edx</span><br><span class="line">f01000ca:e8 <span class="number">20</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span>       call   f01015ef &lt;<span class="built_in">memset</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the console.</span></span><br><span class="line"><span class="comment">// Can't call cprintf until after we do this!</span></span><br><span class="line">cons_init();</span><br><span class="line">f01000cf:e8 <span class="number">4</span>e <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       call   f0100622 &lt;cons_init&gt;</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"6828 decimal is %o octal!\n"</span>, <span class="number">6828</span>);</span><br><span class="line">f01000d4:<span class="number">83</span> c4 <span class="number">08</span>             add    $<span class="number">0x8</span>,%esp</span><br><span class="line">f01000d7:<span class="number">68</span> ac <span class="number">1</span>a <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0x1aac</span></span><br><span class="line">f01000dc:<span class="number">8</span>d <span class="number">83</span> <span class="number">6f</span> <span class="number">07</span> ff ff    lea    <span class="number">-0xf891</span>(%ebx),%eax</span><br><span class="line">f01000e2:<span class="number">50</span>                   push   %eax</span><br><span class="line">f01000e3:e8 <span class="number">72</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span>       call   f0100a5a &lt;cprintf&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test the stack backtrace function (lab 1 only)</span></span><br><span class="line">test_backtrace(<span class="number">5</span>);</span><br><span class="line">f01000e8:c7 <span class="number">04</span> <span class="number">24</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x5</span>,(%esp)</span><br><span class="line">f01000ef:e8 <span class="number">4</span>c ff ff ff       call   f0100040 &lt;test_backtrace&gt;</span><br><span class="line">    <span class="comment">//int x = 1, y = 3, z = 4;</span></span><br><span class="line">    <span class="comment">//cprintf("x %d, y %x, z %d\n", x, y, z);</span></span><br><span class="line"><span class="comment">//unsigned int i = 0x00646c72;</span></span><br><span class="line">    <span class="comment">//cprintf("H%x Wo%s", 57616, &amp;i);</span></span><br><span class="line"><span class="comment">//Sasm("pushl $200");</span></span><br><span class="line">cprintf(<span class="string">"x=%d y=%d\n"</span>, <span class="number">3</span>);</span><br><span class="line">f01000f4:<span class="number">83</span> c4 <span class="number">08</span>             add    $<span class="number">0x8</span>,%esp</span><br><span class="line">f01000f7:<span class="number">6</span>a <span class="number">03</span>                push   $<span class="number">0x3</span></span><br><span class="line">f01000f9:<span class="number">8</span>d <span class="number">83</span> <span class="number">8</span>a <span class="number">07</span> ff ff    lea    <span class="number">-0xf876</span>(%ebx),%eax</span><br><span class="line">f01000ff:<span class="number">50</span>                   push   %eax</span><br><span class="line">f0100100:e8 <span class="number">55</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span>       call   f0100a5a &lt;cprintf&gt;</span><br><span class="line">f0100105:<span class="number">83</span> c4 <span class="number">10</span>             add    $<span class="number">0x10</span>,%esp</span><br></pre></td></tr></tbody></table></figure></li><li><p>问：Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>答：可以在最后push一个整数来表示参数的数目！</p></li></ol><h4 id="3-3有关内核栈"><a href="#3-3有关内核栈" class="headerlink" title="3-3有关内核栈"></a>3-3有关内核栈</h4><h5 id="练习九"><a href="#练习九" class="headerlink" title="练习九"></a>练习九</h5><p>内核是如何初始化栈的？我们结合下面的代码来看，首先把栈顶指针的内容赋值给<code>esp</code>，然后看下面，<code>bootstack</code>给分配了<code>KSTKSIZE</code>的内存空间，也就是8个页的大小。然后栈顶的值是分配的内存空间结束的地址，是高地址！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Set the stack pointer</span><br><span class="line">movl$(bootstacktop),%esp</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">###################################################################</span><br><span class="line"># boot stack</span><br><span class="line">###################################################################</span><br><span class="line">.p2alignPGSHIFT# force page alignment</span><br><span class="line">.globlbootstack</span><br><span class="line">bootstack:</span><br><span class="line">.spaceKSTKSIZE</span><br><span class="line">.globlbootstacktop   </span><br><span class="line">bootstacktop:</span><br></pre></td></tr></tbody></table></figure><h5 id="练习十"><a href="#练习十" class="headerlink" title="练习十"></a>练习十</h5><p>对于<code>testbacktrace</code>，我们从源代码可以看出每次进入这个函数之后进行如下步骤：</p><ol><li>把栈底指针压入栈（然后让<code>ebp</code>变成新的栈底指针）</li><li>把<code>esi</code>和<code>ebx</code>推入栈中，保存寄存器</li><li>然后进行<code>cprintf</code>有关的处理</li><li>把<code>fmt</code>地址入栈</li><li>调用<code>cprintf</code></li><li>把<code>test_backtrace(x-1)</code>的参数压栈</li><li>递归调用</li></ol><p>后面是写代码的题目，懒得写了，先把代码贴上，后期再解释…</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="keyword">uint32_t</span> ebp, old_ebp, eip;</span><br><span class="line"><span class="keyword">uint32_t</span> args[<span class="number">5</span>] = {<span class="number">0</span>};</span><br><span class="line">ebp = read_ebp();</span><br><span class="line"><span class="comment">//ebp = *((uint32_t*)ebp);</span></span><br><span class="line">cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(ebp != <span class="number">0</span>){</span><br><span class="line">old_ebp = *((<span class="keyword">uint32_t</span>*)ebp);</span><br><span class="line">eip = *((<span class="keyword">uint32_t</span>*)(ebp + <span class="number">4</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++){</span><br><span class="line">args[i] = *((<span class="keyword">uint32_t</span>*)(ebp + <span class="number">8</span> + <span class="number">4</span> * i));</span><br><span class="line">}</span><br><span class="line">cprintf(<span class="string">"  ebp %x  eip %x  args %08x %08x %08x %08x %08x\n"</span>, </span><br><span class="line">ebp, eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">debuginfo_eip(eip, &amp;info);</span><br><span class="line"><span class="keyword">char</span> fn_name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(fn_name, info.eip_fn_name, info.eip_fn_namelen);</span><br><span class="line">fn_name[info.eip_fn_namelen]=<span class="string">'\0'</span>;</span><br><span class="line">cprintf(<span class="string">"         %s:%d: %s+%d\n"</span>, </span><br><span class="line">info.eip_file, </span><br><span class="line">info.eip_line, </span><br><span class="line">fn_name,</span><br><span class="line"><span class="comment">//info.eip_fn_name, </span></span><br><span class="line">eip - info.eip_fn_addr);</span><br><span class="line">ebp = old_ebp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="练习十二"><a href="#练习十二" class="headerlink" title="练习十二"></a>练习十二</h5><p>先看一下<code>kern/kernel.ld</code>，可以知道<code>__STAB_BEGIN__</code>和<code>__STAB_END__</code>，<code>__STABSTR_BEGIN__</code>和<code>__STABSTR_END__</code>这四个变量是内存中他们的地址（指针）！</p><p>然后<code>objdump -h</code>查看<code>kernel</code>的节头表，发现有如下内容，所以<code>__STAB_BEGIN__</code>的值应该是<code>0xf01022bc</code>，<code>__STAB_END__</code>的值应该是<code>0xf0106090</code>（另外两个以此类推）</p><p><img src="/picture/6.828-1-1.png" alt="kernel的节头表"></p><p>再<code>kernel</code>被加载好之后，我来查看一下符号表是否也被加载到预期的位置，根据下面这张图来看，确实！</p><p><img src="/picture/6.828-1-2.png" alt="检查stabstr段所在内存"></p><p>下面看一下符号段是什么样的，从下面看出，符号段每个表项包含下面的成员，下面是对各个成员的解释：</p><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Symnum</span> n_<span class="keyword">type</span> n_othr n_desc n_value  n_strx <span class="type">String</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>Symnum</code>是符号索引，换句话说，整个符号表看作一个数组，<code>Symnum</code>是当前符号在数组中的下标</li><li><code>n_type</code>是符号类型，<code>FUN</code>指函数名，<code>SLINE</code>指在<code>text</code>段中的行号</li><li><code>n_othr</code>目前没被使用，其值固定为0</li><li><code>n_desc</code>表示在文件中的行号</li><li><code>n_value</code>表示地址。特别要注意的是，这里只有<code>FUN</code>类型的符号的地址是绝对地址，<code>SLINE</code>符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。</li></ul><p>注意，下面这句两个指针相减得到的是数组的下标！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfile = (stab_end - stabs) - <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>所以二分搜索利用下标对地址进行搜索！</p><p>我们先搜索到相应的源文件，然后对函数进行搜索，所以如下代码用来搜索行号</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr-info-&gt;eip_fn_addr);</span><br><span class="line"><span class="keyword">if</span>(lline &gt; rline){</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三-reference"><a href="#三-reference" class="headerlink" title="三.reference"></a>三.reference</h2><p>1.<a href="https://www.cnblogs.com/wuhualong/p/lab01_exercise02_trace_into_bios.html">《MIT 6.828 Lab 1 Exercise 2》实验报告 - whl1729 - 博客园 (cnblogs.com)</a></p><p>2.<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6 - DRAFT as of September 4, 2018 (mit.edu)</a></p><p>3.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">elf.pdf (mit.edu)</a></p><p>4.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Lanugage (mit.edu)</a></p><p>5.<a href="https://blog.csdn.net/u011728480/article/details/62044567">C 可变参数函数分析(va_start,va_end,va_list…)_Sky的专栏-CSDN博客___builtin_va_start</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记传输层</title>
      <link href="/2021/06/16/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2021/06/16/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-传输层简介transport-layer"><a href="#一-传输层简介transport-layer" class="headerlink" title="一.传输层简介transport layer"></a>一.传输层简介transport layer</h2><h3 id="1-传输层作用"><a href="#1-传输层作用" class="headerlink" title="1.传输层作用"></a>1.传输层作用</h3><ul><li>进程间通信<ul><li>应用进程间的多路复用和解复用</li><li>用端口实现</li></ul></li><li>为应用程序提供端到端的服务<ul><li>可靠的，按序的数据交付</li><li>很好的交付节奏</li></ul></li><li>TCP和UDP是常用的运输层协议<ul><li>还有其他的，就不说了</li></ul></li><li>UDP是极简化的传输层协议<ul><li>只提供复用和分解能力</li></ul></li><li>TCP提供可靠的，按序的，字节流的抽象<ul><li>有拥塞控制，但是没有性能担保</li></ul></li></ul><h3 id="2-应用程序和套接字"><a href="#2-应用程序和套接字" class="headerlink" title="2.应用程序和套接字"></a>2.应用程序和套接字</h3><p>套接字（socket）：给应用进程和操作系统之间交换网络消息的一个软件抽象</p><p>传输层寻址：**&lt;HostIP , Port&gt;**，叫做一个套接字</p><p>两个重要的套接字类型：</p><ul><li>UDP套接字：TYPE是SOCK_DGRAM</li><li>TCP套接字：TYPE是SOCK_STREAM</li></ul><h3 id="3-端口"><a href="#3-端口" class="headerlink" title="3.端口"></a>3.端口</h3><ul><li>帮助区别APP的16比特的数字<ul><li>分组在传输层头带着src和dst端口号</li><li>有常用端口（0-1023）和临时端口</li></ul></li><li>OS存储套接字和端口的映射<ul><li>端口在分组里面，套接字在OS里</li><li>对于UDP端口，OS存储（local port，local IP）来映射套接字</li><li>对于TCP端口，OS存储（local port，local IP，remote port， remote IP）来映射套接字</li></ul></li></ul><h3 id="4-多路复用和多路分解"><a href="#4-多路复用和多路分解" class="headerlink" title="4.多路复用和多路分解"></a>4.多路复用和多路分解</h3><p>在发送方：处理来自多个套接字的数据，添加传输层头。</p><p>在接收方：用header信息来把收到的传输层报文段交付给正确的套接字。</p><h4 id="4-1-如何多路分解"><a href="#4-1-如何多路分解" class="headerlink" title="4-1 如何多路分解"></a>4-1 如何多路分解</h4><p>主机收到IP数据报，里面有源和目的IP，数据报携带传输层报文段，保温段里面有源和目的端口</p><p>主机用IP地址和端口号来把报文段导向正确的套接字</p><p><img src="/picture/format.png"></p><h5 id="4-1-1-无连接的多路分解"><a href="#4-1-1-无连接的多路分解" class="headerlink" title="4-1-1 无连接的多路分解"></a>4-1-1 无连接的多路分解</h5><p>对于UDP协议，当我们收到了目的端口相同，但是源端口或源IP不同的报文段，仍然要引导向同一个目的套接字</p><p>4-1-2基于连接的多路分解</p><p><strong>对于TCP协议，我们确定一个套接字通过一个4元组</strong></p><ul><li>源IP地址</li><li>源端口号</li><li>目的IP地址</li><li>目的端口号</li></ul><p>多路分解：接收方用四元组来导向正确的套接字</p><p>服务器主机或许支持许多同时的TCP套接字：每个套接字通过4元组来确定</p><p>下面是一个例子：</p><p><img src="/picture/socket.png"></p><h2 id="二-传输层设计"><a href="#二-传输层设计" class="headerlink" title="二.传输层设计"></a>二.传输层设计</h2><p>为什么要用传输层？</p><ol><li>IP分组寻址到一个主机，但是端到端的交流是介于进程之间的，需要一种方式（多路复用和分解）来定位到应用进程</li><li>IP提供很弱的服务模型（尽力而为）<ul><li>分组可能错误，延迟，丢包…</li><li>对拥塞情况没有控制</li><li>这些事情还不能让应用程序来处理</li></ul></li></ol><p>尽力而为协议可能做很多很不好的事情，所以我们需要可靠传输</p><p>我们处理这些不好事情需要一些机制：</p><ul><li>检验和：来检测错误</li><li>ACK：接受者告诉发送者收到了包</li><li>NACK：接受者告诉发送者没有收到包</li><li>序号：一种识别分组的方式</li><li>重传</li><li>超时</li><li>发送纠正后的包</li><li>网络编码</li></ul><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p><img src="/picture/sw.png"></p><p>这个协议比较可靠，但是比较低效，浪费带宽。</p><p><img src="/picture/ine.png"></p><p><img src="/picture/ine1.png"></p><h3 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h3><p>流水线：发送方允许多个飞行中的等待“被ACK“的分组。序号的必须增加，在接收方和发送方缓存。</p><p><img src="/picture/uti.png"></p><h4 id="三种设计决策"><a href="#三种设计决策" class="headerlink" title="三种设计决策"></a>三种设计决策</h4><p>哪一个包可以发送根据<strong>滑动窗口</strong></p><p>接收方如何发送ACK？有两种，积累的，选择性的</p><p>发送方需要重传哪些包？Go-Back N（GBN）回退n帧，Selective Repeat(SR)选择重传</p><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>窗口就是一些相邻的序号的集合，集合的大小是窗口大小，假定窗口大小是n</p><p>一次发送n个包：</p><ul><li>发送者可以发送窗口里的包</li><li>接受者可以接受窗口里的包</li><li>当收到ACK，可接受的包的窗口滑动</li></ul><p><img src="/picture/slide.png"></p><h5 id="积累确认"><a href="#积累确认" class="headerlink" title="积累确认"></a>积累确认</h5><p>累计确认永远确认的是还没有收到的序列号最小的那个</p><p><img src="/picture/ca.png"></p><p><img src="/picture/ca1.png"></p><h5 id="选择性确认"><a href="#选择性确认" class="headerlink" title="选择性确认"></a>选择性确认</h5><p>选择确认确认的是收到的包本身的序列！！！</p><p>收到一个正确的包就进行确认，这样需要记录下来哪些已经收到了</p><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>重传包：两种标准的方法：回退n帧GBN和选择重传SR</p><h5 id="回退N帧"><a href="#回退N帧" class="headerlink" title="回退N帧"></a>回退N帧</h5><p>发送方发送最多n个没有被ACK的包</p><p>接收方只按序接收，时序的分组会被丢弃</p><p>接收方用积累确认：ACK的序号等于下一个被期待的正确顺序的序号</p><p>发送方为第一个未完成的ack设置定时器（A+1），如果超时就重传A+1，A+2……</p><h5 id="GBN的滑动窗口"><a href="#GBN的滑动窗口" class="headerlink" title="GBN的滑动窗口"></a>GBN的滑动窗口</h5><p><img src="/picture/gbn.png"></p><p>下面是没有出错的GBN滑动窗口</p><p><img src="/picture/gbn1.png"></p><p>下面是出错的GBN滑动窗口，可以看出4在传输图中丢失了，那么5和6倍接收方丢弃，而4超时没收到ACK之后发送方重传456！！！</p><p><img src="/picture/gbn2.png"></p><h5 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h5><p>发送方发送最多n个没有被ACK的包</p><p>假定分组k丢掉了，<code>K+1</code>没有丢掉</p><ul><li>那么接收方：发送k+1的ACK</li><li>发送方：k超时，只重传k</li></ul><p>高效重传但是记账很复杂，<strong>对于每个包都要一个定时器</strong>！！！</p><p><img src="/picture/sr.png"></p><h5 id="GBN-vs-SR"><a href="#GBN-vs-SR" class="headerlink" title="GBN vs SR"></a>GBN vs SR</h5><p>什么时候GBN更好？错误率低，否则重传多余的包会浪费带宽</p><p>什么时候SR更好？错误率高，否则会搞得很复杂</p><p>对于滑动窗口，只要窗口大小足够大，就可以充分利用链接。</p><p>发送方不得不缓存所有没有被ACK的包，因为可能需要重传</p><p>接收方或许能够接收失序的包，但是不能超过缓存大小！</p><p>实现的复杂度取决于协议的细节！！！</p><h2 id="三-UDP"><a href="#三-UDP" class="headerlink" title="三.UDP"></a>三.UDP</h2><p>UDP是User Datagram Protocol（用户数据报协议）</p><p>TCP是Transmission Control Protocol（传输控制协议）</p><ul><li>进程之间的轻量级交流，避免了额外开销</li><li>目的IP地址和端口来支撑多路分解</li><li>尽力而为服务，UDP报文段或许会丢失，失序交付给app</li><li>无连接的，没有握手，每个UDP报文段都独立被处理</li></ul><p>UDP用：</p><ul><li>流多媒体APP</li><li>DNS</li><li>SNMP</li></ul><p>为什么要有UDP？</p><ol><li>不需要连接建立（没有额外时间开销）</li><li>简单：收发方都没有连接状态</li><li>header比较小</li><li>没有拥塞控制：UDP速度可以爆炸增长</li></ol><h3 id="UDP报文段的格式"><a href="#UDP报文段的格式" class="headerlink" title="UDP报文段的格式"></a>UDP报文段的格式</h3><p><img src="/picture/udp.png"></p><h4 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h4><p>检测传输地报文段的错误</p><p>进行16bit和的反码运算，值得注意的是，在进行16bit加法运算的时候如果有溢出就要进行回卷（把溢出位加到后面！！！），对最后的和进行反码运算</p><p>检验和字段是0意味着没有用检验和</p><h2 id="四-TCP"><a href="#四-TCP" class="headerlink" title="四.TCP"></a>四.TCP</h2><p>TCP交付可靠的，按序的字节流</p><h3 id="TCP头"><a href="#TCP头" class="headerlink" title="TCP头"></a>TCP头</h3><p><img src="/picture/TCP.png"></p><p>用源端口和目的端口来进行多路复用和分解</p><p>checksum用来计算数据和伪头</p><p>序列号是字节偏移量（因为TCP是一个字节流）</p><h3 id="TCP做什么"><a href="#TCP做什么" class="headerlink" title="TCP做什么"></a>TCP做什么</h3><ol><li>检验和</li><li>序号是字节偏移量</li><li>接收方发送积累确认（像GBN）</li><li>接收方缓存时序分组（像SR）</li></ol><h3 id="TCP引入什么"><a href="#TCP引入什么" class="headerlink" title="TCP引入什么"></a>TCP引入什么</h3><p>引入了快速重传机制：冗余的ACK触发早期重传</p><p>发送方维护一个单独的重传计时器，当超时就重传</p><p>那么我们如何确定超时时间是多少呢？</p><p>要跟RTT成一定比例，我们怎么知道RTT呢</p><p>RTT样本的指数加权平均值</p><p><img src="/picture/exp.png"></p><p>我们如何区分真的ACK和重传分组的ACK呢？</p><p><img src="/picture/ACK.png"></p><h4 id="Karn-Partridge算法"><a href="#Karn-Partridge算法" class="headerlink" title="Karn/Partridge算法"></a>Karn/Partridge算法</h4><p>不用来自重传的ACK，一旦重传就忽略后面的ACK报文段</p><p>用α=0.125来计算<code>EstimatedRTT</code></p><p>超时的值设置成<code>EstimatedRTT</code>的2倍</p><p>使用指数回退：当超时就让<code>RTO=2* RTO</code>。每次新的估计值（收到不是重传的ACK）出现，就回退到<code>2*EstimatedRTT</code></p><h4 id="Jacobson-Karels算法"><a href="#Jacobson-Karels算法" class="headerlink" title="Jacobson/Karels算法"></a>Jacobson/Karels算法</h4><p><img src="/picture/JK.png"></p><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><h4 id="双向握手"><a href="#双向握手" class="headerlink" title="双向握手"></a>双向握手</h4><p>A发送SYN，B回复SYN</p><p>如何识别就连接中的报文段</p><p>如何识别冗余过期的SYN</p><h5 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h5><p>用一个和之前连接不同的初始化序列号开始每段新连接</p><p>连接请求的形式为SYN i+1，其中i是将在此连接上发送的第一个数据段的序列号。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/picture/3.png"></p><p><img src="/picture/shake.png"></p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>正常的终止，一次一边</p><p><img src="/picture/fin1.png"></p><p>正常的终止，两边同时</p><p><img src="/picture/fin2.png"></p><p>意外终止</p><p><img src="/picture/fin3.png"></p><p>下面是客户机的生命周期</p><p><img src="/picture/client.png"></p><p>下面是服务器的生命周期</p><p><img src="/picture/server.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记应用层</title>
      <link href="/2021/06/14/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2021/06/14/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-多媒体网络应用"><a href="#一-多媒体网络应用" class="headerlink" title="一.多媒体网络应用"></a>一.多媒体网络应用</h2><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>以恒定速率采样的模拟音频信号</p><ul><li>telephone：8000样本每秒</li><li>CD音乐：44100样本每秒</li></ul><p>每个样本被量化，例如四舍五入(比如2^8=256种可能的量化值)</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>以恒定速率播放的图片序列，比如24张图片每秒</p><p>数字图片：像素的数组，每张图片通过比特来表示</p><p>编码：利用图片之间的冗余（相同的地方）来编码可以节省空间</p><ul><li>空间上的冗余：比如同一排一样的颜色，只需要发送一个颜色和重复的次数即可</li><li>时间上的冗余：相邻两帧只需要发送不一样的地方即可</li></ul><h3 id="三种应用类型"><a href="#三种应用类型" class="headerlink" title="三种应用类型"></a>三种应用类型</h3><h4 id="1-流媒体"><a href="#1-流媒体" class="headerlink" title="1.流媒体"></a>1.流媒体</h4><p>因为整个视频文件太大，所以变成”流“来存储音频和视频，在完全下载下来之前就可以播放。在服务器上面的存储：可以比音频或者视频传输地更快（意味着在客户机缓存）。</p><p>流媒体存储的视频：</p><p><img src="/picture/streaming.png"></p><p>存在一些挑战：</p><ul><li>持续的播放约束，一旦客户播放开始，重放就要匹配得上原来的时间。但是网络延迟是可变的，所以我们需要客户机端的缓冲区来匹配播放需要</li><li>客户机需要交互：暂停，快进，回退…</li><li>视频包可能会丢失</li></ul><p>改进之后：（多了buffer）</p><p><img src="/picture/s.png"></p><h5 id="利用的协议"><a href="#利用的协议" class="headerlink" title="利用的协议"></a>利用的协议</h5><p>UDP</p><p>服务器以一个对于客户合适的速率发送</p><p>要有一个比较短的播放延迟来对抗网络抖动</p><p>UDP可能穿不过防火墙</p><p>HTTP</p><p>通过<code>HTTP GET</code>来获取多媒体文件。在TCP下以一个最小的可能速率发送</p><p><img src="/picture/HTTPTCP.png"></p><p>填充速率波动取决于TCP拥塞控制，重传机制。需要更大的播放延时。HTTP/TCP可以轻松穿过防火墙</p><p>DASH</p><p>Dynamic，Adaptive Streaming over HTTP</p><p>发送方：</p><ul><li>把视频文件分为多个块</li><li>每个块都存下来，以不同的速率编码</li><li>清单文件：提供不同块的URL</li></ul><p>接收方：</p><ul><li>周期性测量服务器到客户的带宽</li><li>询问清单，一次性请求一个块。选择给定当前带宽下可以忍受的最小的编码速率，可以在不同的时间点根据不同带宽选择不同的速率。</li></ul><h4 id="2-基于IP的会话视频或音频"><a href="#2-基于IP的会话视频或音频" class="headerlink" title="2.基于IP的会话视频或音频"></a>2.基于IP的会话视频或音频</h4><p>人和人交互式的场景限制了对延迟的容忍度</p><p>VoIP</p><p>VoIP端到端延迟要求：更高的延迟会明显影响交互性。小于150ms：好，大于400ms：坏。包括应用的等级（分组，播放），网络时延</p><p>会话初始化：接电话的人如何通知它的IP地址，端口号，编码算法呢？</p><p>增值业务：电话转移，筛选，记录</p><p>紧急服务：911</p><h4 id="3-流媒体直播视频或音频"><a href="#3-流媒体直播视频或音频" class="headerlink" title="3.流媒体直播视频或音频"></a>3.流媒体直播视频或音频</h4><p>比如，体育赛事</p><p>三.因特网QoS</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/2021/06/14/NP%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/14/NP%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一-NP问题"><a href="#一-NP问题" class="headerlink" title="一.NP问题"></a>一.NP问题</h2><h3 id="1-优化问题和判定问题"><a href="#1-优化问题和判定问题" class="headerlink" title="1.优化问题和判定问题"></a>1.优化问题和判定问题</h3><p>优化问题是关注某种特殊的结构，并且希望优化该结构的某种指标。判定问题是给出某个特定的指标，来判断某个特殊结构是否可以满足这个指标。一般来说，优化问题可以转化成对应判定问题。下面的最大团问题就是一种优化问题。</p><h4 id="CLIQUE优化问题"><a href="#CLIQUE优化问题" class="headerlink" title="CLIQUE优化问题"></a>CLIQUE优化问题</h4><p>最大团问题：给定一个无向图G，如果G的子图H是一个完全图，那么称H是G的一个团（clique）。定义一个团的大小是它所含节点的个数，那么最大问题就是，给定一个无向图，请找到无向图中最大团的大小。</p><p>那么根据上面的抽象概念，我们所说关注的特殊结构就是团，而指标就是团的大小。一个优化问题可以定义对应的判定问题，判定问题关注同样的结构和同样的指标。但是和优化问题不同的是，判定问题往往给出指标的一个具体的值，问你“能不能”，“可不可以”。</p><p>那么下面我们就可以引出最大团问题对应的判定问题</p><h4 id="CLIQUE判定问题"><a href="#CLIQUE判定问题" class="headerlink" title="CLIQUE判定问题"></a>CLIQUE判定问题</h4><p>问题：给定一个无向图G，请问G中是否存在大小为k的团？</p><p>优化问题比判定问题难。当我们得到优化问题的解，就很容易知道判定问题的解；但是当我们得到判定问题的解，就很难得到优化问题的解。举个例子，我们知道图G的最大团大小为a，那么我问是否存在大小为k的团的时候，只需要比较a和k的大小就可以得到答案；但是当我知道存在大小为k的团，但无法判断是否还有更大的团，所以无法知道最大团的大小！</p><p>由此，我们看出优化问题比判定问题要难！！！</p><h3 id="2-P问题"><a href="#2-P问题" class="headerlink" title="2.P问题"></a>2.P问题</h3><p>P问题就是多项式时间内可解的问题。具体定义如下：</p><p>一个问题是P问题，如果存在关于n的一个多项式<code>poly(n)</code>，并且存在解决该问题的一个算法，满足算法的代价是<code>f(n)=O(poly(n))</code></p><p>P问题可以内聚为一个问题类，是因为多项式运算的封闭性。多项式时间是一个非常大的范围，比如说<code>n^1000000</code>也是一个多项式，但在现实生活中非常不实用。那么有一个问题出现了，我们为什么要引入P问题来研究问题的难度？问题的难易是相对的，多项式时间算法不一定实用，但是如果当算法的代价不是多项式时间的，那么我们可以断定这个问题在较大规模输入的时候必然是不实用的。我们关注的一些难问题，P问题是一个很有意义的分类。</p><p>优化问题和判定问题在难度上往往差距不大，严格的说，<strong>很多优化问题在多项式时间内可解，等价于它的判定问题在多项式时间内可解！</strong></p><p>那么，对于最大团问题，我们有：<strong>最大团问题的优化问题是多项式时间可解的，当且仅当它的判定问题是多项式时间可解的</strong>。</p><p>3.NP问题</p><p>定义过P问题，我们进一步定义NP问题。NP的名称来自<code>Non-deterministic P</code>，含义是非确定性算法在多项式时间内可解，也可以理解为在多项式时间内可验证。具体如下：</p><p>我们定义一个问题为NP问题，如果该问题的解在多项式时间内可验证。这里可验证的含义是首先我们先随便猜一个解，然后可以在多项式时间内可以检查这个解是不是该问题的正确的解。</p><p>定理：**<code>CLIQUE∈NP</code>**</p><p>证明：我们可以通过O(n)来猜想图中的任意k个顶点，然后来检查他们之间是否两两都有边，那么验证过程复杂度是O(k^2)=O(n^2)，所以我们可以在多项式时间内完成问题的验证！</p><h2 id="二-问题的归约"><a href="#二-问题的归约" class="headerlink" title="二.问题的归约"></a>二.问题的归约</h2><h3 id="归约的定义"><a href="#归约的定义" class="headerlink" title="归约的定义"></a>归约的定义</h3><p>问题P可以规约到Q的含义是解决问题P可以间接通过解决问题Q来实现。下面是P到Q的归约的定义：</p><p>判定问题P到Q的归约为一个转换函数<code>T(x)</code>满足：</p><ul><li>它能够将问题P的任意一个合法输入x转换成问题Q的一个合法输入<code>T(x)</code>。假设已经有了解决问题Q的算法，将<code>T(x)</code>输入到该算法，得到问题Q的一个输出。</li><li>P问题对于任意输入x的输出是YES，当且仅当Q问题对输入<code>T(x)</code>的输出是YES</li></ul><p><img src="/picture/gy.png" alt="P到Q的归约"></p><p>在定义归约时，我们看到了研究判定问题带来的便利。不同算法问题的解可能非常不一样，但是如果仅仅讨论判定问题的话，问题的解都是YES或者NO，这样为两个判定问题之间的归约带来了很多便利！！！</p><h3 id="归约代价和问题难度的比较"><a href="#归约代价和问题难度的比较" class="headerlink" title="归约代价和问题难度的比较"></a>归约代价和问题难度的比较</h3><p>我们引入问题的归约是为了衡量问题间相对的难易程度。我们需要对归约作出一定限制，下面定义多项式时间归约<code>≤p</code>：</p><p>如果T是问题P到Q的归约，且T的代价为其输入规模的多项式，则称问题P可以多项式时间归约到问题Q，记为<code>P ≤p Q</code></p><p>对于一个难问题而言，输入转换代价如果是多项式的，那么这个代价对于解决问题的代价而言是一个小量，所以研究难问题之间的难以关系时，我们集中关注多项式时间归约。如果<code>P ≤p Q</code>，说明P的难度不超过Q的难度。对于多项式时间归约，我们有：</p><p><strong>多项式时间归约关系是一个传递关系，即对于问题P，Q，R，如果<code>P ≤p Q</code>，<code>Q ≤p R</code>，那么<code>P ≤p R</code>。</strong></p><h2 id="三-NP完全问题"><a href="#三-NP完全问题" class="headerlink" title="三.NP完全问题"></a>三.NP完全问题</h2><p><strong>NP难问题定义：一个问题P是NP难问题，如果对于属于NP的任意问题Q，<code>Q ≤p P</code></strong></p><p><strong>NP完全问题：一个问题P是NP完全问题，如果<code>P∈NP</code>，并且P是NP难问题</strong></p><p>参考书：《算法设计与分析》第二版–黄宇</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP复杂性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-零钱兑换问题</title>
      <link href="/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/10/DP-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="零钱兑换系列问题"><a href="#零钱兑换系列问题" class="headerlink" title="零钱兑换系列问题"></a>零钱兑换系列问题</h1><h2 id="1-零钱兑换1"><a href="#1-零钱兑换1" class="headerlink" title="1.零钱兑换1"></a>1.零钱兑换1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这道题目是力扣上面的题目，最近正好在学DP就做了个题解</p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>提示</p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coins</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], <span class="attr">amount</span> = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们先从暴力方法入手，我们只需要<code>DFS</code>遍历所有可能的组合数量就可以从中找到一个最优解，但是这样暴力枚举的复杂度相当大，我们需要想一个更加优秀的算法。这种问题我们还是用递归更加恰当，试想我们想知道金额x最少需要多少，那么我只需要知道金额<code>x-coin_i(i&gt;=0 &amp;&amp; i&lt;size)</code>最少需要多少枚硬币，然后找到它们最小那个加一就行了，这样利用了动态规划的思想，站在前人的成果之上来解题，就方便了很多，所以我们只需要从1开始计算到amount分别最少需要多少钱就可以了</p><p>状态转移方程：<code>dp[i]=min(dp[i-coin_j]+1) (j&gt;=0 &amp;&amp; j&lt;coins.size)</code></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins){</span><br><span class="line">                <span class="keyword">if</span>(i-coin&gt;=<span class="number">0</span>){</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount]&lt;INT_MAX<span class="number">-1</span>?dp[amount]:<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="2-零钱兑换2"><a href="#2-零钱兑换2" class="headerlink" title="2.零钱兑换2"></a>2.零钱兑换2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=2<span class="string">+2</span><span class="string">+1</span></span><br><span class="line">5=2<span class="string">+1</span><span class="string">+1</span><span class="string">+1</span></span><br><span class="line">5=1<span class="string">+1</span><span class="string">+1</span><span class="string">+1</span><span class="string">+1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题跟</p><p>类似，但是他们要求解的东西不一样，那道题要求凑成总金额需要最少的硬币数，这道题要求有多少种可以凑成总金额的组合</p><p>对于某一个金额x，我们可以查看<code>x-coin_i</code>的组合数，加到一起即可，等等…我是不是忘了什么，这样很可能出现重复的组合，比如说<code>amount=5</code>，<code>coins=[1,2,5]</code>，那么1+2可以组合成3，那么3+2可以组合成5；2+2可以组合成4，那么4+1可以组合成5，所以<code>1+2+2=5</code>这个组合至少用了两次！！！所以这种做法需要被<code>pass</code>掉！！！</p><p>那么正确的做法应该是什么呢？我们可以在外层对硬币金额进行遍历，内层更新每一个金额。这样每层循环解释起来就是，我用前k种硬币，凑成每一种金额有多少组合。那么我进行每一次遍历的时候，我之前积累起来的是用前k种硬币有多少种，那么加上第k+1种硬币能够有多少种。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度<code>O(amount * size)</code></p><p>空间复杂度<code>O(amount)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=coin;i&lt;=amount;i++){</span><br><span class="line">                dp[i]+=dp[i-coin];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网笔记网络层</title>
      <link href="/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/06/07/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一-网络层的功能"><a href="#一-网络层的功能" class="headerlink" title="一.网络层的功能"></a>一.网络层的功能</h2><ol><li>从发送主机到接收主机传送报文段</li><li>在发送端把运输层报文段封装进网络层数据报</li><li>在接收方，把报文段递交给运输层</li><li>在每一个主机和路由器都有运输层协议</li><li>路由器检查IP数据报的header域，然后通过它传递</li></ol><p><img src="/picture/zzy.png"></p><p>两个关键的功能：</p><p>交换和路由：运用路由算法决定从源到目的发包的路由路线，找到从源到目的最短路线（路由决定转发表）</p><p>转发：从输入端口转发到特定的输出端口，进行错误处理排队和调度</p><p>连接建立：在数据报开始发送之前，终端主机和路由器之间建立虚拟连接（和运输层对比，网络层的连接建立是包括主机和路由器，而运输层是在两个主机进程之间！）</p><h2 id="二-网络服务模型"><a href="#二-网络服务模型" class="headerlink" title="二.网络服务模型"></a>二.网络服务模型</h2><p>信道的什么服务模型来从发送方到接收方传输数据报？</p><h3 id="例子：ATM的网络服务模型"><a href="#例子：ATM的网络服务模型" class="headerlink" title="例子：ATM的网络服务模型"></a>例子：ATM的网络服务模型</h3><p>恒定比特率（CBR）和可变比特率（VBR），有效比特率和未定义比特率</p><p><img src="/picture/atm.png"></p><h3 id="例子：IP的网络服务模型"><a href="#例子：IP的网络服务模型" class="headerlink" title="例子：IP的网络服务模型"></a>例子：IP的网络服务模型</h3><p>尽力而为</p><p><img src="/picture/ip.png"></p><h2 id="三-IP路由器"><a href="#三-IP路由器" class="headerlink" title="三.IP路由器"></a>三.IP路由器</h2><p>互联网基础设施的核心！</p><p>路由器的容量=NXR（其中N是外部路由端口的数量，R是每个端口的速率）</p><p><img src="/picture/isp.png"></p><h3 id="不同类型的路由器"><a href="#不同类型的路由器" class="headerlink" title="不同类型的路由器"></a>不同类型的路由器</h3><h4 id="1-核心路由器"><a href="#1-核心路由器" class="headerlink" title="1.核心路由器"></a>1.核心路由器</h4><p>R = 10/40/100/200/400 Gbps  NR = O(100) Tbps (总共)</p><h4 id="2-边缘路由器"><a href="#2-边缘路由器" class="headerlink" title="2.边缘路由器"></a>2.边缘路由器</h4><p>R = 1/10/40/100 Gbps NR = O(100) Gbps</p><h4 id="2-小型商用"><a href="#2-小型商用" class="headerlink" title="2.小型商用"></a>2.小型商用</h4><p>R = 1 Gbps  NR &lt; 10 Gbps</p><h3 id="路由器的内部：架构概览"><a href="#路由器的内部：架构概览" class="headerlink" title="路由器的内部：架构概览"></a>路由器的内部：架构概览</h3><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h4><p><img src="/picture/router%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88.png"></p><h4 id="2-输入端口"><a href="#2-输入端口" class="headerlink" title="2.输入端口"></a>2.输入端口</h4><p><img src="/picture/11.png"></p><p>输入端口的任务：</p><ul><li>收到包（物理层的任务）</li><li>更新IP头：TTL，checksum，可选字段，切片等</li><li>查找目的IP对应的合适的输出端口</li><li>排队：如果包到达太快就要缓存排队</li></ul><h5 id="查找合适的输出端口"><a href="#查找合适的输出端口" class="headerlink" title="查找合适的输出端口"></a>查找合适的输出端口</h5><p>如果一个表项对应一个地址就要有40亿个表项，为了可扩展性，地址是聚合的，目标地址按一定范围映射。<strong>按照最长前缀匹配规则</strong></p><p><img src="/picture/%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80.png"></p><p>由于一个个表项匹配复杂度有点高，我们可以利用树形结构</p><p><img src="/picture/tree.png"></p><h5 id="处理速度"><a href="#处理速度" class="headerlink" title="处理速度"></a>处理速度</h5><p>输入端口的任务要更新包头还有转发表查询，大多数被硬件处理！</p><h4 id="3-输出端口"><a href="#3-输出端口" class="headerlink" title="3.输出端口"></a>3.输出端口</h4><p><img src="/picture/outputport.png"></p><p>输出端口任务：</p><ul><li>包分类：把包映射到流里面</li><li>缓冲处理：决定什么时候和哪些包要扔掉</li><li>调度：决定哪些包什么时候传输（从排队的包里面选择进行传输，当buffer满了就要选择包丢弃）</li></ul><p>缓冲处理先进先出：最简单，没有分类，buffer满了的话就丢掉后来的包</p><p><img src="/picture/fifo.png"></p><p>包分类：根据header域来把IP包分类，比如源和目的的IP地址，源和目的的TCP端口号，服务类型，协议类型……</p><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>对于每一个流（“flow”）都有一个队列，调度器决定什么时候才能够哪个队列发包。调度器的目标是：快！</p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>在最高优先级的要在低优先级之前转发</p><h6 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h6><p>轮转：每个队列里的包被轮流调度</p><p>公平排队（FQ）：对于不同大小的队列进行轮转调度</p><p>加权公平队列（WFQ）：按照权重比例来调度</p><h4 id="4-交换结构"><a href="#4-交换结构" class="headerlink" title="4.交换结构"></a>4.交换结构</h4><p>交换结构用来连接输入端口和输出端口，从输入buffer传送到合适的输出buffer。</p><p>交换速率：包可以从输入端口到输出端口传送的速率</p><p>有三种结构来交换：</p><ul><li>通过共享内存交换</li><li>通过总线交换</li><li>通过物联的网络交换：比如横梁</li></ul><p><img src="/picture/3%E7%A7%8D.png" alt="三种交换结构"></p><h5 id="4-1-通过共享内存交换"><a href="#4-1-通过共享内存交换" class="headerlink" title="4-1 通过共享内存交换"></a>4-1 通过共享内存交换</h5><p>第一代路由器采用这种，它是一种直接在CPU控制下交换的传统的电脑，分组被拷贝到系统的内存里面。速度被内存的带宽限制</p><h5 id="4-2-通过总线交换"><a href="#4-2-通过总线交换" class="headerlink" title="4-2 通过总线交换"></a>4-2 通过总线交换</h5><p>数据报通过共享总线从输入端口内存传送到输出端口内存，速率被总线的带宽限制</p><h5 id="4-3-通过网状结构交换"><a href="#4-3-通过网状结构交换" class="headerlink" title="4-3 通过网状结构交换"></a>4-3 通过网状结构交换</h5><p>克服了总线带宽的限制</p><h2 id="四-虚电路和数据报网络"><a href="#四-虚电路和数据报网络" class="headerlink" title="四.虚电路和数据报网络"></a>四.虚电路和数据报网络</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>为了传输数据会预留端到端的资源（比如带宽和交换能力）</p><p>专用的资源，没有共享</p><p>对性能有保证</p><p>连接需要建立和撤销</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>每个端到端的数据流被划分为分组</p><p>应用A，B的分组共享网络资源</p><p>存储和转发：分组一次移动一跳，并且在交换机里需要排队</p><p>资源争夺：总共的资源需要量可以超过可获得的资源总量总量</p><p>拥塞：分组排队和等待链路</p><h4 id="分组交换的两种类型"><a href="#分组交换的两种类型" class="headerlink" title="分组交换的两种类型"></a>分组交换的两种类型</h4><p>虚电路网络：对信息流提供网络服务，VC网络提供基于服务的网络连接，比如ATM，X.25，Frame Relay</p><p>数据报网络：对单个的分组提供网络服务，数据报网络提供网络层无连接服务，例如IP网络</p><p><img src="/picture/%E8%99%9A%E7%94%B5%E8%B7%AF%E8%B7%AF%E7%94%B1.png" alt="虚电路路由"></p><p><img src="/picture/%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%B7%AF%E7%94%B1.png" alt="数据报路由"></p><h5 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h5><ul><li>对于每个信息流要进行连接建立和拆除</li><li>每个分组带着VC号</li><li>在源到目的路径上的每个交换机维护每个传输连接的状态</li><li>连接，交换资源（带宽，缓存）或许被分配给虚电路</li></ul><h6 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h6><p>这个是虚电路网络的必要功能，两个主机和中间交换机预留一条路径给虚连接，路由没用来找到一条合适的路径</p><h6 id="虚电路的实现"><a href="#虚电路的实现" class="headerlink" title="虚电路的实现"></a>虚电路的实现</h6><p>一个虚电路包括一条从源到目的的路径，还包括VC号（每个链路一个），交换机里面转发表的表项。</p><p>注意：属于VC的分组携带VC号（而不是地址！！！），VC号可能在每条链路上被改变，转发表列出了新的VC号</p><p>VC的转发表如下：</p><p><img src="/picture/vc%E8%BD%AC%E5%8F%91%E8%A1%A8.png" alt="vc转发表"></p><h6 id="信令协议"><a href="#信令协议" class="headerlink" title="信令协议"></a>信令协议</h6><p>被用来建立，维护，拆除虚电路</p><p>被用在ATM，frame-relay，X.25</p><p>现在已经不用了</p><p><img src="/picture/%E4%BF%A1%E4%BB%A4%E5%8D%8F%E8%AE%AE.png" alt="信令协议"></p><h5 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h5><p>在网络层不需要连接建立，没有网络层的“连接”概念</p><p>交换：没有端对端的链接的状态</p><p>用目的主机地址来进行分组转发</p><p>在同一组源和目的之间或许会有不同的路径</p><p><img src="/picture/sjbwl.png" alt="数据报网络发包"></p><p>数据报网络的转发表：</p><p><img src="/picture/datagram.png" alt="数据报网络转发表"></p><h5 id="数据报网络和虚电路的对比"><a href="#数据报网络和虚电路的对比" class="headerlink" title="数据报网络和虚电路的对比"></a>数据报网络和虚电路的对比</h5><p>数据报：</p><ul><li>在计算机间交换数据，有弹性，没有严格的计时</li><li>聪明的端系统：可以适应，控制，错误恢复，网络内部简单，边缘复杂</li><li>不同的链路类型：不同的特点，统一的服务是很困难的</li></ul><p>虚电路：</p><ul><li>从电话演变而来</li><li>人类的交流，有严格的时限，需要可靠性，需要服务保障</li><li>沉默的端系统：电话，网络内部复杂</li><li>链路类型统一化</li></ul><h2 id="五-IP协议"><a href="#五-IP协议" class="headerlink" title="五.IP协议"></a>五.IP协议</h2><p><code>IP=Internet Protocol</code>，最著名的因特网协议，它被<code>ARPANET</code>开发</p><p>IP层的内容位于各个主机和路由器上，提供无连接服务</p><p>网络层的概览：</p><p><img src="/picture/ipwlc.png" alt="网络层"></p><h3 id="因特网寻址"><a href="#因特网寻址" class="headerlink" title="因特网寻址"></a>因特网寻址</h3><h5 id="寻址等级"><a href="#寻址等级" class="headerlink" title="寻址等级"></a>寻址等级</h5><p>物理因特网地址：用于PDU（目的MAC地址）在单个物理网络中的路由</p><p>因特网地址：IP地址或者因特网地址，用于在网络中路由PDU。对于每个端系统或者介质系统都有唯一的地址</p><p>应用层地址：在目的主机分配的进程ID，比如TCP/IP端口</p><h5 id="寻址作用域"><a href="#寻址作用域" class="headerlink" title="寻址作用域"></a>寻址作用域</h5><p>全局地址</p><p>网络连接地址</p><p>端口地址：在网络层之上并且在一个系统独一无二，例如端口80-TCP/IP的网络服务器监听端口</p><h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>个人或者单播寻址</p><p>广播地址</p><p>多播地址</p><p>任播地址</p><p><img src="/picture/al.png" alt="地址层级"></p><h3 id="IP的操作"><a href="#IP的操作" class="headerlink" title="IP的操作"></a>IP的操作</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li><p>主机和路由器维护路由表，指出数据报应被发送到的下一个路由器，静态-可能包含可替代的路径，动态-对拥塞和错误灵活的回复</p></li><li><p>路由策略：距离向量，链路状态，路径向量</p></li></ul><h4 id="数据报的生存期"><a href="#数据报的生存期" class="headerlink" title="数据报的生存期"></a>数据报的生存期</h4><p>数据报可能无限期地在两个路由器间循环</p><p>我们给数据报一个生存时间可以解决这个问题：在IP头里面放了一个TTL域（Time to live）</p><h3 id="IP结构"><a href="#IP结构" class="headerlink" title="IP结构"></a>IP结构</h3><p>IP分组包括头和负载：</p><ul><li>负载对于网络层是不透明的</li><li>头是我们需要关注的</li><li>IP层第一个端到端的层级（从下往上看）</li></ul><p>IP头是如何设计出来的呢？</p><p>我们思考一下IP头是一种在源和目的，源和中间路由器间传递网络信息的接口，那么我们设计它的话需要考虑他有多少使命要完成，很多东西既然存在必然会尤其需要的地方：需要它-&gt;被设计出来。</p><p>IP的功能：</p><ul><li>解析包</li><li>能把包送到目的</li><li>处理路上的一些问题：循环（bugs），错误，包过大</li><li>可以根据情况调节革新</li><li>处理特殊情况</li></ul><h4 id="1-解析包"><a href="#1-解析包" class="headerlink" title="1.解析包"></a>1.解析包</h4><p>首先，想要解析包，就要根据固定的格式，不同的版本格式可能不同，所以我们需要<code>IP version number（4bit）</code>，包的长度（16bit，用来查看是否有optional域，如果没有就是20byte）</p><p><code>Header length</code>表明头里面有多少个4字节，一般是5（20bype），如果有<code>Options</code>域的话可能就更多</p><h4 id="2-把包送到目的"><a href="#2-把包送到目的" class="headerlink" title="2.把包送到目的"></a>2.把包送到目的</h4><p>需要目的IP地址，32bit</p><p>我们插入一个小插曲，辨析一下MAC地址和IP地址的区别</p><table><thead><tr><th>MAC地址</th><th>IP地址</th></tr></thead><tbody><tr><td>在适配器生产时被硬编码</td><td>后期被配置的，可以被动态学习到</td></tr><tr><td>扁平的48bit的名空间</td><td>层级式的32bit名空间</td></tr><tr><td>类似身份证号</td><td>类似邮政地址</td></tr><tr><td>可携带的，不管主机移动到哪都不变</td><td>不可携带，取决于主机在哪个地方</td></tr><tr><td>被用来在同一个网络下传送包</td><td>用来给目的IP子网传送包</td></tr></tbody></table><h4 id="3-处理路径上的问题"><a href="#3-处理路径上的问题" class="headerlink" title="3.处理路径上的问题"></a>3.处理路径上的问题</h4><p>循环：为了破除循环，设计了<code>TTL(Time to Live)</code>，8bit</p><p>错误：检验和<code>checksum(16bit)</code></p><p>包太大：分段域，一共32bit，里面还有更细致的划分</p><h5 id="3-1TTL"><a href="#3-1TTL" class="headerlink" title="3-1TTL"></a>3-1TTL</h5><p>因为一些<code>bugs</code>造成包在网络中循环，这样积累起来会慢慢消耗掉网络的所有容量，所以我们设计了TTL域，开始的时候设置一个值，在每一跳都减一，当减为0的时候就丢弃这个包并且给源地址发送”Time exceeded”超时错误包</p><h5 id="3-2错误"><a href="#3-2错误" class="headerlink" title="3-2错误"></a>3-2错误</h5><p>需要检验和，在包头有一个特定的格式，如果检查出错误就丢包。</p><p>有一个问题，就是为什么在每一个路由器都要重新计算检验和呢？是因为<code>TTL</code>的改变或者包的切片会导致<code>checksum</code>发生变化！</p><h5 id="3-3分片"><a href="#3-3分片" class="headerlink" title="3-3分片"></a>3-3分片</h5><p>每一个链路都有最大传输单元（<code>MTU</code>），就是它所能承载的最大比特数量</p><p>如果包的大小超出了链路的MTU，一个路由器可以把包分成多个片。我们在目的主机必须重组恢复成最原始的包。</p><p>下面我们举一个例子：</p><p>一个<code>4000byte</code>大小的包要穿越一个<code>MTU</code>是<code>1500byte</code>的链路</p><p>那么可以切成下面这样的3片</p><p><img src="/picture/qp1.png" alt="切片"></p><p>有一个问题，切片之后为什么还要重组？下面的图片给了解答</p><p>因为上层协议的包头都在一个包的前面，后面都是数据的部分，所以我们要重组以便能够完整地交付给上层</p><p><img src="/picture/whyre.png" alt="why重组"></p><p>那么又有问题来了，我们在哪里重组？目的主机？还是路由器？</p><p>这个是端到端原理的典型案例</p><p>在如果由路由器重组就给网络带来了负担，因为重组算法比较复杂，要维护各种状态；而且切片不一定走同一条路径，所以可能很多路由器得到的切片是一些碎片。所以在中间路由器重组是事倍功半的，所以在目的主机重组</p><p>那么我们重组需要那些信息来填充字段呢？</p><p>我们需要来找到切片属于哪个分组，所以分组的ID被需要；我们还要知道每个切片是分组的哪部分，所以需要偏移量字段；<code>Flag</code>字段：</p><ul><li><code>Reserved</code>：目前被忽略</li><li>DF：不要被切片，可能会触发错误包发回发送者</li><li>MF：置1，表示这个不是末尾的切片</li></ul><p>下面我们来举个分片的例子</p><p><img src="/picture/%E5%88%86%E7%89%871.png"></p><p><img src="/picture/%E5%88%86%E7%89%872.png"></p><p><img src="/picture/%E5%88%86%E7%89%873.png"></p><p><img src="/picture/%E5%88%86%E7%89%874.png"></p><p><img src="/picture/%E5%88%86%E7%89%875.png"></p><h4 id="4-支持更新"><a href="#4-支持更新" class="headerlink" title="4.支持更新"></a>4.支持更新</h4><p>通过版本号<code>version number(4 bit)</code>，或许还可以算上”特殊处理域“</p><h4 id="5-支持一些特殊处理"><a href="#5-支持一些特殊处理" class="headerlink" title="5.支持一些特殊处理"></a>5.支持一些特殊处理</h4><h5 id="5-1特殊处理域"><a href="#5-1特殊处理域" class="headerlink" title="5-1特殊处理域"></a>5-1特殊处理域</h5><p><code>Type of Service</code>服务类型域</p><p>允许包被按需对待，比如不同的优先级，不同的拥塞提醒之类的（比如说一些实时语音通话比较注重时延，一些文件比较注重准确率）。在不同的运营商（自治域）可能要被重新定义</p><h5 id="5-2Options"><a href="#5-2Options" class="headerlink" title="5-2Options"></a>5-2Options</h5><p>它是可变长度，解析时候通过<code>packet len</code>字段来判断是否有<code>Options</code></p><h4 id="6-其他一些字段"><a href="#6-其他一些字段" class="headerlink" title="6.其他一些字段"></a>6.其他一些字段</h4><h5 id="源地址"><a href="#源地址" class="headerlink" title="源地址"></a>源地址</h5><p>我们需要告诉目的端系统是谁发来的包，所以需要<code>Source Address</code>字段</p><h5 id="协议Protocol"><a href="#协议Protocol" class="headerlink" title="协议Protocol"></a>协议Protocol</h5><p>告诉我们上层协议是什么，对于接收主机端的多路分解很重要，告诉主机要交付给哪个上层协议</p><p><img src="/picture/protocol.png" alt="协议栈"></p><h3 id="IPv4头"><a href="#IPv4头" class="headerlink" title="IPv4头"></a>IPv4头</h3><p><img src="/picture/ipv4.png" alt="IPv4"></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4地址枯竭迫使它的出现，专注于简化IP协议，抛弃一些不必要的字段，形成了一种优雅，无二义性的协议</p><p><img src="/picture/%E5%AF%B9%E6%AF%94.png" alt="IPv4和IPv6的对比"></p><p>总结一下这些变化：</p><ol><li>切片被清除</li><li>校验和被清除</li><li>options字段被清除</li><li>头的长度字段被清除</li><li>扩展了地址大小</li><li>添加了流标签</li></ol><h4 id="IPv6头"><a href="#IPv6头" class="headerlink" title="IPv6头"></a>IPv6头</h4><p><img src="/picture/ipv6.png" alt="IPv6头"></p><h5 id="Traffic-Class字段"><a href="#Traffic-Class字段" class="headerlink" title="Traffic Class字段"></a>Traffic Class字段</h5><h5 id="Flow-Label字段"><a href="#Flow-Label字段" class="headerlink" title="Flow Label字段"></a>Flow Label字段</h5><p>什么是流？</p><p>它是一个从特定源到特定目的的分组的序列</p><p>从主机的视角来看，由一个应用生成并且有同样的传输服务要求，或许包含一个单独的或者多个TCP连接。一个应用可能生成一个或者多个流</p><p>从路由器的视角看，这个是影响这些包如何被路由器处理的共享属性</p><p>流是独一无二的标识，被源和目的地址标识和非零的流标签所定义。流需求被定义优先于流的发端。路由器通过简单的在一个表中查询流标签来决定如何路由和处理分组。</p><h5 id="IPv6头的结构（包含拓展的header）"><a href="#IPv6头的结构（包含拓展的header）" class="headerlink" title="IPv6头的结构（包含拓展的header）"></a>IPv6头的结构（包含拓展的header）</h5><p><img src="/picture/ipv6s.png"></p><p>可选的部分在拓展headers里面，在主header后面呈菊花链状</p><p><img src="/picture/header.png"></p><p>这些header是按序出现的</p><p>路由器在ipv6里面不切片，因为要在核心里面更有效率的处理，切片已经在主机里面做好了。如果包在下一跳发现太大了，那么就发送包太大error消息（ICMPv6消息）</p><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>iPv6没有广播，有一个“全部节点”多播群组：ff02::1</p><p>广播的缺点，它唤醒了全部节点，实际上只有很少的设备被需要，可能造成广播风暴</p><h5 id="邻居节点探索"><a href="#邻居节点探索" class="headerlink" title="邻居节点探索"></a>邻居节点探索</h5><p>IPv6没有ARP，取而代之的是<code>Neighbor Discovery</code>，使用<code>ICMPv6</code>和多播</p><p><code>Neighbor Discovery</code>被节点使用为了获取地址，发现邻居路由器，跟踪地址变化，检查邻居可达性，做地址复制检测</p><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>128bit，单个接口或许有多个单播地址，有三种类型地址：单播，多播，任播</p><h4 id="从IPv4迁移到IPv6"><a href="#从IPv4迁移到IPv6" class="headerlink" title="从IPv4迁移到IPv6"></a>从IPv4迁移到IPv6</h4><p>所有节点不可以同时更新，所以需要有一种机制让IPv4和IPv6同时工作。</p><p>两种可能：</p><ul><li>双栈技术</li><li>隧道：在IPv4路由器中，在IPv4数据报中的IPv6头被当做数据负载</li></ul><h2 id="六-IP地址"><a href="#六-IP地址" class="headerlink" title="六.IP地址"></a>六.IP地址</h2><p>IP地址是32位的全局地址，分为网络部分（高位）和主机部分（低位）</p><p>对于主机和路由器的每个物理接口都需要一个通向一个网络的分离的地址。</p><p>使用十进制点的记法</p><p>网络部分ID被如下的三个机构管辖：</p><ul><li>American Registry for Internet Numbers (ARIN)</li><li>Reseaux IP Europeens (RIPE）</li><li>Asia Pacific Network Information Centre (APNIC)</li></ul><p>主机部分ID被指定的组织来分配</p><h3 id="IPv4地址格式"><a href="#IPv4地址格式" class="headerlink" title="IPv4地址格式"></a>IPv4地址格式</h3><p>分为A类地址，B类地址，C类地址……</p><p><img src="/picture/ipv4dizhi.png" alt="IPv4地址"></p><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p><img src="/picture/A.png" alt="A类地址"></p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p><img src="/picture/B.png" alt="B类地址"></p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p><img src="/picture/C.png" alt="C类地址"></p><h3 id="子网和子网掩码"><a href="#子网和子网掩码" class="headerlink" title="子网和子网掩码"></a>子网和子网掩码</h3><p>处理网络地址不足，地址的主机部分分为子网号和主机号。子网掩码指出哪些比特是子网号，哪些是主机号，每个局域网被分配一个子网号，本地路由器在子网里面路由</p><p>子网对于因特网的其余部分看起来像一个单独的网络，把全部的网络从网络号和路由的复杂中隔离出来</p><p><img src="/picture/subtorest.png"></p><p><img src="/picture/route.png"></p><h3 id="CIDR记法"><a href="#CIDR记法" class="headerlink" title="CIDR记法"></a>CIDR记法</h3><p>无类域间路由，一个IP地址以“A.B.C.D/n”的形式被呈现，n叫做IP前缀</p><p><img src="/picture/CIDR.png"></p><h2 id="七-网络层协议簇"><a href="#七-网络层协议簇" class="headerlink" title="七.网络层协议簇"></a>七.网络层协议簇</h2><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h3><p>对内部和外部流量启用不同的IP地址</p><p>网络地址转换发生在带有更广阔的因特网的内联网接口</p><p>目的：</p><ul><li>作为一个防火墙隐藏内部IP地址</li><li>允许一个组织使用更多的内部IP地址</li><li>隔离组织的变化</li></ul><p>下面有3种NAT：</p><ul><li>静态NAT：一个私有的IP地址映射到一个预留的共有IP地址，用于网络服务器</li><li>动态NAT：NAT路由器保持一个已注册IP地址池，在需要的时候分配给私有IP地址，通常用于客户内部网PC</li><li>单地址：NAT/Overloading/Masquerading/Network Address  Port Translation (NAPT）</li></ul><p>图解NAT：</p><p><img src="/picture/NAT.png"></p><p><img src="/picture/overload.png"></p><p><img src="/picture/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="网络地址转换"></p><p>NAT是很有争议的，地址不时会发生变化，必须被P2P应用纳入考虑</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><code>Internet Control Message Protocol</code></p><p>用来在主机和路由器间传播错误和控制消息</p><ul><li>Echo请求和Echo回复被用来诊断网络</li><li>还会传达关于问题的反馈，比如超时，不可达主机……</li></ul><p>被封装在IP数据报里面</p><ul><li><code>Protocol type=1</code></li><li>不可靠</li></ul><p><img src="/picture/ICMP.png" alt="ICMP信息格式"></p><p><img src="/picture/ICMP1.png" alt="ICMP类型"></p><p><img src="/picture/ICMP2.png" alt="ICMP不同类型格式"></p><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>测试目的地址是否可达，源发送一个<code>echo request</code>给遥远的主机或者路由器。如果远程系统收到了<code>ICMP</code>包，他会给源回复一个<code>echo reply</code>。</p><p>ping的实用程序可以做得更好，比如计算从发送到接收时间，计算到目的有多少跳</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>用来测量到目的地址需要多少跳</p><ol><li>源发送TTL等于1的第一个IP（UDP）包，第一个路由器把TTL减为0，然后发送TTL超时错误给源。源计算RTT，然后重复三次</li><li>源发送第二个IP包（TTL设置为2），第二个路由器发回TTL超时错误，源计算RTT，然后重复三次</li><li>源继续增加TTL知道到达目的</li></ol><p>Path MTU</p><p>用来找到路径上的最小MTU</p><ol><li>源发送不带有切片位的大IP包</li><li>如果包太大，相关路由器会发送错误包</li><li>源相应减小包的大小，再次尝试</li><li>重复直到包到达目的（没有收到错误包）</li></ol><h2 id="八-移动IP"><a href="#八-移动IP" class="headerlink" title="八.移动IP"></a>八.移动IP</h2><p>移动IP标准在1996年被IESG批准，同年被IETF作为一种被提议的标准发布。它被发明出来是为了应对日益增长的PDA和Laptop的使用需求。</p><p>数据报从一个网络移动到另一个网络需要用到目的的IP地址，IP地址被划分为两部分<code>&lt;netID,hostID&gt;</code>，大多数网络应用支持<code>TCP</code>连接，<code>TCP</code>使用IP地址和端口号来路由和交付。当移动设备从一个网络移动到另一个的时候，它的IP地址动态改变，因此TCP连接在每次移动的时候需要重启正在进行的会话。移动IP正在解决动态变化的IP地址的问题，就不必重启TCP，就好像移动设备的IP地址假装没改变</p><p><img src="/picture/mip.png"></p><h3 id="不同的实体"><a href="#不同的实体" class="headerlink" title="不同的实体"></a>不同的实体</h3><p>移动节点：一个或许会改变它的接入点或者从一个网络到另一个网络连接的主机</p><p>通信节点：一个要给移动节点发包的主机</p><p>归属代理：一个在归属网络上维护一个已注册移动节点列表的节点</p><p>外部代理：一个在外部网络上帮助移动节点发送数据报的路由器</p><h3 id="三角路由"><a href="#三角路由" class="headerlink" title="三角路由"></a>三角路由</h3><p><img src="/picture/%E4%B8%89%E8%A7%92%E8%B7%AF%E7%94%B1.png"></p><h3 id="协议的细节"><a href="#协议的细节" class="headerlink" title="协议的细节"></a>协议的细节</h3><p>移动路由有三种能力：发现，注册，隧道技术</p><h4 id="1-发现"><a href="#1-发现" class="headerlink" title="1.发现"></a>1.发现</h4><p>移动（外部）代理：周期性发送带有移动代理广告扩展的ICMP路由广告来表明它的存在</p><p>移动节点：可以向代理请求广告或者简单地等待下一个广告</p><h4 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h4><p>移动节点：需要来自外部代理的转交地址。请求它的归属代理来转发数据包到外部代理。</p><p>四步：</p><ol><li>移动节点发送<code>registration request</code>给外部代理</li><li>外部代理转发这个请求给归属代理</li><li>归属代理发送<code>registration reply</code>给外部代理</li><li>外部代理转发这个<code>reply</code>给移动节点</li></ol><p><img src="/picture/registration.png"></p><p>下面是一个注册的例子</p><p><img src="/picture/%E4%BE%8B%E5%AD%90.png"></p><h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h4><p>在注册之后，一个IP隧道建立起来了，在归属代理和移动节点的COA之间建立。归属节点广播把移动节点IP地址绑定到归属代理MAC地址的ARP请求。因此，归属代理收到了发送给移动节点的包，会通过IP隧道转发给外部代理</p><p><img src="/picture/111.png"></p><h2 id="九-路由算法"><a href="#九-路由算法" class="headerlink" title="九.路由算法"></a>九.路由算法</h2><p>路由分为中心化的路由和分布式路由</p><p>中心化：固定的并且需要配置</p><p>分布式：通过洪泛，随机的，自适应的</p><p><img src="/picture/cvd.png"></p><h3 id="插播：洪泛（分布式）"><a href="#插播：洪泛（分布式）" class="headerlink" title="插播：洪泛（分布式）"></a>插播：洪泛（分布式）</h3><p>洪泛不需要全局网络信息，分组被交换机发送给所有邻居，分组在除了入链路的每个链路都会转发，最后很多拷贝会到达目的。</p><p>洪泛的性质：所有可能的路由都会被尝试，至少一个包会通过最小cost路由，所有的交换机都被访问过（分布式，可能用于路由）</p><h3 id="随机路由（分布式）"><a href="#随机路由（分布式）" class="headerlink" title="随机路由（分布式）"></a>随机路由（分布式）</h3><p>节点选择一个出链路来转发到来的包，选择是随机或者轮流的，基于概率。不需要什么网络信息，适合强连通网络，路由不是最佳的。</p><p>以下说明如何分配概率：</p><p><img src="/picture/p.png"></p><h3 id="自适应路由"><a href="#自适应路由" class="headerlink" title="自适应路由"></a>自适应路由</h3><p>被用作几乎所有分组交换网络，当网络状况改变时候路由决策也会改变。需要网络的信息，需要在网络质量和开销之间权衡。有助于拥塞控制</p><h3 id="两种最小花费算法"><a href="#两种最小花费算法" class="headerlink" title="两种最小花费算法"></a>两种最小花费算法</h3><p><code>Dijkstra</code>算法和<code>Bellman-Ford</code>算法</p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>找到从给定源到其他所有节点的最短路径</p><ul><li>N是网络中的节点集合</li><li>s是源节点</li><li>T是到目前为止已经被算法合并的节点</li><li><code>w(i,j)</code>是从i到j的链路消耗<ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li></ul><h5 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h5><p><code>L(n)</code>是从源s到当前已知的节点n的最小路径花费</p><ol><li>初始化<ul><li><code>T={s}</code>是只包含源点s被合并其中的节点的集合</li><li><code>L(n)=w(s,n) for n≠s</code></li><li>初始化到邻居节点的路径花费</li></ul></li><li>得到下一个节点<ul><li>找到不在T中的到源点s的最短路径的x，<code>min L(x)</code></li><li>把x合并在T中</li></ul></li><li>更新路径<ul><li><code>L(n)=min{L(n),L(x)+w(x,n)} for all n∉T</code></li><li>如果后者更小的话，那么从s到n的路径就变成了从s到x再从x到n的路径</li></ul></li></ol><p>算法在所有节点被添加到T中时结束</p><p>步骤2和3的一次迭代会添加一个新节点到T中</p><p><img src="/picture/dijkstra.png"></p><p>但是可能会出现震荡，解决办法就是非同步运行路由算法，链路代价更新随机化（让每台路由器发送链路通告的时间随机化）</p><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>找到一条从给定节点包含最多一条链路的最短路径，</p><p>找到一条从给定节点包含最多两条链路的最多路径（基于前面的步骤）</p><p>找到一条…不断进行迭代</p><ul><li><p>s是源点</p></li><li><p><code>w(i,j)</code>是从i到j的链路消耗</p><ul><li><code>w(i,i)+0</code></li><li><code>w(i,j)=无穷</code>当两节点没有直接连接</li><li><code>w(i,j)&gt;0</code>当两节点直接连接</li></ul></li><li><p>h是在当前阶段路径上链路的最大数量</p></li><li><p><code>L_h(n)</code>是在当前不超过h条链路的限制下从s到n的最短链路消耗</p></li></ul><h5 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>初始化<ul><li><code>L_0(n) = ∞, for all n ≠ s</code> </li><li><code>L_1(n) = w(s, n) </code></li><li><code>L_h(s) = 0, for all h</code></li></ul></li><li>更新<ul><li>对于每个连续的<code>h&gt;0</code></li><li>对于每个<code>n≠s</code>，计算<code>L_(h+1)(n) = min_j [Lh(j)+w(j,n)]</code></li><li>用已经找到最小的预处理节点j连接n</li><li>消除在早期迭代过程中形成的n的任何连接</li></ul></li><li>重复一直到没有改变</li></ol><p><img src="/picture/Bellman.png"></p><h5 id="链路花费改变"><a href="#链路花费改变" class="headerlink" title="链路花费改变"></a>链路花费改变</h5><p>当链路代价改变时候：</p><ul><li>节点检测到本地链路代价改变了</li><li>更新路由信息，重新计算距离向量</li><li>如果<code>DV</code>，改变了，就通知周围邻居<ul><li><img src="/picture/dv.png"></li><li>t0:y检测到链路代价改变，更新dv，通知邻居</li><li>t1:z收到来自y的更新，更新自己的表，计算到x的最小距离，发送给邻居</li><li>t2:y收到z的更新，更新自己的表，没有改变，所以不用给z发送消息</li></ul></li></ul><p>这样会出现无穷计数问题，当链路代价改变时候需要非常多次迭代才可以稳定下来！！！所以我们需要一种机制，叫做<strong>毒性逆转</strong></p><p>毒性逆转：当一个节点a通过b到达c，那么我向b声称我到c的距离是无穷！！！</p><h4 id="Dijkstra-VS-Bellman-Ford"><a href="#Dijkstra-VS-Bellman-Ford" class="headerlink" title="Dijkstra VS Bellman-Ford"></a>Dijkstra VS Bellman-Ford</h4><p>基于DIjkstra路由：</p><ul><li><strong>链路状态</strong>洪泛到其他所有节点</li><li>每个节点将会有一个完整的拓扑，并且建立他自己的路由表</li><li>不能处理负权值</li></ul><p>基于Bellman-Ford路由：</p><ul><li>每个节点维护一个到其他已知节点的<strong>距离向量</strong></li><li>距离向量要发送给直接邻居来更新路径和cost</li><li>路由表是分布式的</li></ul><h5 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h5><p>DK：n个节点，e个链路，有O(ne)个消息</p><p>BF：取决于收敛时间</p><h5 id="收敛时间："><a href="#收敛时间：" class="headerlink" title="收敛时间："></a>收敛时间：</h5><p>DK：O(n^2)并且很快，或许会有震动</p><p>BF：很慢并且取决于链路代价改变，或许包含路由环</p><h5 id="鲁棒性："><a href="#鲁棒性：" class="headerlink" title="鲁棒性："></a>鲁棒性：</h5><p>DK：可能广播不正确的链路代价，但是错误的范围被限制</p><p>BF：错误节点可能交换不正确的路径代价，错误可能会传播到网络中</p><h3 id="路由算法分类："><a href="#路由算法分类：" class="headerlink" title="路由算法分类："></a>路由算法分类：</h3><h4 id="中心化算法和去中心化（分布式）算法"><a href="#中心化算法和去中心化（分布式）算法" class="headerlink" title="中心化算法和去中心化（分布式）算法"></a>中心化算法和去中心化（分布式）算法</h4><p>中心化：所有节点都要有完整的拓扑，链路代价信息，比如<strong>链路状态算法</strong></p><p>分布式：路由器知道物理上直接连接的邻居，还有到邻居的代价，通过迭代的计算过程和邻居交换信息，比如<strong>距离向量算法</strong></p><h4 id="静态或动态"><a href="#静态或动态" class="headerlink" title="静态或动态"></a>静态或动态</h4><p>静态：经过时间，路由很慢的改变</p><p>动态：路由很快进行改变，为了回应链路代价的改变，周期化进行更新</p><h3 id="如何判断链路代价？"><a href="#如何判断链路代价？" class="headerlink" title="如何判断链路代价？"></a>如何判断链路代价？</h3><p>在ARPANET中有3个阶段：</p><h4 id="1969年第一个阶段"><a href="#1969年第一个阶段" class="headerlink" title="1969年第一个阶段"></a>1969年第一个阶段</h4><p>输出队列的长度作为链路代价</p><p>Bell-Ford被用于路由</p><h4 id="1979年第二个阶段"><a href="#1979年第二个阶段" class="headerlink" title="1979年第二个阶段"></a>1979年第二个阶段</h4><p>测量出来的延时作为链路代价，其中混合了排队时延，传输时延，传播时延。Dijkstra算法用于路由</p><h4 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h4><p>为了处理Dijkstra的震荡问题，让一些连接保持在加载的链路上来平衡流量。把链路利用率来表示链路状态，用之前的值和新的利用率结合起来更新。也有的用跳归一化指标来计算链路代价。</p><p>链路利用率：</p><ul><li>p=2（Ts-T）/(Ts-2T)</li><li>T是当前测量的时延</li><li>Ts是分组的长度除以传输速率（传输时延）</li></ul><p>更新利用率</p><ul><li><code>Un=αp+(1-α)Un-1</code></li><li>Un是第n次的链路利用率</li><li>α是常数，现在设置为0.5</li></ul><h2 id="十-因特网路由"><a href="#十-因特网路由" class="headerlink" title="十.因特网路由"></a>十.因特网路由</h2><p>层级化路由：把路由器整合到一个个域里面，叫自治系统（autonomous system，AS）。同一个AS里面的运行同样的路由协议（AS内部路由协议）；不同AS可以运行不同的AS内部路由协议。网关路由器负责目的地址在AS外部的路由，跟外面的路由器一起运行AS间路由协议，和内部路由器运行AS内部路由协议。</p><h3 id="自治系统（Autonomous-Systems，AS）"><a href="#自治系统（Autonomous-Systems，AS）" class="headerlink" title="自治系统（Autonomous  Systems，AS）"></a>自治系统（Autonomous  Systems，AS）</h3><p>它是被单个ISP或者更大组织掌管的路由器和网络的集合。一个被分配独一无二的AS号（ASN）的网络，使用普通的路由协议。</p><p>IGP是Interior Gateway Protocol，用于AS内路由。EGP是Exterior Gateway Protocol，用于AS间路由</p><h4 id="IGP"><a href="#IGP" class="headerlink" title="IGP"></a>IGP</h4><ul><li>RIP: Routing Information Protocol, use distance  vector</li><li>OSPF: Open Shortest Path First, use link state</li><li>IGRP: Interior Gateway Routing Protocol (Cisco proprietary)</li></ul><h4 id="EGP"><a href="#EGP" class="headerlink" title="EGP"></a>EGP</h4><ul><li>BGP: Border Gateway Protoco</li></ul><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>每个节点和邻居节点交换信息。节点维护自己到邻居链路代价，下一跳到目的的距离向量。DV根据跟邻居交换信息来更新路由表</p><h3 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h3><p>要把消息告知拓扑中的所有其他路由器（不只是邻居）</p><p>每一个路由器都可以构建出整个拓扑，可以计算出到达每个目的网络的最短路径。路由器实际上使用<code>Dijkstra</code>算法</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>使用距离向量算法。距离靠多少跳来度量，距离向量每三十秒跟邻居交换一次。如果180秒没收到信息，说明邻居没了。用UDP包。</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先，利用链路状态路由算法。每十秒更新一次，直接用IP承载，不用UDP。</p><p>网络，主机和BGP路由器都是目的，每个路由器计算它到其他目的最短路径的SPF tree</p><p><img src="/picture/SPF.png"></p><h4 id="OSPF高级的功能"><a href="#OSPF高级的功能" class="headerlink" title="OSPF高级的功能"></a>OSPF高级的功能</h4><ul><li>安全性：所有的OSPF消息需要认证来组织恶意入侵</li><li>可以允许多个相同路径</li><li>对于每个链路，对于不同TOS有多种不同代价度量方式</li><li>综合单播和多播支持</li><li>在更大的域里面用层级OSPF</li></ul><h4 id="层级式OSPF"><a href="#层级式OSPF" class="headerlink" title="层级式OSPF"></a>层级式OSPF</h4><p>为了提升可扩充性，AS或许被划分为不同区域</p><ul><li>区域被32位Aera ID认定</li><li>区域里的路由器只知道区域内部的拓扑</li><li>限制链路状态信息洪泛到其他区域</li><li>区域边界路由器从其他区域总结信息</li></ul><p>每个区域必须连接到骨干区域(0.0.0.0)</p><ul><li>在区域间的分布式路由信息</li></ul><p>好处：划分区域的好处是将洪泛交换链路状态信息的范围局限于每一个区域 而不是整个的自治系统。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其 他区域的网络拓扑的情况。主干区域用于连通其他下层区域</p><p><img src="/picture/OSPFarea.png"></p><h4 id="RIP-vs-OSPF"><a href="#RIP-vs-OSPF" class="headerlink" title="RIP vs OSPF"></a>RIP vs OSPF</h4><p>RIP</p><ul><li>配置简单，适用于小型网络（小于15跳）</li><li>可分布式实现</li><li>收敛速度较慢</li><li>网络是一个平面，不适用于大规模网络</li></ul><p>OSPF</p><ul><li>收敛速度快，无跳数限制</li><li>支持不同服务类型选路</li><li>支持身份认证</li><li>支持层次式网络，适用于大规模复杂网络</li><li>集中式算法</li><li>每个节点需要维护全局拓扑</li><li>配置复杂</li></ul><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><h4 id="由于跨AS业务关系形成的拓扑和策略"><a href="#由于跨AS业务关系形成的拓扑和策略" class="headerlink" title="由于跨AS业务关系形成的拓扑和策略"></a>由于跨AS业务关系形成的拓扑和策略</h4><p>AS间的三种基本关系</p><ul><li>A是B的客户</li><li>A是B的供应商</li><li>A是B的伙伴</li></ul><p>客户给供应商交钱。伙伴之间不需要交钱，大概网络程度类似</p><p><img src="/picture/AS%E4%B8%9A%E5%8A%A1%E5%85%B3%E7%B3%BB.png"></p><p>为什么要伙伴关系</p><p><img src="/picture/peer.png"></p><p>AS为他们的客户提供传输服务，但是不提供它的peers之间的传输服务</p><p><img src="/picture/allow.png"></p><p>总结来说，AS拓扑反映了AS之间的业务关系，AS之间的业务关系反映了什么样的路由选择是可接受的</p><h4 id="基本想法"><a href="#基本想法" class="headerlink" title="基本想法"></a>基本想法</h4><p><img src="/picture/basic.png"></p><p>BGP是被DV算法所启发</p><p>每个目的地址进行通知，没有全局共享拓扑信息，在路径上进行迭代和分布式收敛。不过有四种关键的不同之处</p><h4 id="和BGP的不同之处"><a href="#和BGP的不同之处" class="headerlink" title="和BGP的不同之处"></a>和BGP的不同之处</h4><h5 id="1-不选择最短路径"><a href="#1-不选择最短路径" class="headerlink" title="1.不选择最短路径"></a>1.不选择最短路径</h5><p>BGP基于策略选择最好的路由，而不是最短的距离（比如最小的花费），如下图可能A可能选择ABC而不是AC</p><p><img src="/picture/abc.png"></p><h5 id="2-路径向量路由"><a href="#2-路径向量路由" class="headerlink" title="2.路径向量路由"></a>2.路径向量路由</h5><p>主要思想：message要记录整个路径</p><ul><li>DV：发送到目的的距离度量</li><li>BGP：发送到目的的整个路径</li></ul><p>好处：避免循环（遇到路径上有我自己的直接丢弃）；灵活并且有表现力</p><h5 id="3-选择性的路由通告"><a href="#3-选择性的路由通告" class="headerlink" title="3.选择性的路由通告"></a>3.选择性的路由通告</h5><p>出于策略上的原因，AS可以选择不发布到目的地的路由。因此，即使物理上相连，也不一定可达</p><h5 id="4-BGP或许会合并路由"><a href="#4-BGP或许会合并路由" class="headerlink" title="4.BGP或许会合并路由"></a>4.BGP或许会合并路由</h5><p>为了稳定性，BGP或许会把不同前缀地址的路由进行合并</p><h4 id="BGP的细节"><a href="#BGP的细节" class="headerlink" title="BGP的细节"></a>BGP的细节</h4><p>谁来运行BGP呢？自治系统中的边界路由器</p><p><img src="/picture/border.png"></p><p>Speak BGP意味着什么？</p><ul><li>实现BGP协议标准</li><li>说明要和其他BGP speaker交换什么消息</li><li>如何处理这些消息</li></ul><p>边界路由器之间使用eBGP会话，边界路由器和同一个AS内的其他路由器使用iBGP会话</p><p>eBGP：在不同AS的边界路由器之间